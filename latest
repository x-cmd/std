# shellcheck shell=sh disable=SC3043

# author:       Li Junhao           l@x-cmd.com
# maintainer:   Li Junhao

___x_cmd_list_resource(){
    printf "%s" "proxy
cowsay
theme
tldr
advise"
}

# Section : Unfinished ___x_cmd_official_which

# TODO: optimization. Consider sharing the big binary in a common folder.
# But that will introduce risk.
# How?
# 1. Local user $HOME/.x-cmd
# 2. Global sharing folder.
# Consider using the sha512 to calculate the file hash for this purpose.

___x_cmd_official_which(){
    X_CMD_SRC_PATH="$HOME/.x-cmd"
    local target="${1:-Provide target path}"
    local cache="$X_CMD_SRC_PATH/$target"

    local target2="${target#@}"
    if [ "$target2" != "$target" ]; then
        target=target2
        cache="$X_CMD_SRC_PATH/___users/$target"
        echo "Not supported yet." >&2
        return 1
    fi

    if CACHE="$cache" ___x_cmd_curl_gitx "$target" <<A
$(___x_cmd_mirror)
A
    then
        :
    fi

}

# EndSection

# Section : run by file: get_engine_by_file* and run_by_file*

___x_cmd_xrc_run(){
    local fp="${1:?filepath}"; shift

    local main
    if ! main="$(___x_cmd_ldict_get ___X_CMD_XRC_SET_MAIN_DICT "$fp")"; then
        ___x_cmd_xrc_source_file "$fp" # xrc
        local code=$?
        if ! main="$(___x_cmd_ldict_get ___X_CMD_XRC_SET_MAIN_DICT "$fp")"; then
            return "$code"
        fi
    fi

    "$main" "$@"
}

___x_cmd_source_run(){
    local ___x_cmd_x_source_run_filepath="${1:?filepath}";        shift

    ___x_cmd_source "$___x_cmd_x_source_run_filepath" "$@"

    # local ___xrc_module_name="${___x_cmd_x_source_run_filepath##*/}"

    # if command -v "___x_cmd_${___xrc_module_name}" >/dev/null; then
    #     "___x_cmd_${___xrc_module_name}" "$@"
    # elif command -v "${___xrc_module_name}" >/dev/null; then
    #     "${___xrc_module_name}" "$@"
    # else
#         cat 2>/dev/null <<A
# File not containing function: $___xrc_module_name
# Exit without execute: $___xrc_module_name "$@"
# A
#         return 1
    #     :
    # fi
}

___x_cmd_xsh_run()(
    ___x_cmd_source_run "$@"
)

___x_cmd_run_with_engine(){
    local engine="${1:?Please provide engine}";
    local filepath="${2:?Please provide filepath}";        shift 2
    case "$engine" in
        source)     ___x_cmd_source_run "$filepath" "$@";;
        xrc)        ___x_cmd_xrc_run "$filepath" "$@";;
        xsh)        ___x_cmd_xsh_run "$filepath" "$@";;
        7z)         ___x_cmd_main 7z x "$filepath" "$@"      ;;
        *)          ___x_cmd_main "$engine" "$filepath" "$@" ;;
    esac
}

___x_cmd_get_engine_by_file_header(){
    local filepath="${1:?Please provide filepath}"; shift
    case "$(head -n1 "$filepath")" in
        *source*)       printf "%s" source          ;;
        *xrc*)          printf "%s" xrc             ;;
        *xsh*)          printf "%s" xsh             ;;
        *python*)       printf "%s" python          ;;
        *perl*)         printf "%s" perl            ;;
        *ruby*)         printf "%s" ruby            ;;
        *node*)         printf "%s" node            ;;
        *ts*)           printf "%s" ts              ;;

        *bash*)         printf "%s" bash            ;;
        *zsh*)          printf "%s" zsh             ;;
        *fish*)         printf "%s" fish            ;;
        *ksh*)          printf "%s" ksh             ;;

        *sh*)           printf "%s" sh              ;;
        *)              return 127
    esac
}

___x_cmd_run_by_file_header(){
    local filepath="${1:?filepath}"; shift
    local engine
    if engine="$(___x_cmd_get_engine_by_file_header "$filepath")"; then
        ___x_cmd_run_with_engine "$engine" "$filepath" "$@"
    fi
}

___x_cmd_get_engine_by_file_ext(){
    local filepath="${1:?filepath}"; shift
    local ext="${filepath##*.}"
    case "$ext" in
        "$filepath")    return 126                  ;;
        py)             printf "%s" python          ;;
        pl)             printf "%s" perl            ;;
        rb)             printf "%s" ruby            ;;
        js)             printf "%s" node            ;;
        ts)             printf "%s" ts              ;;

        7z)             printf "%s" 7z              ;;

        bash)           printf "%s" bash            ;;
        zsh)            printf "%s" zsh             ;;
        fish)           printf "%s" fish            ;;
        ksh)            printf "%s" ksh             ;;
        sh)             printf "%s" sh              ;;

        *)              return 126                  ;;
    esac
}

___x_cmd_run_by_file_ext(){
    local filepath="${1:?filepath}"; shift
    local engine
    if engine="$(___x_cmd_get_engine_by_file_ext "$filepath")"; then
        ___x_cmd_run_with_engine "$engine" "$filepath" "$@"
    fi
}

___x_cmd_get_engine_by_file(){
    local filepath="${1:?filepath}"
    ___x_cmd_get_engine_by_file_ext "$filepath" || ___x_cmd_get_engine_by_file_header "$filepath"
}

___x_cmd_run_by_file(){
    local filepath="${1:?filepath}"; shift

    if [ -L "$filepath" ]; then
        filepath="$(___x_cmd_readlink_recursive "$filepath")"
        filepath="$(___x_cmd_abspath "$filepath")"
    fi

    if [ -x "$filepath" ]; then
        "$filepath" "$@"
        return
    fi

    local engine
    if engine="$(___x_cmd_get_engine_by_file "$filepath")"; then
        ___x_cmd_run_with_engine "$engine" "$filepath" "$@"
    else
        ___x_cmd_run_with_engine source "$filepath" "$@"
    fi
}

# EndSection

# Section : utils

___x_cmd_abspath(){
    local target_path="${1:-Please provide path}"
    # $(dirname "$filepath")/
    if [ "${target_path#/}" = "${target_path}" ]; then
        printf "%s" "$(cd "$(dirname "$target_path")" && pwd)/$(basename "$target_path")"
    else
        printf "%s" "$target_path"
    fi
}

# EndSection

# Section : Find And Execute at .x-cmd folder

___x_cmd_exe_workspace(){
    local filepath="${1:?filepath}"
    if [ -L "$filepath" ]; then
        # local target_path
        # target_path="$(___x_cmd_readlink_recursive "$filepath")"
        # target_path="$(___x_cmd_abspath "$target_path")"
        filepath="$(___x_cmd_readlink_recursive "$filepath")"
        filepath="$(___x_cmd_abspath "$filepath")"
    fi

    # TODO: notice. Filepath should be colorized and emphasized.
    # TODO: Hit enter twise will ignore this. But really, should we add this protection?
    if [ -z "$X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION" ]; then
        while true; do
            printf "%s" \
"=> Running file: $filepath ?
=> Enter or press y to continue, n to abort. default is y: " >&2

            read -r action
            case $action in
                n|no|nein|ne)  cat >&2 <<A
=> You could run the file by yourself:
\033[32m    x \"$filepath\" \033[;0m
A
                    return 1
                    ;;
                ""|y)            printf "%s\n" "";     break ;;
            esac
        done
    fi

    shift
    if [ -x "$filepath" ]; then
        "$filepath" "$@"
        local code=$?
        # Bad interpreter
        if [ $code != 126 ] && [ $code != 127 ]; then
            ___x_cmd_run_by_file_ext "$filepath" "$@"
            return
        fi
    fi

     # workspace
    ___X_CMD_WSROOT="$filepath"
    ___X_CMD_WSROOT="$(dirname "$___X_CMD_WSROOT")"
    ___X_CMD_WSROOT="$(cd "$___X_CMD_WSROOT" && pwd)/"
    ___X_CMD_WSROOT="${___X_CMD_WSROOT%/.x-cmd/*}"

    export ___X_CMD_WSROOT

    ___x_cmd_run_by_file "$filepath" "$@"
    if [ $? = 126 ]; then
        cat >&2 <<A
Cannot find out how to execute the file: "$filepath". Please specify the execution engine. For more information, consult 'x help'
A
    fi

}

# EndSection

# Section : utilties in static-build

# _x_xrc_static_run(){
#     local name=$1;  shift
#     xrc static-build
#     static_build_xrc "$name"
#     "_${name}_bin" "$@"
# }

___x_cmd_jq(){
    xrc static-build && static_build_init jq jq ___x_cmd_jq && ___x_cmd_jq          "$@"
}

___x_cmd_yq(){
    xrc static-build && static_build_init yq yq ___x_cmd_yq && ___x_cmd_yq          "$@"
}

___x_cmd_static_build_curl(){
    xrc static-build && static_build_init curl curl ___x_cmd_static_build_curl && ___x_cmd_static_build_curl  "$@"
}

___x_cmd_openssl(){
    xrc static-build && static_build_init openssl openssl ___x_cmd_openssl && ___x_cmd_openssl          "$@"
}

___x_cmd_tmux(){
    xrc static-build && static_build_init tmux tmux ___x_cmd_tmux && ___x_cmd_tmux          "$@"
}

___x_cmd_git(){
    xrc static-build && static_build_init git git ___x_cmd_git && ___x_cmd_git          "$@"
}

___x_cmd_nmap(){
    xrc static-build && static_build_init nmap nmap ___x_cmd_nmap && ___x_cmd_nmap  "$@"
}

___x_cmd_ncat(){
    xrc static-build && static_build_init nmap ncat ___x_cmd_ncat && ___x_cmd_ncat  "$@"
}

___x_cmd_nping(){
    xrc static-build && static_build_init nmap nping ___x_cmd_nping && ___x_cmd_nping  "$@"
}

___x_cmd_traceroute(){
    xrc static-build && static_build_init nmap traceroute ___x_cmd_traceroute && ___x_cmd_traceroute  "$@"
}

___x_cmd_bw(){
    xrc static-build && static_build_init bandwhich bandwhich ___x_cmd_bw && ___x_cmd_bw          "$@"
}

___x_cmd_exa(){
    xrc static-build && static_build_init exa exa ___x_cmd_exa && ___x_cmd_exa --color always "$@"
}

___x_cmd_dust(){
    xrc static-build && static_build_init dust dust ___x_cmd_dust && ___x_cmd_dust  "$@"
}

___x_cmd_sqlite3(){
    xrc static-build && static_build_init sqlite3 sqlite3 ___x_cmd_sqlite3 && ___x_cmd_sqlite3  "$@"
}

___x_cmd_procs(){
    xrc static-build && static_build_init procs procs ___x_cmd_procs && ___x_cmd_procs  "$@"
}

___x_cmd_bat(){
    xrc static-build && static_build_init bat bat ___x_cmd_bat && ___x_cmd_bat      "$@"
}

# EndSection

# Section : Runtime, future using xenv module

# . _v0/node
# . _v0/python

# node: node v12 and above, x using v16
# python: v3.6 and above, python using v14

# EndSection

# Section : run in concurrent

# ___X_CMD_EVAL_CON_SEPERATOR="$(printf "\001")"
___X_CMD_EVAL_CON_SEPERATOR=""

___x_cmd_eval_concurrent_single_head(){
    eval "$1"
    printf "%s" "${___X_CMD_EVAL_CON_SEPERATOR}"
}

___x_cmd_eval_concurrent_single_head_without_end(){
    printf "%s%s" "$(eval "$1")" "${___X_CMD_EVAL_CON_SEPERATOR}"
}

___x_cmd_eval_concurrent_single_tail(){
    local s
    local sep
    sep="$(printf "\001")"
    s="$(eval "$1"; printf "%s" "${___X_CMD_EVAL_CON_SEPERATOR}$sep")"
    cat
    printf "%s" "${s%$sep}"
}

___x_cmd_eval_concurrent_single_tail_without_end(){
    local s
    s="$(eval "$1")"
    cat
    printf "%s%s" "${s}" "${___X_CMD_EVAL_CON_SEPERATOR}"
}

# time x conjoin "sleep 1s; echo 1" "sleep 1s; echo 2" "sleep 1s; echo 3"
# time sep=, x conjoin "sleep 1s; echo 1" "sleep 1s; echo 2" "sleep 1s; echo 3"
___x_cmd_eval_concurrent_join(){

    if [ $# -le 1 ]; then
        eval "$@"
        return
    fi

    local cmd
    local result
    cmd='___x_cmd_eval_concurrent_single_head_without_end "$1"'
    local i
    for i in $(seq 2 $#); do
        if [ "$i" -eq $# ]; then
            cmd="$cmd | ___X_CMD_EVAL_CON_SEPERATOR= ___x_cmd_eval_concurrent_single_tail_without_end \"\$$i\""
        else
            cmd="$cmd | ___x_cmd_eval_concurrent_single_tail_without_end \"\$$i\""
        fi
    done
    # eval "$cmd"

    local ___X_CMD_EVAL_CON_SEPERATOR="${sep:-
}"
    eval "$cmd"
}

# time x con a= "sleep 1s; echo 1" b= "sleep 1s; echo 2" c= "sleep 1s; echo 3"
# time x con a= "sleep 1s; echo 1" b:= "sleep 1s; echo 2" c= "sleep 1s; echo 3"
___x_cmd_eval_concurrent_assign(){
    [ $# -le 1 ] && return 1

    local cmd
    local result
    local var_namelist=
    local i=2

    while [ $i -le $# ]; do
        local varname_eq="$(eval printf "%s" \""\$$((i-1))"\")"
        case "$varname_eq" in
            *:=)
                eval "${varname_eq%:=}=s"
                if [ -z "$var_namelist" ]; then
                    var_namelist="${varname_eq%:=}"
                else
                    var_namelist="$var_namelist
${varname_eq%:=}"
                fi

                if [ "$i" -eq 2 ]; then
                    cmd='___x_cmd_eval_concurrent_single_head "$2"'
                else
                    cmd="$cmd | ___x_cmd_eval_concurrent_single_tail \"\$$i\""
                fi
                ;;
            *=)
                eval "${varname_eq}"
                if [ -z "$var_namelist" ]; then
                    var_namelist="${varname_eq%=}"
                else
                    var_namelist="$var_namelist
${varname_eq%=}"
                fi

                if [ "$i" -eq 2 ]; then
                    cmd='___x_cmd_eval_concurrent_single_head_without_end "$2"'
                else
                    cmd="$cmd | ___x_cmd_eval_concurrent_single_tail_without_end \"\$$i\""
                fi
                ;;
            *)
                printf "%s\n" "Expect to be *= but get $varname_eq" >&2
                return 1
        esac

        i=$((i+2))
    done

    local ___X_CMD_EVAL_CON_SEPERATOR
    ___X_CMD_EVAL_CON_SEPERATOR="$(printf "\001")"

    result="$( eval "$cmd"; printf "$___X_CMD_EVAL_CON_SEPERATOR" )"
    local varname
    local item
    local IFS=""
    while read -r varname; do
        item="${result%%${___X_CMD_EVAL_CON_SEPERATOR}*}"
        eval "$varname=\"\$item\""
        [ "$item" = "$result" ] && break
        result="${result#*${___X_CMD_EVAL_CON_SEPERATOR}}"
    done <<A
$var_namelist
A

}

# EndSection

# Section : xaas

# queue
# cron

# EndSection

# Section : alias

___X_CMD_ALIAS_SEP="$(printf "\001")"
___X_CMD_ALIAS_ITEM_SEP="$(printf "\002")"

___x_cmd_alias(){
    case "$#" in
        1)      ___x_cmd_alias_ls   "$@" ;;
        2)
                if [ "${2#*=}" = "$2" ]; then
                    ___x_cmd_alias_print    "$@"
                else
                    ___x_cmd_alias_set      "$@"
                fi
                ;;
        *)      ___x_cmd_alias_set          "$@" ;;
    esac
}

___x_cmd_unalias(){
    ___x_cmd_alias_unset "$@"
}

___x_cmd_alias_init(){
    local obj="$1"
    eval "___X_CMD_ALIAS_SET_${obj}=\"\${___X_CMD_ALIAS_SET_${obj}:-\${___X_CMD_ALIAS_SEP}}\""
}

___x_cmd_alias_ls(){
    local obj="$1"
    local DATA
    eval "DATA=\"\${___X_CMD_ALIAS_SET_${obj}}\""

    # printf "%s" "${DATA#${___X_CMD_ALIAS_SEP}}" | tr "${___X_CMD_ALIAS_SEP}${___X_CMD_ALIAS_ITEM_SEP}" "\n\t"
    printf "%s" "${DATA#${___X_CMD_ALIAS_SEP}}" | awk -v RS="${___X_CMD_ALIAS_SEP}" -v FS="${___X_CMD_ALIAS_ITEM_SEP}" '
{
    print "  \033[31m" $1 "\033[0m=\033[32m" $2 "\t\t\033[34m" $3
}
'
}

___x_cmd_alias_echo(){
    local IFS=" "
    printf "%s" "$*"
}


___x_cmd_alias_set(){
    local obj="$1";     local name="$2";


    local code="${name#*=}"
    if [ "$code" = "$name" ]; then
        printf "CANNOT set alias for %s" "$*" >&2
        return 1
    fi

    name="${name%%=*}"
    # Put these things into the
    local desc="$3"

    ___x_cmd_alias_unset "$obj" "$name"

    eval "___X_CMD_ALIAS_SET_${obj}=\"\${___X_CMD_ALIAS_SET_${obj}}"'${name}${___X_CMD_ALIAS_ITEM_SEP}${code}${___X_CMD_ALIAS_ITEM_SEP}${desc}${___X_CMD_ALIAS_SEP}"'
}

___x_cmd_alias_clear(){
    local obj="$1"
    eval "___X_CMD_ALIAS_SET_${obj}=\"\${___X_CMD_ALIAS_SEP}\""
}

___x_cmd_alias_unset(){
    local obj="$1";     local name="$2";    shift 2
    local DATA
    eval "DATA=\"\${___X_CMD_ALIAS_SET_${obj}}\""

    local a="${DATA%%${___X_CMD_ALIAS_SEP}${name}${___X_CMD_ALIAS_ITEM_SEP}*}"
    if [ "$a" = "$DATA" ]; then
        return 1
    fi

    DATA="${DATA#*${___X_CMD_ALIAS_SEP}${name}${___X_CMD_ALIAS_ITEM_SEP}*${___X_CMD_ALIAS_SEP}}"
    DATA="$a${___X_CMD_ALIAS_SEP}${DATA}"

    eval "___X_CMD_ALIAS_SET_${obj}=\"$DATA\""
}

___x_cmd_alias_exec(){
    local obj="$1";     local name="$2";    shift 2
    local DATA
    eval "DATA=\"\${___X_CMD_ALIAS_SET_${obj}}\""
    local code="${DATA#*$___X_CMD_ALIAS_SEP${name}${___X_CMD_ALIAS_ITEM_SEP}}"
    ___X_CMD_ALIAS_EXEC_EXIST=
    if [ "$code" = "$DATA" ]; then
        return
    fi

    code="${code%%${___X_CMD_ALIAS_ITEM_SEP}*${___X_CMD_ALIAS_SEP}*}"
    eval "$code" "$@"
    ___X_CMD_ALIAS_EXEC_EXIST=1
}

___x_cmd_alias_info(){
    local obj="$1";     local name="$2";    shift 2
    local DATA
    eval "DATA=\"\${___X_CMD_ALIAS_SET_${obj}}\""
    local item="${DATA#*$___X_CMD_ALIAS_SEP${name}${___X_CMD_ALIAS_ITEM_SEP}}"
    ___X_CMD_ALIAS_EXEC_EXIST=
    if [ "$item" = "$DATA" ]; then
        return 1
    fi

    ___X_CMD_ALIAS_EXEC_EXIST=1
    item="${item%%${___X_CMD_ALIAS_SEP}*}"
    code="${item%%${___X_CMD_ALIAS_ITEM_SEP}*}"
    desc="${item#*${___X_CMD_ALIAS_ITEM_SEP}}"
}

___x_cmd_alias_print(){
    local obj="$1"
    local name="$2"
    local code
    local desc

    if ___x_cmd_alias_info "$@"; then
        printf "%s    %s       %s\n" "$name" "$code" "$desc"
        return
    fi
    return 1
}

# EndSection

# Section : x main function

___x_cmd_varset(){
    local _______variable_name="${1}"
    if [ "$#" -eq 1 ]; then
        eval printf "%s" "\"\$$_______variable_name\""
        return
    fi

    local result
    shift 1

    local ___X_CMD_EVAL_CON_SEPERATOR
    ___X_CMD_EVAL_CON_SEPERATOR="$(printf "\001")"

    result="$("$@"; printf "${___X_CMD_EVAL_CON_SEPERATOR}")"
    result="${result%${___X_CMD_EVAL_CON_SEPERATOR}}"
    eval "$_______variable_name=\"\$result\""
}

___x_cmd_varset_without_end(){
    local _______variable_name="${1}"
    if [ "$#" -eq 1 ]; then
        eval printf "%s" "\"\$$_______variable_name\""
        return
    fi

    local result
    shift 1
    result="$("$@")"
    eval "$_______variable_name=\"\$result\""
}

___x_cmd_arg_line(){
    awk -v every="${1:-1}" '

function printcode( len ){
    count = 0
    code=""
    for (j=1; j<=len; ++j) {
        e = result[j]
        gsub("\"", "\\\"", e)
        code = code " " "\"" e "\""
    }
    print code
}

{
    arrl = split($0, arr, /[ \t]+/)
    for (i=1; i<=arrl; ++i) {
        count ++
        result[ count ] = arr[i]
        if (count == every) {
            printcode( every )
        }
    }
}

END {
    if (count > 0) printcode( count )
}
'

}

___x_cmd_args(){
    local n="$1"; shift
    local IFS=" "

    ___x_cmd_arg_line "$n" | while read -r line; do
        eval \"\$@\" "$line"
    done
}


___x_cmd_shell_exec(){
    local shell="${1:?Provide shell}"
    shift
    if [ -x "/bin/$shell" ]; then
        # "/bin/$shell" $X_CMD_SRC_PATH/boot && ___x_cmd_source "$@"
        "/bin/$shell" "$@"
    elif [ -x "/usr/bin/$shell" ]; then
        # "/usr/bin/$shell" $X_CMD_SRC_PATH/boot && ___x_cmd_source "$@"
        "/usr/bin/$shell" "$@"
    else
        command "$shell" "$@"
    fi
}

___x_cmd_ls(){
    case "$1" in
        @*|*@*/*)
            ___x_cmd_file_ls "$@"
            return
            ;;
    esac
    ___x_cmd_exa        "$@"
}

___x_cmd_workspace_root(){
    local cur="${1:-.}"

    cur="$(cd "$cur" 1>/dev/null 2>&1 && pwd)"

    while [ ! "$cur" = "" ]; do
        if [ -d "$cur/.x-cmd" ]; then
            printf "%s" "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}

___x_cmd_main_otherwise(){
    local subcmd="$1";  shift

    ___x_cmd_alias_exec ___x_cmd "$subcmd" "$@"
    local code=$?
    if [ -n "$___X_CMD_ALIAS_EXEC_EXIST" ]; then
        return $?
    fi

    # static build
    # update the static-build files
    local p
    if ___x_cmd_which_one "$subcmd"; then
        p="$___X_CMD_WHICH_ONE_RESULT"
        case "$___X_CMD_WHICH_ONE_RESOURCE_TYPE" in
            workspace)      ___x_cmd_exe_workspace "$p" "$@" ;;
            local)          ___x_cmd_run_by_file "$p" "$@" ;;
            hub)            ___x_cmd_run_by_file "$p" "$@" ;;
            official)
                ___x_cmd_run_by_file "$p" "$@" ;;
        esac
        return
    else
        printf "%s" "Error" >&2
    fi
    printf "%s" "$p"
}

___x_cmd_ws(){
    local X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION=1

    local TGT

    if [ -z "$1" ]; then
        if TGT="$(___x_cmd_search_path . ".x-cmd/ws")"; then
            ___x_cmd_exe_workspace "$TGT/.x-cmd/ws"
            return
        else
            printf "%s\n" "Cannot find .x-cmd/ws" >&2
            return 1
        fi
    fi

    local RESOURCE_NAME="$1"; shift
    if TGT="$(___x_cmd_search_path . ".x-cmd/ws")"; then
        ___x_cmd_exe_workspace "$TGT/.x-cmd/ws" "$RESOURCE_NAME" "$@"
        return
    elif TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
        ___x_cmd_exe_workspace "$TGT/.x-cmd/$RESOURCE_NAME" "$@"
        return
    else
        printf "Workspace Resource Not found: %s\n" "$RESOURCE_NAME" >&2
        return 1
    fi
}


___x_cmd_ws_(){
    local X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION=1

    local RESOURCE_NAME="$1"; shift

    local TGT
    if TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
        ___x_cmd_exe_workspace "$TGT/.x-cmd/$RESOURCE_NAME" "$@"
        return
    else
        printf "Workspace Resource Not found: %s\n" "$RESOURCE_NAME" >&2
        return 1
    fi
}

___x_cmd_cd(){
    xrc x_fs/v0 && ___x_cmd_cd "$@"
}


___x_cmd_alias_init ___x_cmd

___x_cmd_main(){
    local IFS=" "

    local subcmd=$1; [ $# -gt 0 ] && shift
    case "$subcmd" in
        ""|help)                                printf "%s\n" "Show help" >&2; return 1 ;;

        alias)                                  ___x_cmd_alias      ___x_cmd "$@"   ;;
        unalias)                                ___x_cmd_unalias    ___x_cmd "$@"   ;;

        boot)                                   ( xrc x-cmd/_v0/boot && ___x_cmd_boot "$@"; ) ;;

        conjoin)                                ___x_cmd_eval_concurrent_join "$@" ;;
        con)                                    ___x_cmd_eval_concurrent_assign "$@" ;;

        *:=)                                    ___x_cmd_varset "${subcmd%:=}" "$@" ;;
        *=)                                     ___x_cmd_varset_without_end "${subcmd%=}" "$@" ;;

        args)                                   ___x_cmd_args "$@"      ;;
        arg1)                                   ___x_cmd_args 1 "$@"    ;;
        arg2)                                   ___x_cmd_args 2 "$@"    ;;
        arg3)                                   ___x_cmd_args 3 "$@"    ;;

        install)                                xrc install/v0 && ___x_cmd_install "$@" ;;

        cd)                                     ___x_cmd_cd "$@";;

        man)        ;;
        advise)                                 xrc advise/v0 && advise "$@" ;;
        env)        ;;

        login)                                  ( xrc hub/v0 && ___x_cmd_hub login "$@" ) ;;
        register)                               ( xrc hub/v0 && ___x_cmd_hub register "$@" ) ;;
        token)                                  ( xrc hub/v0 && ___x_cmd_hub token "$@" ) ;;
        hub)                                    ( xrc hub/v0 && ___x_cmd_hub "$@" ) ;;

        log)                                    xrc x-cmd/_v0/log && ___x_cmd_log "$@" ;;

        upgrade)
                                                ___XRC_UDPATE=1
                                                ___X_CMD_XRC_MODULE_IMPORTED=
                                                rm -rf "$___X_CMD_ROOT/.boot/boot" && eval "$(curl https://get.x-cmd.com)"
                                                ;;
        clear)                                  if ! grep "___x_cmd_http_get()" "$___X_CMD_ROOT/xrc/latest" >/dev/null 2>&1; then
                                                    ___xrc_log debug "'$___X_CMD_ROOT/xrc/latest' NOT found. Please manually clear cache folder: $___X_CMD_ROOT"
                                                    return 1
                                                fi
                                                rm -rf "$___X_CMD_ROOT" ;;
        reinstall)                              x clear && RELOAD=1 x upgrade ;;

        z)                                      (   xrc zuz && zuz z "$@"   ) ;;
        uz)                                     (   xrc zuz && zuz uz "$@"  ) ;;

        ubu|alp|deb|cen|bus)                    (   xrc xdk/v0 && xdk "$subcmd" "$@" ) ;;
        docker|dk|xdk)                          (   xrc xdk/v0 && xdk "$@" )   ;;
        sh|bash|zsh|fish|ksh|dash|ash)          ___x_cmd_shell_exec "$subcmd" "$@" ;;

        jar)                                    java -jar "$@" ;;
        java)                                   java "$@" ;;

        pip|pip3)                               xrc x-cmd/_v0/python && ___x_cmd_pip3 "$@" ;;
        python|py|python3|py3)                  xrc x-cmd/_v0/python && ___x_cmd_python3 "$@" ;;

        nvm)                                    xrc nvm/v0;     nvm "$@" ;;
        javascript|js|node)                     xrc x-cmd/_v0/node && ___x_cmd_node "$@" ;;
        npm)                                    xrc x-cmd/_v0/node && ___x_cmd_npm "$@" ;;
        npx)                                    xrc x-cmd/_v0/node && ___x_cmd_npx "$@" ;;
        ts)                                     local arg
                                                local argstr
                                                while [ $# -ge 0 ]; do
                                                    case "$arg" in
                                                        -*)     argstr="$argstr $arg"   ;;
                                                        *)      break
                                                    esac
                                                done
                                                local script
                                                # script="$(___x_cmd_official_which "$1")"
                                                script="$1"
                                                shift
                                                x npx @typeshell/exec "$argstr" "$script" "$@"
                                                ;;
        ruby|rb)                                ruby "$(___x_cmd_official_which "$2")" "$@"      ;;
        lua)            ;;

        7zr)                                    ( xrc p7zr/v0   &&  p7zr "$@" )     ;;
        7z)                                     ( xrc p7z/v0    &&  p7z "$@" )      ;;
        ls)                                     ___x_cmd_ls         "$@"             ;;
        ll)                                     ___x_cmd_exa  -l    "$@"             ;;
        ps)                                     ___x_cmd_procs      "$@"             ;;
        du)                                     ___x_cmd_dust       "$@"             ;;
        sqlite3)                                ___x_cmd_sqlite3    "$@"             ;;
        cat)
                                                if [ "$#" -ne 0 ]; then
                                                    ___x_cmd_bat "$@"
                                                else
                                                    ___x_cmd_bat "--help"
                                                fi
                                                ;;
        bw)                                     ___x_cmd_bw         "$@"             ;;
        jq)
                                                if [ "$#" -ne 0 ]; then
                                                    ___x_cmd_jq "$@"
                                                else
                                                    ___x_cmd_jq "--help"
                                                fi
                                                ;;
        yq)                                     ___x_cmd_yq         "$@"             ;;
        curl)                                   ___x_cmd_static_build_curl  "$@"     ;;
        openssl|ssl)                            ___x_cmd_openssl    "$@"             ;;
        tmux)                                   ___x_cmd_tmux       "$@"             ;;
        git)                                    ___x_cmd_git        "$@"             ;;
        nmap)                                   ___x_cmd_nmap       "$@"             ;;
        ncat)                                   ___x_cmd_ncat       "$@"             ;;
        nping)                                  ___x_cmd_nping      "$@"             ;;
        traceroute)                             ___x_cmd_traceroute "$@"             ;;
        run)                                    ___x_cmd_run_by_file "$@"            ;;
        search_path)                            ___x_cmd_search_path "$@"            ;;
        which|w)                                local p
                                                for p in "$@"; do
                                                    if ! ___x_cmd_which_one "$p"; then
                                                        printf "%s\n" "Fail to find path for $p" >&2
                                                        return
                                                    else
                                                        printf "%s\n" "$___X_CMD_WHICH_ONE_RESULT"
                                                    fi
                                                done
                                                ;;
        _x_cmd_advise_json)                     ___x_cmd_x_cmd_advise_json "$@" ;;
        wsroot)                                 ___x_cmd_workspace_root "$@" ;;
        ws)                                     ___x_cmd_ws "$@" ;;
        _ws)                                    ___x_cmd_ws_ "$@" ;;
        *)                                      ___x_cmd_main_otherwise "$subcmd" "$@" ;;

    esac
}

# EndSection

# Section : advise.json
___x_cmd_x_cmd_advise_json(){
    cat <<A
{
  "boot": {
      "cat": null,
      "which|w": null,
      "mod": {
          "add|+": null,
          "del|-": "x initrc mod ls",
          "ls": null
      }
  },
  "install": {
      "ls": "--- list all software",
      "update": "--- update",
      "get": {
          "#1": "x install name",
          "#desc": "get software installation command"
      },
      "run": {
          "#1": "x install name",
          "#desc": "run software installation command"
      },
      "#1": "x install name"
  },
  "config": {
      "tab": null,
      "ssh": null,
      "sshd": null
  },
  "man": { },
  "env": { },
  "login": { },
  "register": { },
  "token": { },
  "hub": {
      "file": {
          "ls": null,
          "which": "x hub file ls",
          "upload": "x hub file ls",
          "share": "x hub file ls",
          "private": "x hub file ls"
      },
      "login": null,
      "register": null,
      "token": null
  },
  "log": {
      "init": { },
      "timestamp": {
          "on": { },
          "off": { }
      },
      "#n": "xrc x-cmd/_v0/log && ___x_cmd_log_completer"
  },
  "upgrade": { },
  "clear": { },
  "reinstall": { },
  "z": null,
  "uz": null,
  "ubu|alp|deb|cen|bus": {
      "alias": { },
      "run": {
          "centos": { },
          "ubuntu": { },
          "alpine": { },
          "busybox": { }
      },
      "exec": { },
      "empower": { },
      "centos": { },
      "ubuntu": { },
      "alpine": { },
      "busybox": { }
  },
  "docker|dk|xdk": {
      "alias": { },
      "run": {
          "centos": { },
          "ubuntu": { },
          "alpine": { },
          "busybox": { }
      },
      "exec": { },
      "empower": { },
      "centos": { },
      "ubuntu": { },
      "alpine": { },
      "busybox": { }
  },
  "sh|bash|zsh|fish|ksh|dash|ash": "___advise_ls",
  "jar": "___advise_ls",
  "java": "___advise_ls",
  "pip|pip3": "___advise_ls",
  "python|py|python3|py3": "___advise_ls",
  "nvm": null,
  "javascript|js|node": "___advise_ls",
  "npm": null,
  "npx": null,
  "ts": null,
  "ruby|rb": null,
  "lua": null,
  "jq": null,
  "yq": null,
  "cat|du": "___advise_ls",
  "ls|ll|cd": "___advise_ls",
  "ps|procs": null,
  "nmap": null,
  "ncat": null,
  "nping": null,
  "traceroute": null,
  "sqlite3": null,
  "run": { },
  "search_path": { },
  "which": { },
  "wsroot": { },
  "#1": "___x_cmd_list_resource",
  "#n": "___advise_get_result 1"
}
A
    return 126
}
# EndSection

x(){
    ___x_cmd_main "$@"
}

if [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]; then
    # if you use xrc that you must have advise
    # xrc advise/v0
    advise x
fi

# TODO: We should have a better solution for this.
X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION=1
