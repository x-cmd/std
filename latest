# shellcheck shell=sh disable=SC3043

xrc param/v0

# Section: main

___x_cmd_theme_control(){
    local zinit
    local font
    zinit="$([ -n "$ZSH_VERSION" ] && printf "zinit    \"init the zsh environment\"")"
    font="$([ -z "$SSH_CONNECTION" ] && [ ! -f "/.dockerenv" ] && printf "font    \"install powerline font\"")"
    param:dsl <<A
subcommands:
    ls          "list all theme"
    use         "use theme when starting the shell"
    try         "try theme"
    rollback    "use last theme"
    ${zinit}
    ${font}
    unset       "unset the theme"
A
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_theme_control _param_help_doc
        return 0
    fi

    "___x_cmd_theme_control_${PARAM_SUBCMD}" "$@"
}

___x_cmd_theme_which(){
    local name="${1:?Provide name}"

    local ___X_CMD_CURL_UPDATE="${___X_CMD_CURL_UPDATE}"

    local CACHE="$___X_CMD_ROOT/.tmp/theme/$name"
    if find "$CACHE" -mmin 60 2>/dev/null 1>&2; then
        ___X_CMD_CURL_UPDATE=
    fi

    local url="https://gitee.com/x-cmd/theme/raw/main/$name"
    if [ "$___X_CMD_IN_CHINA_NET" != 1 ]; then
        url="https://raw.githubusercontent.com/x-cmd/theme/main/$name"
    fi

    ___x_cmd_curl "$url" && printf "%s" "$CACHE"
}

# EndSection

# Section: subcmd

___x_cmd_theme_control_ls() {
    local fp
    if fp="$(___x_cmd_theme_which index.yml)"; then
        awk '{ print $2; }' <"$fp"
    fi
}

xrc theme/_v0/lib
xrc theme/_v0/style

___x_cmd_theme_control_use(){
    local name="${1:-ys}"
    ___x_cmd_theme_control_try "$name"
    x boot rc add x-theme x theme try "$name"
}

___x_cmd_theme_control_unset(){
    local ___X_CMD_ROOT_RC="$___X_CMD_ROOT/.boot/rc"
    if [ ! -f "$___X_CMD_ROOT_RC" ]; then
        printf "%s\n" "The configuration file does not exist,unset failed"
        return 0
    fi
    x boot rc del x-theme
    printf "\033[32munset the theme successfully! \033[1;33mNow you can restart your terminal.\033[0m \n"
}

___x_cmd_theme_control_try(){
    local name="${1}"

    case "$name" in
        ys|"")
            ___x_cmd_theme_load_format "$(xrc which theme/_v0/ys)"
            return
            ;;
        */*)
            ___x_cmd_theme_load_format "$(xrc which "$name")"
            return
            ;;
    esac

    ___x_cmd_theme_control_ls | awk -v name="$name" '
$1=name{ code=1; exit 0; };
END{
    if (code==1) exit 0
    else exit 1
}'

    local code=$?
    if [ "$code" != 0 ]; then
        return $code
    fi

    local fp
    if fp="$(___x_cmd_theme_which "$name")"; then
        ___x_cmd_theme_load_format "$fp"
    fi
    return 1
}

___x_cmd_theme_control_rollback(){
    :
}

___x_cmd_theme_control_zinit(){
    local _have_loaded_theme
    _have_loaded_theme=$([ -f "$___X_CMD_ROOT/.boot/rc" ] && x boot rc ls | grep 'x-theme')
    # load theme
    [ -z "$_have_loaded_theme" ] && ___x_cmd_theme_control_use ""
    # load zsh plugins
    [ -z "$ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME" ] && ___x_cmd_theme_control_use_plugin "zsh-autosuggestions"
    [ -z "$ZSH_HIGHLIGHT_REVISION" ] && ___x_cmd_theme_control_use_plugin "zsh-syntax-highlighting"
    # load font
    [ -z "$SSH_CONNECTION" ] && [ ! -f "/.dockerenv" ] && ___x_cmd_theme_control_font
    printf "%s\n" "[x-cmd]: Successfully initialized."
}

___x_cmd_theme_control_use_plugin() {
    { [ -z "$1" ] || [ -z "$ZSH_VERSION" ]; } && return 1
    xrc theme/third-party/"$1"/"$1".plugin.zsh
    x boot rc add "x-plugin-$1" "[ -n \"\$ZSH_VERSION\" ] && xrc theme/third-party/$1/$1.plugin.zsh"
}

___x_cmd_theme_control_font() {
    local _font_dir
    local _font_name
    if [ "$(uname)" = "Darwin" ]; then
        # MacOS
        _font_dir="$HOME/Library/Fonts"
        _font_name='MonacoPL.ttf'
    else
        # Linux
        _font_dir="$HOME/.local/share/fonts"
        mkdir -p "$_font_dir"
        _font_name='CascadiaCodePL.ttf'
    fi
    if [ -f "$_font_dir/$_font_name" ];then
        printf "%s\n" "[x-cmd]: font already installed: $_font_dir"
        return 0
    fi
    local CACHE="$_font_dir/$_font_name"
    local url="https://gitee.com/x-cmd/theme/raw/main/font/$_font_name"
    if [ "$___X_CMD_IN_CHINA_NET" != 1 ]; then
        url="https://raw.githubusercontent.com/x-cmd/theme/main/font/$_font_name"
    fi
    ___x_cmd_curl "$url"
    if [ -n "$(command -v fc-cache)" ] ; then
        printf "%s\n" "[x-cmd]: Resetting font cache, this may take a moment..."
        fc-cache -f "$_font_dir"
    fi
}

# Best efforts to retrieve background color.
# Works: terminal app in macos, ...
# Now works: vscode, ...
# Reference:
# 1. https://unix.stackexchange.com/questions/172548/how-to-determine-the-current-color-of-the-console-output
# 2. https://newbedev.com/how-to-determine-a-terminal-s-background-color
___x_cmd_theme_control_get_current_background_color(){
    local oldstty
    oldstty=$(stty -g)
    local Ps=${1:-11}

    stty raw -echo min 0 time 0
    printf "\033]$Ps;?\033\\"
    sleep 0.00000001

    local answer
    read -r answer
    local result
    result=${answer#*;}
    stty "$oldstty"
    # Remove escape at the end.
    printf "%s" "$result" | sed 's/[^rgb:0-9a-f/]\+$//'
}

# EndSection


# Section: test

___x_cmd_theme_control_is_using_x_theme(){
    :
}

___x_cmd_theme_control_subenv_prompt_clear(){
    ___X_CMD_THEME_CONTROL_SUBENV_PROMPT=
}

___x_cmd_theme_control_subenv_prompt(){
    local subenv_prompt="${1}"

    if [ -z "$1" ]; then
        printf "%s\n" "$___X_CMD_THEME_CONTROL_SUBENV_PROMPT"
        return
    fi

    if ___x_cmd_theme_control_is_using_x_theme; then
        # ___x_cmd_theme_control_subenv
        ___X_CMD_THEME_CONTROL_SUBENV_PROMPT="${subenv_prompt}"
    else
        :
    fi
}

# using dict

___x_cmd_theme_control_env(){
    xrc dict/v0
    case "$#" in
        0)      dict :___x_cmd_theme_env ls ;;
        1)      dict :___x_cmd_theme_env get "$1" ;;
        2)      dict :___x_cmd_theme_env put "$1" "$2" ;;
        *)      printf "%s\n" "___x_cmd_theme_control_env [key] [val]" >&2
    esac
}

# EndSection

