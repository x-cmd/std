# shellcheck shell=sh disable=SC2039,SC2142,SC3043

# author:       Li Junhao           l@x-cmd.com

xrc dict/latest
xrc jo/latest

# Section 1: Global definitions
############################

___X_CMD_PARAM_AWK_RE_PATH="$(xrc which awk/lib/re.awk)"
___X_CMD_PARAM_AWK_DSL_PATH="$(xrc which param/lib/dsl.awk)"
___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/main.awk)"
PARAM_DEFAULT_VAR_PREFIX=___X_CMD_X_BASH_PARAM_DEFAULT___
PARAM_TYPE_VAR_PREFIX=___X_CMD_X_BASH_PARAM_TYPE___
PARAM_SUBCMD_VAR_PREFIX=___X_CMD_X_BASH_PARAM_SUBCMD___

# DICT_KEYS_SEP conflict. But it is OK.
PARAM_ARG_SEP="$(printf "\005")"         # ARG_SEP in awk script
PARAM_RS_SEP="${DICT_SEP}"
# EndSection

# Section 2: param_marg -- Helper for param user: Handle param marg
# Example:
# for idx in $(param_marg optname); do
#     param_marg optname "$idx"
# done

param_marg() {
    local a=${1:?Provide option name}
    if [ -n "$2" ]; then
        param_marg_get "$@"
    else
        param_marg_seq "$@"
    fi
}

param_marg_get() {
    local a=${1:?Provide option name}
    local n=${2:?Provide option argument index}
    if [ -z "$3" ]; then
        eval "echo \"\$${a}_${n}\""
    else
        eval "echo \"\$${a}_${n}_${3}\""
    fi
}

param_marg_len() {
    local a=${1:?Provide option name}
    eval "echo \"\$${a}_n\""
}

param_marg_seq() {
    local a=${1:?Provide option name}
    seq "$(param_marg_len "$a")"
}

# EndSections

# Section 3: param type definition
# Example:
# param_type    gitee     repo
# param_type    gitee     user      =~  [A-Za-z0-9_]+
# param_type    gitee     access    =   private         public          inner-public
# param_type    gitee     License   -  <"$(xrc cat gh/lib/_type/license)"

# TODO: check
param_type(){
    local app_name="${1:?Provide app name}"
    shift

    local result
    if [ "$2" != - ]; then
        result="$*"
    else
        result="$1 = $(cat | awk '{ str=$0 ; gsub("\"", "\\\"", str) ; printf(" \"%s\"", str) }')"
    fi

    local varname="${PARAM_TYPE_VAR_PREFIX}${app_name}"
    eval "$varname=\"\${$varname}\${PARAM_ARG_SEP}\${result}\""
}

param_type_unset(){
    local app_name="${1:?Provide app name}"
    local varname="${PARAM_TYPE_VAR_PREFIX}${app_name}"
    eval "$varname="
}

param_type_pprint(){
    _param_type_print "$@" | tr "$PARAM_ARG_SEP" "\n"
}

_param_type_print() {
    local app_name="${1:?Provide app name}"
    local varname="${PARAM_TYPE_VAR_PREFIX}${app_name}"
    eval echo "\"\$$varname\""
}

# EndSections

# Section 4: param default management
# param_default put <scope> <key> <value>
# eg. param_default put gitee/$O repo x-bash
# eg. param_default put gitee/$O user edwinjhlee
# eg. param_default put gitee/$O access public

param_default() {
    local op="$1"
    local app_name=${2:?Provide Object}
    shift 2

    local object_name=${app_name#*/}
    if [ "$object_name" = "$app_name" ]; then
        object_name=
    fi
    app_name=${app_name%%/*}

    local O="${PARAM_DEFAULT_VAR_PREFIX}${app_name}"

    case "$op" in # yml seemed to be a better
        load)
                    local json_path="${1:?Provide path in function param_default}"
                        dict @"${O}" load_json "$(cat "$json_path")"
                    ;;
        dump)       if [ -n "$object_name" ]; then
                        dict @"${O}" scope "${object_name}" | ___dict_pjson
                    else
                        dict @"${O}" json
                    fi ;;
        dump_raw)   if [ -n "$object_name" ]; then
                        dict @"${O}" scope "${object_name}" | dict @"${O}" dump
                    else
                        dict @"${O}" dump
                    fi ;;
        clear)      dict @"${O}" free ;;
        get)        dict @"${O}" get ${object_name:+"${object_name}"} "${1:?Provide [key] name in function 'param_default get'}" ;;
        put | set )
                    dict @"${O}" put ${object_name:+"${object_name}"} "${1:?Provide key name in function param_default}" "${2:?Provide [value] in function 'param_default put'}" ;;
        remove)
                    if [ -n "$object_name" ]; then
                        dict @"${O}" remove "${object_name:+"${object_name}"}$PARAM_ARG_SEP${1:?Provide key name in function param_default}"
                    else
                        dict @"${O}" remove "${1:?Provide key name in function param_default}"
                    fi ;;
        export)     export "${O?}" ;;
        *)
        ;;
    esac
}
# EndSections

# Section 5: param scope and plugin

___param_scope_set_id(){
    ___X_CMD_PARAM_SCOPE="${1:?Please provide scope}"
}
alias param:scope='local ___X_CMD_PARAM_SCOPE;    ___param_scope_set_id'

___param_plugin_set_id(){
    ___X_CMD_PARAM_PLUGIN_ID="${1:?Please provide scope}"
}
alias param:plugin="local ___X_CMD_PARAM_PLUGIN_ID; ___param_plugin_set_id"

# EndSection

# Section 6: param main

___param_dsl_set(){
    if [ -z "$1" ]; then
        ___X_CMD_PARAM_DSL="$(cat)"
    else
        ___X_CMD_PARAM_DSL="$1"
    fi
}

alias param:dsl="local ___X_CMD_PARAM_DSL; ___param_dsl_set"
# TODO: there is a better design.
alias param:run='local IFS; ___x_cmd_param_int "$@" ; local _x_cmd_param_code="$?" ; [ "$_x_cmd_param_code" = 125 ] && eval "$(_param_main "$@" )" || return $_x_cmd_param_code'

___x_cmd_param_int(){
    case "$1" in
        _x_cmd_help | _param_help_doc)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/help.awk)" _param_main
            ;;
        _x_cmd_advise_json)
            eval "$(___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/advise.awk)" _param_main "$@")"
            ;;
        _param_list_subcmd)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/meta.awk)" _param_main "$@"
            ;;
        _param_has_subcmd)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/meta.awk)" _param_main "$@"
            ;;
        _ls_subcmd)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/meta.awk)" _param_main "$@"
            ;;
        _ls_option)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/meta.awk)" _param_main "$@"
            ;;
        _ls_option_name)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/meta.awk)" _param_main "$@"
            ;;
        _ls_option_subcmd)
            ___X_CMD_PARAM_AWK_PATH="$(xrc which param/lib/meta.awk)" _param_main "$@"
            ;;
        *)  return 125
    esac
    return
}

alias param:void="local ___X_CMD_PARAM_SCOPE;  local ___X_CMD_PARAM_DSL;  param:run"

___param_eval_echo(){
    local IFS
    printf "%s\n" "$*" >&2
    eval "$*"
}

alias param:debug='local IFS; ___param_eval_echo "$(_param_main "$@"  )"'
if [ "${-#*i}" != "$-" ]; then
    xrc ui/latest
fi

# TODO: our goal, 6ms
_param_main() {
    if [ -n "$___X_BASH_PARAM_PLUGIN_ID" ]; then
        if [ "plugin" = "$1" ]; then
            printf "%s\n" shift
            printf "param_plugin \"\$@\"\n"
            printf "return 0 >/dev/null 2>/dev/null"
            return 0
        fi
    fi

    local ___X_CMD_PARAM_IS_INTERACTIVE=0
    # Maybe for JUDGE
    # TO OPTIMIZE
    if [ -t 0 ] && [ "${-#*i}" != "$-" ]; then
        ___X_CMD_PARAM_IS_INTERACTIVE=1
    fi

    local ___X_CMD_PARAM_STDERR_IS_TTY=0
    if [ -t 2 ] ; then
        ___X_CMD_PARAM_STDERR_IS_TTY=1
    fi

    {
        local IFS
        if [ -z "$___X_CMD_PARAM_SCOPE" ]; then
            # line 1: global types and subcmds are null
            printf "$PARAM_RS_SEP$PARAM_RS_SEP"
        else
            # line 1: global types and subcmds
            _param_type_print "${___X_CMD_PARAM_SCOPE%%/*}"
            printf "$PARAM_RS_SEP"
            if [ "${___X_CMD_PARAM_PLUGIN_ID}" != "" ] ;then
                ___param_plugin_print "${___X_CMD_PARAM_PLUGIN_ID}"
            fi
            printf "$PARAM_RS_SEP"
        fi

        printf "%s" "$___X_CMD_PARAM_DSL"
        # line 3: running argument lines
        IFS="$PARAM_ARG_SEP"                    # ARG_SEP in awk script
        printf "$PARAM_RS_SEP%s$PARAM_RS_SEP" "$*"

        # line 4: default dict
        if [ -n "$___X_CMD_PARAM_SCOPE" ]; then
            param_default dump_raw "$___X_CMD_PARAM_SCOPE"
        fi
    } | awk \
            -v OBJECT_NAME="${O}" \
            -v ARG_SEP="$PARAM_ARG_SEP" \
            -v RS="$PARAM_RS_SEP" \
            -v COLUMNS="$COLUMNS" \
            -v IS_INTERACTIVE="$___X_CMD_PARAM_IS_INTERACTIVE" \
            -v IS_TTY="$___X_CMD_PARAM_STDERR_IS_TTY" \
            -f "$___X_CMD_PARAM_AWK_RE_PATH" \
            -f "$___X_CMD_PARAM_AWK_DSL_PATH" \
            -f "$___X_CMD_PARAM_AWK_PATH"
    local code="$?"
    # Notice: Must clear this variable.
    ___X_CMD_PARAM_SCOPE=
    return $code
}

# EndSections

# Section 7: param plugin

param_plugin(){
    local op="$1";      shift
    case "$op" in
        add)        ___param_plugin_define "$@"     ;;
        del)        ___param_plugin_del "$@"        ;;
        unset)      ___param_plugin_unset "$@"      ;;
        pprint)     ___param_plugin_pprint "$@"     ;;
        *) printf "%s" "param_plugin: Unknown operation '$op'" ;;
    esac
}

___param_plugin_define() {
    # FIXME: To use no app name to add the subcmd plugin.
    local plugin_id="$___X_CMD_PARAM_PLUGIN_ID"
    local subcmd="${1:?Provide subcmd}"
    local desc="${2:?Provide description}"

    local varname="${PARAM_SUBCMD_VAR_PREFIX}${plugin_id}"
    local result="$subcmd $desc"
    eval "$varname=\"\${$varname}\${PARAM_ARG_SEP}\${result}\""
}

# Maybe using dict?
___param_plugin_del() {
    # FIXME: To use no app name to add the subcmd plugin.
    local plugin_id="$___X_CMD_PARAM_PLUGIN_ID"
    local subcmd="${1:?Provide subcmd}"

    # TODO: Not provided
}

___param_plugin_unset() {
    local plugin_id="$___X_CMD_PARAM_PLUGIN_ID"
    local varname="${PARAM_SUBCMD_VAR_PREFIX}${plugin_id}"
    eval "$varname="
}

___param_plugin_pprint() {
    ___param_plugin_print "$@" | tr "$PARAM_ARG_SEP" "\n"
}

___param_plugin_print() {
    local plugin_id="${1:?Provide plugin id}"
    local varname="${PARAM_SUBCMD_VAR_PREFIX}${plugin_id}"
    eval echo "\"\$$varname\""
}

# EndSection

# Section 8: param:flag2bool param:option2json

___x_cmd_param_flag_to_bool(){
    local true="${true:-true}"
    local false="${false:-false}"

    local ___name
    local ___key
    local ___value
    for ___name in "$@"; do
        ___key="${___name%=*}"
        if [ "$___key" = "$___name" ]; then
            if eval [ -n \"\$"$___key"\" ]; then
                eval "$___key=$true"
            else
                eval "$___key=$false"
            fi
            continue
        fi

        ___value="${___name#*=}"
        case "$___value" in
            ^^*)
                if eval [ -n \"\$"${___value#^^}"\" ]; then
                    eval "$___key=$true"
                else
                    eval "$___key=$false"
                fi
                ;;
            ^*)
                if eval [ -z \"\$"${___value#^}"\" ]; then
                    eval "$___key=$true"
                else
                    eval "$___key=$false"
                fi
                ;;
            *)
                if eval [ -n \"\$"$___value"\" ]; then
                    eval "$___key=$true"
                else
                    eval "$___key=$false"
                fi
        esac
    done
}

alias param:flag2bool=___x_cmd_param_flag_to_bool

# param:option2json repository=repo has_wiki=^no_wiki enable_page=^^has_page
___x_cmd_param_option_to_json()(
    ___code="___x_cmd_jo dict"
    ___to_remove=""

    for ___name in "$@"; do
        case "$___name" in
            *=^^*)      ___key="${___name%%=*}"
                        if eval [ -n \"\$"${___name#*=^^}"\" ]; then
                            eval "$___key=true"
                        else
                            eval "$___key=false"
                        fi
                        ___code="$___code ${___key}"
                        ;;
            *=^*)       ___key="${___name%%=*}"
                        if eval [ -z \"\$"${___name#*=^}"\" ]; then
                            eval "$___key=true"
                        else
                            eval "$___key=false"
                        fi
                        ___code="$___code ${___key}"
                        ;;
            *=*)        ___key="${___name%%=*}"
                        ___value="${___name#*=}"
                        ___to_remove="$___to_remove ${___value} "
                        eval "$___key=\"\$${___value}\""
                        ___code="$___code ${___key}"
                        ;;
            -*)         ___to_remove="$___to_remove ${___name#-} " ;;
            +*)         ___code="$___code ${___name#+}" ;;
            *)          ___code="$___code ${___name}" ;;
        esac
    done

    while read -r ___option_name; do
        eval "[ -z \"\$""$___option_name""\" ] && ___to_remove=\"$___to_remove ${___option_name} \""
        if [ "${___to_remove#* "$___option_name" *}" = "$___to_remove" ]; then
            ___code="$___code $___option_name"
        fi
    done <<A
$(___x_cmd_param_int _ls_option_name)
A
    eval "$___code"
)

alias param:option2json=___x_cmd_param_option_to_json

# EndSection
