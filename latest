# Author:       Li Junhao   l@x-cmd.com             # xrc
# shellcheck    shell=sh    disable=SC3043,SC1091

# Section : run by file: get_engine_by_file* and run_by_file*

___x_cmd_xrc_run(){
    local fp="${1:?filepath}"; shift

    local main
    if ! main="$(___x_cmd_ldict get ___X_CMD_XRC_SET_MAIN_DICT "$fp")"; then
        ___x_cmd_xrc_source_file "$fp" # xrc
        local code=$?
        if ! main="$(___x_cmd_ldict get ___X_CMD_XRC_SET_MAIN_DICT "$fp")"; then
            return "$code"
        fi
    fi

    "$main" "$@"
}

___x_cmd_source_run(){
    local ___x_cmd_x_source_run_filepath="${1:?filepath}";        shift

    ___x_cmd_source "$___x_cmd_x_source_run_filepath" "$@"

    # local ___xrc_module_name="${___x_cmd_x_source_run_filepath##*/}"

    # if command -v "___x_cmd_${___xrc_module_name}" >/dev/null; then
    #     "___x_cmd_${___xrc_module_name}" "$@"
    # elif command -v "${___xrc_module_name}" >/dev/null; then
    #     "${___xrc_module_name}" "$@"
    # else
#         cat 2>/dev/null <<A
# File not containing function: $___xrc_module_name
# Exit without execute: $___xrc_module_name "$@"
# A
#         return 1
    #     :
    # fi
}

___x_cmd_xsh_run()(
    ___x_cmd_source_run "$@"
)

___x_cmd_run_with_engine(){
    local engine="${1:?Please provide engine}";
    local filepath="${2:?Please provide filepath}";        shift 2
    case "$engine" in
        source)     ___x_cmd_source_run "$filepath" "$@";;
        xrc)        ___x_cmd_xrc_run "$filepath" "$@";;
        xsh)        ___x_cmd_xsh_run "$filepath" "$@";;
        7z)         ___x_cmd_main 7z x "$filepath" "$@"      ;;
        *)          ___x_cmd_main "$engine" "$filepath" "$@" ;;
    esac
}

___x_cmd_get_engine_by_file_header(){
    local filepath="${1:?Please provide filepath}"; shift
    case "$(head -n1 "$filepath")" in
        *source*)       printf "%s" source          ;;
        *xrc*)          printf "%s" xrc             ;;
        *xsh*)          printf "%s" xsh             ;;
        *python*)       printf "%s" python          ;;
        *perl*)         printf "%s" perl            ;;
        *ruby*)         printf "%s" ruby            ;;
        *node*)         printf "%s" node            ;;
        *ts*)           printf "%s" ts              ;;

        *bash*)         printf "%s" bash            ;;
        *zsh*)          printf "%s" zsh             ;;
        *fish*)         printf "%s" fish            ;;
        *ksh*)          printf "%s" ksh             ;;

        *sh*)           printf "%s" sh              ;;
        *)              return 127
    esac
}

___x_cmd_run_by_file_header(){
    local filepath="${1:?filepath}"; shift
    local engine
    if engine="$(___x_cmd_get_engine_by_file_header "$filepath")"; then
        ___x_cmd_run_with_engine "$engine" "$filepath" "$@"
    fi
}

___x_cmd_get_engine_by_file_ext(){
    local filepath="${1:?filepath}"; shift
    local ext="${filepath##*.}"
    case "$ext" in
        "$filepath")    return 126                  ;;
        py)             printf "%s" python          ;;
        pl)             printf "%s" perl            ;;
        rb)             printf "%s" ruby            ;;
        js)             printf "%s" node            ;;
        ts)             printf "%s" ts              ;;

        7z)             printf "%s" 7z              ;;

        bash)           printf "%s" bash            ;;
        zsh)            printf "%s" zsh             ;;
        fish)           printf "%s" fish            ;;
        ksh)            printf "%s" ksh             ;;
        sh)             printf "%s" sh              ;;

        *)              return 126                  ;;
    esac
}

___x_cmd_run_by_file_ext(){
    local filepath="${1:?filepath}"; shift
    local engine
    if engine="$(___x_cmd_get_engine_by_file_ext "$filepath")"; then
        ___x_cmd_run_with_engine "$engine" "$filepath" "$@"
    fi
}

___x_cmd_get_engine_by_file(){
    local filepath="${1:?filepath}"
    ___x_cmd_get_engine_by_file_ext "$filepath" || ___x_cmd_get_engine_by_file_header "$filepath"
}

___x_cmd_run_by_file(){
    local filepath="${1:?filepath}"; shift

    if [ -L "$filepath" ]; then
        filepath="$(___x_cmd_readlink_recursive "$filepath")"
        filepath="$(___x_cmd_abspath "$filepath")"
    fi

    if [ -x "$filepath" ]; then
        # In bash and dash. The file mount into the docker container using [ -x <path> ]
        #   does not correctly determine whether the file has execute permissions or not.
        exec 3>&1
        local err
        if err="$("$filepath" "$@" 2>/dev/stdout 1>&3)" || [ "${err%Permission denied}" = "$err" ]; then
            exec 3<&-
            printf "%s\n" "$err" >&2
            return
        fi
    fi

    local engine
    if engine="$(___x_cmd_get_engine_by_file "$filepath")"; then
        ___x_cmd_run_with_engine "$engine" "$filepath" "$@"
    else
        ___x_cmd_run_with_engine source "$filepath" "$@"
    fi
}

# EndSection

# Section : Find And Execute at .x-cmd folder

___x_cmd_abspath(){
    local target_path="${1:-Please provide path}"
    # $(dirname "$filepath")/
    if [ "${target_path#/}" = "${target_path}" ]; then
        printf "%s" "$(cd "$(dirname "$target_path")" && pwd)/$(basename "$target_path")"
    else
        printf "%s" "$target_path"
    fi
}

___x_cmd_exe_workspace(){
    local filepath="${1:?filepath}"
    if [ -L "$filepath" ]; then
        # local target_path
        # target_path="$(___x_cmd_readlink_recursive "$filepath")"
        # target_path="$(___x_cmd_abspath "$target_path")"
        filepath="$(___x_cmd_readlink_recursive "$filepath")"
        filepath="$(___x_cmd_abspath "$filepath")"
    fi

    # TODO: notice. Filepath should be colorized and emphasized.
    # TODO: Hit enter twise will ignore this. But really, should we add this protection?
    if [ -z "$X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION" ]; then
        while true; do
            printf "%s" \
"=> Running file: $filepath ?
=> Enter or press y to continue, n to abort. default is y: " >&2

            read -r action
            case $action in
                n|no|nein|ne)  cat >&2 <<A
=> You could run the file by yourself:
\033[32m    x \"$filepath\" \033[;0m
A
                    return 1
                    ;;
                ""|y)            printf "%s\n" "";     break ;;
            esac
        done
    fi

    shift
    if [ -x "$filepath" ]; then
        exec 3>&1
        local err
        if err="$("$filepath" "$@" 2>/dev/stdout 1>&3)"; then
            exec 3<&-
            printf "%s\n" "$err" >&2
            return
        else
            local code=$?
            # Bad interpreter
            if [ $code != 126 ] && [ $code != 127 ] && [ "${err%Permission denied}" = "$err" ]; then
                ___x_cmd_run_by_file_ext "$filepath" "$@"
                return
            fi
        fi
    fi

     # workspace
    ___X_CMD_WSROOT="$filepath"
    ___X_CMD_WSROOT="$(dirname "$___X_CMD_WSROOT")"
    ___X_CMD_WSROOT="$(cd "$___X_CMD_WSROOT" && pwd)/"
    ___X_CMD_WSROOT="${___X_CMD_WSROOT%/.x-cmd/*}"

    export ___X_CMD_WSROOT

    ___x_cmd_run_by_file "$filepath" "$@"
    if [ $? = 126 ]; then
        cat >&2 <<A
Cannot find out how to execute the file: "$filepath". Please specify the execution engine. For more information, consult 'x help'
A
    fi

}

# EndSection

# Section : utilties in static-build

# _x_xrc_static_run(){
#     local name=$1;  shift
#     xrc static-build
#     static_build_xrc "$name"
#     "_${name}_bin" "$@"
# }

___x_cmd_static_build_file(){
    local app="${1:?Provide app name}"
    local repo="${2:?Provide repo name}"
    shift 2
    eval " ___x_cmd_$app(){
        xrc static-build && static_build_init $app $repo ___x_cmd_$app && ___x_cmd_$app  \"\$@\"
    }"
    ___x_cmd_"$app" "$@"
}

___x_cmd_static_build_help(){
    if [ "$#" -eq 2 ]; then
        ___x_cmd_static_build_file "$@" "--help"
    else
        ___x_cmd_static_build_file "$@"
    fi
}
# EndSection

. "$___X_CMD_ROOT/x-cmd/lib/glob"
. "$___X_CMD_ROOT/x-cmd/lib/con"
. "$___X_CMD_ROOT/x-cmd/lib/alias"
. "$___X_CMD_ROOT/x-cmd/lib/args"

# Section : varset

___x_cmd_varset(){
    local _______variable_name="${1}"
    if [ "$#" -eq 1 ]; then
        eval printf "%s" "\"\$$_______variable_name\""
        return
    fi

    local result
    shift 1

    local ___X_CMD_EVAL_CON_SEPERATOR
    ___X_CMD_EVAL_CON_SEPERATOR="$(printf "\001")"

    result="$("$@"; printf "${___X_CMD_EVAL_CON_SEPERATOR}")"
    result="${result%${___X_CMD_EVAL_CON_SEPERATOR}}"
    eval "$_______variable_name=\"\$result\""
}

___x_cmd_varset_without_end(){
    local _______variable_name="${1}"
    if [ "$#" -eq 1 ]; then
        eval printf "%s" "\"\$$_______variable_name\""
        return
    fi

    local result
    shift 1
    result="$("$@")"
    eval "$_______variable_name=\"\$result\""
}

# EndSection

# Section : x main function

___x_cmd_shell_exec(){
    local shell="${1:?Provide shell}"
    shift
    if [ -x "/bin/$shell" ]; then
        # "/bin/$shell" $X_CMD_SRC_PATH/boot && ___x_cmd_source "$@"
        "/bin/$shell" "$@"
    elif [ -x "/usr/bin/$shell" ]; then
        # "/usr/bin/$shell" $X_CMD_SRC_PATH/boot && ___x_cmd_source "$@"
        "/usr/bin/$shell" "$@"
    else
        command "$shell" "$@"
    fi
}

___x_cmd_ls(){
    case "$1" in
        @*|*@*/*)
            ___x_cmd_file_ls "$@"
            return
            ;;
    esac
    ___x_cmd_static_build_file exa exa   "$@"
}

___x_cmd_workspace_root(){
    local cur="${1:-.}"

    cur="$(cd "$cur" 1>/dev/null 2>&1 && pwd)"

    while [ ! "$cur" = "" ]; do
        if [ -d "$cur/.x-cmd" ]; then
            printf "%s" "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}

___x_cmd_main_otherwise(){
    local subcmd="$1";  shift

    ___x_cmd_alias_exec ___x_cmd "$subcmd" "$@"
    local code=$?
    if [ -n "$___X_CMD_ALIAS_EXEC_EXIST" ]; then
        return $?
    fi

    # static build
    # update the static-build files
    local ___X_CMD_WHICH_ONE_RESULT
    local ___X_CMD_WHICH_ONE_RESOURCE_TYPE
    if ___x_cmd_which_one "$subcmd"; then
        local p="$___X_CMD_WHICH_ONE_RESULT"
        case "$___X_CMD_WHICH_ONE_RESOURCE_TYPE" in
            workspace)      ___x_cmd_exe_workspace  "$p" "$@" ;;
            local)          ___x_cmd_run_by_file    "$p" "$@" ;;
            hub)            ___x_cmd_run_by_file    "$p" "$@" ;;
            official)       ___x_cmd_run_by_file    "$p" "$@" ;;
        esac
        ___xrc_log debug "$p"
        return 0
    else
        printf "%s" "Error" >&2
        return 1
    fi
}

___x_cmd_ws(){
    local X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION=1

    local TGT

    if [ -z "$1" ]; then
        if TGT="$(___x_cmd_search_path . ".x-cmd/ws")"; then
            ___x_cmd_exe_workspace "$TGT/.x-cmd/ws"
            return
        else
            printf "%s\n" "Cannot find .x-cmd/ws" >&2
            return 1
        fi
    fi

    local RESOURCE_NAME="$1"; shift
    if TGT="$(___x_cmd_search_path . ".x-cmd/ws")"; then
        ___x_cmd_exe_workspace "$TGT/.x-cmd/ws" "$RESOURCE_NAME" "$@"
        return
    elif TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
        ___x_cmd_exe_workspace "$TGT/.x-cmd/$RESOURCE_NAME" "$@"
        return
    else
        printf "Workspace Resource Not found: %s\n" "$RESOURCE_NAME" >&2
        return 1
    fi
}


___x_cmd_ws_(){
    local X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION=1

    local RESOURCE_NAME="$1"; shift

    local TGT
    if TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
        ___x_cmd_exe_workspace "$TGT/.x-cmd/$RESOURCE_NAME" "$@"
        return
    else
        printf "Workspace Resource Not found: %s\n" "$RESOURCE_NAME" >&2
        return 1
    fi
}

___x_cmd_alias_init ___x_cmd

___x_cmd_which_panic(){
    local ___X_CMD_WHICH_ONE_RESULT
    if ! ___x_cmd_which_one "$p"; then
        printf "%s\n" "Fail to find path for $p" >&2
        return 1
    else
        printf "%s\n" "$___X_CMD_WHICH_ONE_RESULT"
    fi
}

. "$___X_CMD_ROOT/x-cmd/lib/qr"

___x_cmd_main(){
    local IFS=" "

    local subcmd=$1; [ $# -gt 0 ] && shift
    case "$subcmd" in
        log)                                    ___x_cmd_log "$@" ;;
        ""|help)                                printf "x     x-bash core function.
    Uasge:  x <subcommand> [<subcommand>...]
    Please visit our homepage for more information: https://x-cmd.com
" >&2;
                                                ___x_cmd_x_cmd_help
                                                return 0
;;
        \.)                                     command code . ;;

        alias)                                  ___x_cmd_alias      ___x_cmd "$@"   ;;
        unalias)                                ___x_cmd_unalias    ___x_cmd "$@"   ;;

        conjoin)                                ___x_cmd_eval_concurrent_join "$@" ;;
        con)                                    ___x_cmd_eval_concurrent_assign "$@" ;;

        *:=)                                    ___x_cmd_varset "${subcmd%:=}" "$@" ;;
        *=)                                     ___x_cmd_varset_without_end "${subcmd%=}" "$@" ;;

        args)                                   ___x_cmd_args "$@"      ;;
        arg1)                                   ___x_cmd_args 1 "$@"    ;;
        margs)                                  ___x_cmd_margs "$@"     ;;
        marg1)                                  ___x_cmd_margs 1 "$@"   ;;

        login)                                  xrc hub/latest && ___x_cmd_hub login "$@" ;;

        update)                                 xrc update "$@"  ;;
        upgrade)                                xrc upgrade "$@" ;;
        clear)                                  if ! grep "___x_cmd_http_get()" "$___X_CMD_ROOT/xrc/latest" >/dev/null 2>&1; then
                                                    ___xrc_log debug "'$___X_CMD_ROOT/xrc/latest' NOT found. Please manually clear cache folder: $___X_CMD_ROOT"
                                                    return 1
                                                fi
                                                rm -rf "$___X_CMD_ROOT" ;;
        reinstall)                              x clear && RELOAD=1 x upgrade ;;

        z|uz)                                   ( xrc zuz && ___x_cmd_zuz "$subcmd" "$@" ) ;;
        zl)                                     ( xrc zuz && ___x_cmd_zuz_ls "$@"        ) ;;

        sh|bash|zsh|fish|ksh|dash|ash)          ___x_cmd_shell_exec "$subcmd" "$@" ;;

        jar)                                    xrc java/latest && ___x_cmd_java -jar "$@" ;;
        java)                                   xrc java/latest && ___x_cmd_java "$@" ;;

        pip|pip3)                               xrc python/latest && ___x_cmd_pip3 "$@" ;;
        python|py)                              xrc python/latest && ___x_cmd_python "$@" ;;

        nvm)                                    xrc nvm/latest  && ___x_cmd_nvm "$@" ;;
        javascript|js|node)                     xrc node/latest && ___x_cmd_node "$@" ;;
        npm)                                    xrc node/latest && ___x_cmd_npm "$@" ;;
        npx)                                    xrc node/latest && ___x_cmd_npx "$@" ;;
        ts)                                     local arg
                                                local argstr
                                                while [ $# -ge 0 ]; do
                                                    case "$arg" in
                                                        -*)     argstr="$argstr $arg"   ;;
                                                        *)      break
                                                    esac
                                                done
                                                local script
                                                script="$1"
                                                shift
                                                x npx @typeshell/exec "$argstr" "$script" "$@"
                                                ;;
        # ruby|rb)                                ruby "$(___x_cmd_official_which "$2")" "$@"      ;;
        lua)            ;;

        7zd)                                    ( xrc p7zip/v0   &&  p7zd "$@" ) ;;
        7z|7za|7zr)                             ___x_cmd_static_build_file      p7zip 7za               "$@"    ;;

        ls)                                     ___x_cmd_ls         "$@"        ;;
        ll)                                     ___x_cmd_static_build_file      exa exa  -l             "$@"    ;;
        ps)                                     ___x_cmd_static_build_file      procs procs             "$@"    ;;
        du)                                     ___x_cmd_static_build_file      dust dust               "$@"    ;;
        sqlite)                                 ___x_cmd_static_build_file      sqlite3 sqlite3         "$@"    ;;
        cat)                                    ___x_cmd_static_build_help      bat bat                 "$@"    ;;
        bw)                                     ___x_cmd_static_build_file      bandwhich bandwhich     "$@"    ;;
        jq)                                     ___x_cmd_static_build_help      jq jq                   "$@"    ;;
        # TODO: we will rename ___x_cmd_curl to make room for it
        curl|yq|tmux|git|nmap|tesseract|magick)        ___x_cmd_static_build_file     "$subcmd" "$subcmd"      "$@"    ;;
        ffmpeg)                                 xrc ffmpeg && ___x_cmd_ffmpeg_download       "$@"    ;;
        pandoc)                                 xrc pandoc && ___x_cmd_pandoc                "$@"    ;;

        openssl|ssl)                            ___x_cmd_static_build_file      openssl openssl         "$@"    ;;
        ncat)                                   ___x_cmd_static_build_file      nmap ncat               "$@"    ;;
        nping)                                  ___x_cmd_static_build_file      nmap nping              "$@"    ;;
        traceroute)                             ___x_cmd_static_build_file      nmap traceroute         "$@"    ;;
        run)                                    ___x_cmd_run_by_file "$@"       ;;
        search_path)                            ___x_cmd_search_path "$@"       ;;
        which|w)                                local p
                                                for p in "$@"; do
                                                    ___x_cmd_which_panic || return 1
                                                done
                                                ;;
        qr)                                     ___x_cmd_qr "$@" ;;
        _x_cmd_advise_json)                     ___x_cmd_x_cmd_advise_json "$@" ;;
        wsroot)                                 ___x_cmd_workspace_root "$@" ;;
        ws)                                     ___x_cmd_ws "$@" ;;
        _ws)                                    ___x_cmd_ws_ "$@" ;;
        *)                                      ___x_cmd_main_otherwise "$subcmd" "$@" ;;

    esac
}

# EndSection

# Section : help and advise.json
___x_cmd_x_cmd_advise_json(){
    xrc cat x-cmd/lib/x.json
    return 126
}

___x_cmd_x_cmd_help(){
    xrc advise/lib/advise_get
    ___x_cmd_advise_get_help "$(xrc which x-cmd/lib/x.json)"
}
# EndSection

x(){
    ___x_cmd_main "$@"
}

if ___x_cmd_is_suitable_advise_env; then
    # if you use xrc that you must have advise
    # xrc advise/latest
    advise x
fi

# TODO: We should have a better solution for this.
X_DISABLE_WORKSPACE_EXECUTION_CONFIRMATION=1
