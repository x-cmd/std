# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263

# author:       Li Junhao           l@x-cmd.com
# license:      GPLv3


# Section 1: utils: search_path
___x_cmd_search_path(){
    local cur="${1:?Provide starting path}"
    cur="$(cd "$cur" 1>/dev/null 2>&1 && pwd)"

    local relative_filepath="${2:?Provide relative filepath}"
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/$relative_filepath" ]; then
            printf "%s" "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}

___x_cmd_is_interative_tty(){
    [ "${-#*i}" != "$-" ]
}

___x_cmd_is_suitable_advise_env(){
    [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]
}

___x_cmd_readlink_recursive(){
    if [ -L "${1:?Provide link}" ]; then
        local next_link
        next_link="$(readlink "${1}")" || return
        if [ "${next_link#/}" = "$next_link" ]; then
            next_link="$(dirname "${1}")/$next_link"
        fi
        ___x_cmd_readlink_recursive "$next_link"
    else
        [ ! -e "${1}" ] && return 1        # File Not Exists
        printf "%s" "$1"
    fi
}

___x_cmd_definelazyloader(){
    local funcname="${1:?Provide function name}"
    local respath="${2:?Provide resource path}"
    eval "$funcname(){
        if [ \"\$___X_CMD_DEFINELAZYLOADER\" = \"$funcname\" ]; then
            printf \"No such function [%s] in [%s]\" \"$funcname\" \"$respath\"
            return 1
        fi

        if ! xrc $respath; then
            printf \"Fail to xrc: %s\" \"$respath\"
            return 1
        fi

        local ___X_CMD_DEFINELAZYLOADER=$funcname
        $funcname \"\$@\"
    }"
}

# VAR   SEP    IT
___x_cmd_trimutil(){
    eval "
[ -z \"\$${O}\" ] && return 1
IT=\"\${${O}%%${SEP:-
}*}\"
if [ \"\${IT}\" = \"\${$O}\" ]; then
    $O=\"\"
else
    $O=\"\${${O}#*${SEP:-
}}\"
fi
return 0
"
}

# f(){
#     local IT
#     local SEP=,
#     local a
#     a="abc,cde,eft"
#     while O=a ___x_cmd_trimutil; do
#         printf "%s\n" "$IT"
#     done
# }

# f

___x_cmd_pidofsubshell(){
    sh -c 'printf "%s\n" "$PPID"'
}

# EndSection

# Section 2: get ___X_CMD_SHELL, ___xrc_log, ___x_cmd_source, ___x_cmd_shift1
if [ -n "$BASH_VERSION" ]; then
    ___X_CMD_SHELL=bash
    shopt -s expand_aliases
elif [ -n "$ZSH_VERSION" ]; then
    ___X_CMD_SHELL=zsh
    # The same as 'shopt -s expand_aliases' in bash, refer: https://stackoverflow.com/questions/23258413/expand-aliases-in-non-interactive-shells
    setopt aliases
elif [ -n "$KSH_VERSION" ]; then
    ___X_CMD_SHELL=ksh
    alias local=typeset
else
    # TODO: Otherwise, loading a remarkable script to detect shell
    ___X_CMD_SHELL="$(
        res="$(___x_cmd_readlink_recursive "$(command -v "$0")")"
        if [ "${res%dash}" != "$res" ]; then
            printf "%s" dash
        elif /bin/sh --help 2>&1 | grep BusyBox >/dev/null; then
            printf "%s" ash
        else
            printf "WARNING: %s\n" "Unknown shell." >&2
        fi
    )"
fi
___X_CMD_CUR_SHELL="${___X_CMD_SHELL:-sh}"      # TODO: will remove

# To prevent dash inline environment problem: just for dash
if [ "$___X_CMD_SHELL" = dash ]; then
    alias ___x_cmd_shift1='[ $# -gt 0 ] && shift ; '
else
    alias ___x_cmd_shift1="shift ; "
fi

___x_cmd_source(){
    . "$@"
}

___x_cmd_source_inner(){
    while [ $# -gt 0 ]; do
        . "$___X_CMD_ROOT_MOD/$1"
        shift
    done
}

# deprecated
alias xrc:inner=___x_cmd_source_inner

alias xrc:mod=___x_cmd_source_inner

___x_cmd_source_inner_lib(){
    local mod="${1:?Provide module name}"; shift
    while [ $# -gt 0 ]; do
        . "$___X_CMD_ROOT_MOD/$mod/lib/$1"
        shift
    done
}

# deprecated
alias xrc:inner:lib=___x_cmd_source_inner_lib

alias xrc:mod:lib=___x_cmd_source_inner_lib

# TODO: xrc_log +xrc
___xrc_log(){
    local level="$1"; shift
    [ "$level" = debug ] && [ -z "$___X_CMD_XRC_LOG_DEBUG_MODE" ] && return
    printf "[%s]: %s\n" "$level" "$@" 1>&2
}

[ -z "$TMPDIR" ] && TMPDIR="$(dirname "$(mktemp -u)")/"     # It is posix standard. BUT NOT set in some cases.

if [ -z "$___X_CMD_ROOT" ]; then
    ___X_CMD_ROOT="$HOME/.x-cmd"           # boot will be placed in "$HOME/.x-cmd/boot"
    ___X_CMD_ROOT_MOD="$___X_CMD_ROOT"
    ___X_CMD_ROOT_TMP="$___X_CMD_ROOT/.tmp"

    ___xrc_log debug "Setting env ___X_CMD_ROOT: $___X_CMD_ROOT"
    [ -d "$___X_CMD_ROOT" ] || mkdir -p "$___X_CMD_ROOT" || return 1 || exit 1
    PATH="$___X_CMD_ROOT/x-cmd/lib/bin:$PATH"
    export ___X_CMD_ROOT
    export PATH
fi

xrc:mod log/latest

case "$___X_CMD_SHELL" in
    bash|zsh)
___x_cmd_q1(){
    printf "'%s'" "${1//\'/\\\'}"
}

___x_cmd_q2(){
    printf "\"%s\"" "${1//\"/\\\"}"
}
    ;;
    *)
___x_cmd_q1(){
    awk '
BEGIN{ RS="\001"; S="'\''"; }
{
    gsub(S, "\\" S, $0)
    printf(S "%s" S, $0)
}' <<A
$1
A
}

___x_cmd_q2(){
    awk '
BEGIN{ RS="\001"; S="\""; }
{
    gsub(S, "\\" S, $0)
    printf(S "%s" S, $0)
}' <<A
$1
A
}
    ;;
esac

# EndSection

# Section 3: httpget: using curl, wget, and x-curl

___x_cmd_httpget_handle_resp_header(){
    local url="${1:?Provide url}"
    local code="${2:?Provide exit code of function ___x_cmd_httpget_inner}"

    local http_code
    http_code="$(awk 'NR==1{ printf("%s", $2); }')"
    case "$http_code" in
        20*)    return 0 ;;
        40*)    ___xrc_log debug "HTTP_CODE: $http_code. Fail to retrieve file from: $url"
                return 4 ;;     # TODO: consider using exit code 70
        "")     ___xrc_log debug "Return code: $code. HTTP_CODE Unavialable. Fail to retrieve file from: $url"
                return 1 ;;
        5*)     ___xrc_log debug "Return code: $code. Server internal error. Fail to retrieve file from: $url"
                return 5 ;;     # TODO: consider using exit code 69
        *)      ___xrc_log debug "Unknow error. HTTP_CODE: $http_code. Fail to retrieve file from: $url"
                return 2 ;;
    esac
}

# TODO: rename to ___x_cmd_httpget_with_cache
___x_cmd_httpget() {
    local url="${1:?Provide url}"
    local cache="$2"
    local cache_expiration="$3"

    local redirect_path=            # "&1"
    if [ -n "$cache" ]; then
        if [ -f "$cache" ]; then
            # days
            case "$cache_expiration" in
                "") # infinite time
                    ___xrc_log debug "Function ___x_cmd_httpget() terminated. Because local cache existed with update flag unset: $cache"
                    return 0
                    ;;
                -)  # force update
                    ;;
                *)  # days
                    if [ -n "$(find "$cache" -mtime "-$cache_expiration" 2>/dev/null)" ]; then
                        ___xrc_log debug "Function ___x_cmd_httpget() terminated. Because local cache existed within days: $cache_expiration"
                        return 0
                    fi
            esac
        fi

        # First make sure it works before webservice. Fail fast.
        mkdir -p "$(dirname "$cache")"
        redirect_path="$TMPDIR/x-bash-temp-download.$RANDOM"
        # TODO: Consider using following code
        # redirect_path="$(dirname "$cache")/x-bash-temp-download.$RANDOM"
    fi

    ___xrc_log debug "URL is $url"
    if ___x_cmd_httpget_inner "$url" "$redirect_path"; then
        if [ -n "$cache" ]; then
            ___xrc_log debug "Copy the temp file to CACHE file: $cache"
            mv "$redirect_path" "$cache"
        fi
    else
        code=$?
        [ -n "$cache" ] && rm -f "$redirect_path"    # In centos, file in "$redirect_path" is write protected.
        return $code
    fi
}

# org reponame branch suburl
# rename to ___x_cmd_httpget_gitx_with_cache
___x_cmd_httpget_gitx(){   # Simple strategy
    local owner="${1:?Provide owner}"
    local reponame="${2:?Provide reponame}"
    local branch="${3:?Provide branch}"
    local suburl="${4:?Provide location like str}"
    local cache="${5}"
    local cache_expiration="${6}"

    local IFS

    local mirror_list
    mirror_list="$(___x_cmd_mirror)"

    local mirror
    local lineno=1
    local urlpath
    while read -r mirror; do
        # shellcheck disable=SC2059
        urlpath="$(printf "$mirror" "$owner" "$reponame" "${branch}" "$suburl")"
        ___x_cmd_httpget "$urlpath" "$cache" "$cache_expiration"

        case $? in
            0)  if [ "$lineno" -ne 1 ]; then
                    ___xrc_log debug "Current default mirror is $mirror"
                    ___x_cmd_mirror "$mirror" "$(printf "%s" "$mirror_list" | awk "NR!=$lineno{ print \$0 }" )"

                    # Set CHINA_NET FLAG
                    case "$mirror" in
                        *gitee*|*codechina*)                    ___X_CMD_IN_CHINA_NET=1; ___X_CMD_WHICHNET=cn ;;
                        *github*|*gitlab*)                      ___X_CMD_IN_CHINA_NET= ; ___X_CMD_WHICHNET=default ;;
                    esac
                fi
                return 0;;
            1)  ___xrc_log debug "Network unavailable."
                return 1;;
            4)  ___xrc_log debug "Resource Not Found."
                return 4;;
            *)
                ___xrc_log debug "Network unavailable Or Mirror is down: $urlpath"
                return 1;;
        esac
        lineno=$((lineno+1))
    done <<A
${mirror_list}
A
    return 1
}

# rename to ___x_cmd_httpget_gitx_official
___x_cmd_httpget_gitx_official(){
    ___x_cmd_httpget_gitx x-cmd "$___X_CMD_CODESORUCE_REPO" "${___X_CMD_CODESORUCE_REPO_BRANCH}" "${1:?Provide resource path}" "$2" "$3"
}


# TODO: will remove the following functions
___x_cmd_curl(){
    ___x_cmd_httpget "$@"
}

___x_cmd_curl_gitx(){
    ___x_cmd_httpget_gitx "$@"
}

___x_cmd_curl_gitx_official(){
    ___x_cmd_httpget_gitx_official "$@"
}

___x_cmd_llist(){
    xrc xrc/lib/llist && ___x_cmd_llist "$@" ;
}

___x_cmd_awk(){
    xrc awk/latest && ___x_cmd_awk "$@"
}

# EndSection

# Section 4: mirror

___X_CMD_CODESORUCE_REPO_BRANCH=${___X_CMD_CODESORUCE_REPO_BRANCH:-main}
___X_CMD_CODESORUCE_REPO=${___X_CMD_CODESORUCE_REPO:-x-cmd}

___x_cmd_mirror(){
    local fp="$___X_CMD_ROOT/.source.mirror.list"
    if [ $# -ne 0 ]; then
        local IFS="
";
        printf "%s" "$*" >"$fp"
        return
    fi

    # TODO: what if the mirror file is wrong or empty? ... We should have a solution for that.
    if [ -f "$fp" ]; then
        cat "$fp"
        return
    fi

    tee "$fp" <<A
https://raw.githubusercontent.com/%s/%s/%s/%s
https://gitee.com/%s/%s/raw/%s/%s
A

}

if [ "$___X_CMD_IN_CHINA_NET" = 1 ] || [ "$___X_CMD_WHICHNET" = cn ]; then
    ___x_cmd_mirror \
            "https://gitee.com/%s/%s/raw/%s/%s" \
            "https://raw.githubusercontent.com/%s/%s/%s/%s"
fi

case "$(___x_cmd_mirror | head -n1)" in
    *gitee*|*codechina*)        ___X_CMD_IN_CHINA_NET=1 ;   ___X_CMD_WHICHNET=cn ;;
    *github*|*gitlab*)          ___X_CMD_IN_CHINA_NET= ;    ___X_CMD_WHICHNET=default ;;
    *)                          printf "%s\n" "Unknown mirror: $(___x_cmd_mirror | head -n1)" >&2
                                ___X_CMD_IN_CHINA_NET= ;    ___X_CMD_WHICHNET=unknown ;;
esac
# EndSection

# Section 5: ldict
___x_cmd_ldict(){
    local op="$1"; shift
    case "$op" in
        put)        ___x_cmd_ldict_put "$@" ;;
        unshift)    ___x_cmd_ldict_unshift "$@" ;;
        get)        ___x_cmd_ldict_get "$@" ;;
        keys)       ___x_cmd_ldict_keys "$@" ;;
        print)      ___x_cmd_ldict_print "$@" ;;
        *)
            printf "Show help for ldict\n" >&2
            return 1
    esac
}

alias ldict="___x_cmd_ldict"

___X_CMD_LDICT_SEP="$(printf "\001")"
___X_CMD_LDICT_KVSEP="$(printf "\002")"

___x_cmd_ldict_unshift(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"
    local value="${3:?Provide value}"

    ___x_cmd_ldict_rm "$name" "$key"

    eval "___X_CMD_LDICT_${name}=\"\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}\${value}\${___X_CMD_LDICT_${name}:-\${___X_CMD_LDICT_SEP}}\""
}

___x_cmd_ldict_put(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"
    local value="${3:?Provide value}"

    ___x_cmd_ldict_rm "$name" "$key"

    eval "___X_CMD_LDICT_${name}=\"\${___X_CMD_LDICT_${name}:-\${___X_CMD_LDICT_SEP}}\${key}\${___X_CMD_LDICT_KVSEP}\${value}\${___X_CMD_LDICT_SEP}\""
}

___x_cmd_ldict_rm(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"

    local tmp
    eval "tmp=\"\${___X_CMD_LDICT_${name}#*\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}*\${___X_CMD_LDICT_SEP}}\""
    if eval [ \"\$tmp\" != \"\$"___X_CMD_LDICT_${name}"\" ]; then
        eval "___X_CMD_LDICT_${name}=\"\${___X_CMD_LDICT_${name}%%\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}*}\${___X_CMD_LDICT_SEP}\${tmp}\""
        return 0
    fi
    return 1
}

___x_cmd_ldict_has(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"

    local tmp
    eval "tmp=\"\${___X_CMD_LDICT_${name}#*\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}*\${___X_CMD_LDICT_SEP}}\""
    eval [ \"\$tmp\" != \"\$"___X_CMD_LDICT_${name}"\" ]
}

___x_cmd_ldict_get(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"

    local tmp

    eval "tmp=\"\${___X_CMD_LDICT_${name}#*\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}}\""

    if eval [ \"\$tmp\" != \"\$"___X_CMD_LDICT_${name}"\" ]; then
        printf "%s" "${tmp%%${___X_CMD_LDICT_SEP}*}"
    else
        return 1
    fi
}

___x_cmd_ldict_keys(){
    local name="${1:?Provide dict name}"
    eval printf \"%s\" \"\$"___X_CMD_LDICT_${name}"\" | awk -v RS="$___X_CMD_LDICT_SEP" -v FS="${___X_CMD_LDICT_KVSEP}" '
NR!=1{
    print $1
}'
}

___x_cmd_ldict_print(){
    local name="${1:?Provide dict name}"
    eval printf \"%s\" \"\$"___X_CMD_LDICT_${name}"\" | awk -v RS="$___X_CMD_LDICT_SEP" -v FS="${___X_CMD_LDICT_KVSEP}" '
NR!=1{
    print $1 " = " $2
}'
}

___x_cmd_ldict_dump(){
    local name="${1:?Provide dict name}"
    eval printf \"%s\" \"\$"___X_CMD_LDICT_${name}"\"
}

# EndSection

# Section 6: main entrance helper: xrc_set_main, which_one, which_one_with_naming
___x_cmd_xrc_set_main(){
    ___X_CMD_XRC_SET_MAIN="${1:?Provide function}"
}

# RETURN ___X_CMD_WHICH_ONE_NAMING
___x_cmd_which_one_with_naming(){
    local RESOURCE_NAME="${1:?Provide resource name for ___x_cmd_which_one_with_naming}"

    ___X_CMD_WHICH_ONE_NAMING=

    case "$RESOURCE_NAME" in
        *=/*)                   ;;
        *=http://*|*=https://*) ;;
        *=*@*/*)                ;;
        *=./*|*=../*)           ;;
        *=*)                    ;;
        *)
            # TODO: some future work for http
            case "$RESOURCE_NAME" in

                */*)    ;;  # Should no set alias function when is a path
                *)      ___X_CMD_WHICH_ONE_NAMING="${RESOURCE_NAME}" ;;     # Only when it is a module name...
            esac
            # ___X_CMD_WHICH_ONE_NAMING="${RESOURCE_NAME##*/}"
            ___x_cmd_which_one "${RESOURCE_NAME}"
            return
    esac

    ___X_CMD_WHICH_ONE_NAMING="${RESOURCE_NAME%%=*}"
    ___x_cmd_which_one "${RESOURCE_NAME#*=}"
}

# RETURN ___X_CMD_WHICH_ONE_RESULT, ___X_CMD_WHICH_ONE_RESOURCE_TYPE
___x_cmd_which_one(){
    local RESOURCE_NAME="${1:?Provide resource name for ___x_cmd_which_one}"

    ___X_CMD_WHICH_ONE_RESOURCE_TYPE=
    ___X_CMD_WHICH_ONE_RESULT=

    local TGT
    case "$RESOURCE_NAME" in
        /*)
            ___xrc_log debug "Resource recognized as local file: $RESOURCE_NAME"
            ___X_CMD_WHICH_ONE_RESOURCE_TYPE=local
            ___X_CMD_WHICH_ONE_RESULT="$RESOURCE_NAME"
            return 0
            ;;
        http://*|https://*)
            ___X_CMD_WHICH_ONE_RESOURCE_TYPE=http
            ___xrc_log debug "Resource recognized as http resource: $RESOURCE_NAME"

            TGT="$___X_CMD_ROOT/.http_resource/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" ___x_cmd_httpget "$RESOURCE_NAME"; then
                ___xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            else
                ___X_CMD_WHICH_ONE_RESULT="$TGT"
            fi
            ;;
        *@*/*)
            xrc hub/latest
            ___X_CMD_WHICH_ONE_RESULT="$(___x_cmd_hub_file_which "$RESOURCE_NAME")"     # Will set ___X_CMD_WHICH_ONE_RESOURCE_TYPE=1 if from unknow source
            ;;
        ./*|../*)
            ___xrc_log debug "Resource recognized as local file with relative path: $RESOURCE_NAME"
            local tmp
            if tmp="$(cd "$(dirname "$RESOURCE_NAME")" || exit 1; pwd)"; then
                ___X_CMD_WHICH_ONE_RESOURCE_TYPE=local
                ___X_CMD_WHICH_ONE_RESULT="$tmp/$(basename "$RESOURCE_NAME")"
                return 0
            else
                ___xrc_log warn "Local file not exists: $RESOURCE_NAME"
                return 1
            fi
            ;;
        *)
            if [ -z "$___X_CMD_NO_LOCAL" ]; then
                # This is ONLY for x-cmd
                if [ -f "$RESOURCE_NAME" ]; then
                    ___X_CMD_WHICH_ONE_RESULT="$RESOURCE_NAME"
                    ___X_CMD_WHICH_ONE_RESOURCE_TYPE=local
                    return      # local file
                fi

                if TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
                    ___X_CMD_WHICH_ONE_RESOURCE_TYPE=workspace
                    ___X_CMD_WHICH_ONE_RESULT="$TGT/.x-cmd/$RESOURCE_NAME"
                    return                   # .x-cmd
                fi
            fi

            ___X_CMD_WHICH_ONE_RESOURCE_TYPE=official
            # x-bash module
            ___xrc_log debug "Resource recognized as x-bash module: $RESOURCE_NAME"
            local module="$RESOURCE_NAME"
            if [ "${RESOURCE_NAME#*/}" = "$RESOURCE_NAME" ] ; then
                module="$module/latest"         # If it is short alias like str (short for str/latest)
                ___xrc_log debug "Version suffix unavailable. Using \"latest\" by default: $module"
            fi

            TGT="$___X_CMD_ROOT/$module"
            if [ -f "$TGT" ]; then
                ___X_CMD_WHICH_ONE_RESULT="$TGT"
                return 0
            fi
            # ___xrc_log debug "Module not found: $module"
            # return 1

            ___xrc_log info "Downloading resource=$RESOURCE_NAME to local cache: $TGT"
            if ___x_cmd_httpget_gitx_official "mod/$module" "$TGT"; then
                ___X_CMD_WHICH_ONE_RESULT="$TGT"
                return 0
            fi

            ___xrc_log warn "ERROR: Fail to load module due to network error or other: $RESOURCE_NAME"
            return 1
    esac
}
# EndSection

# Section 7: main entrance helper: cat, source_file
___x_cmd_xrc_cat(){
    while [ $# -ne 0 ]; do
        local ___X_CMD_LOCAL_XRCPATH="$1";   shift

        if ! ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$___X_CMD_LOCAL_XRCPATH"; then
            printf "ERROR: Interrupted because resource not found. %s \n" "$___X_CMD_LOCAL_XRCPATH" >&2
            return 1
        fi

        cat "$___X_CMD_WHICH_ONE_RESULT"
    done
}

___X_CMD_XRC_MODULE_IMPORTED="
"

___x_cmd_xrc_source_file(){
    local ___X_CMD_WHICH_ONE_NAMING
    local ___X_CMD_WHICH_ONE_RESULT
    local ___X_CMD_LOCAL_XRCPATH

    while [ $# -ne 0 ]; do
        ___X_CMD_LOCAL_XRCPATH="$1";   shift

        if ! ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one_with_naming "$___X_CMD_LOCAL_XRCPATH"; then
            printf "ERROR: Interrupted because resource not found. %s \n" "$___X_CMD_LOCAL_XRCPATH" >&2
            printf "%s\n" "return 1"
            return 1
        fi

        # Ask whether using http or outside resource.
        if [ "$___X_CMD_WHICH_ONE_RESOURCE_TYPE" = http ] && [ -z "$NOWARN" ]; then

            # We should do it before ___x_cmd_which_one
            printf "Sourcing script from untrusted location: %s\n" "$___X_CMD_LOCAL_XRCPATH"
            cat >&2 <<A
SECURITY WARNING! Sourcing script from untrusted location: $___X_CMD_WHICH_ONE_RESULT
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
> NOWARN=1 xrc "$___X_CMD_LOCAL_XRCPATH"
A
            printf "Input yes to continue. Otherwise exit > " >&2
            local ___X_CMD_LOCAL_INPUT
            read -r ___X_CMD_LOCAL_INPUT

            if [ "$___X_CMD_LOCAL_INPUT" != "yes" ]; then
                rm "$___X_CMD_WHICH_ONE_RESULT"
                printf "%s\n" "Exit because of a non yes output received: $___X_CMD_LOCAL_INPUT" >&2
                printf "%s\n" "return 1"
                return 1
            fi
        fi

        ___x_cmd_xrc_source_file_main "$___X_CMD_WHICH_ONE_RESULT"
    done
}

___x_cmd_xrc_source_file_main_define_by_setmain(){
    if [ -n "$___X_CMD_WHICH_ONE_NAMING" ] && [ -n "$___X_CMD_XRC_SET_MAIN" ] && [ "$___X_CMD_WHICH_ONE_NAMING" != "$___X_CMD_XRC_SET_MAIN" ]; then
        eval "
        $___X_CMD_WHICH_ONE_NAMING(){
            \"$___X_CMD_XRC_SET_MAIN\" \"\$@\"
        }"

        if ___x_cmd_is_suitable_advise_env && [ -n "$___X_CMD_XRC_SET_MAIN" ] && [ -n "$___X_CMD_WHICH_ONE_NAMING" ] ; then
            advise init "$___X_CMD_XRC_SET_MAIN" "" "$___X_CMD_WHICH_ONE_NAMING"
        fi
    fi
}

___x_cmd_xrc_source_file_main(){
    ___X_CMD_WHICH_ONE_RESULT="${1:?Provide exact file}"

    if [ -z "$___X_CMD_XRC_RELOAD" ]; then
        if [ "${___X_CMD_XRC_MODULE_IMPORTED#*
"$___X_CMD_WHICH_ONE_RESULT"
*}" != "${___X_CMD_XRC_MODULE_IMPORTED}" ]; then
            local ___X_CMD_XRC_SET_MAIN
            ___X_CMD_XRC_SET_MAIN="$(___x_cmd_ldict_get ___X_CMD_XRC_SET_MAIN_DICT "${___X_CMD_WHICH_ONE_RESULT}")"

            ___x_cmd_xrc_source_file_main_define_by_setmain
            return    # exited already. skip
        fi
    fi

    ___X_CMD_XRC_MODULE_IMPORTED="
${___X_CMD_WHICH_ONE_RESULT}${___X_CMD_XRC_MODULE_IMPORTED}"

    local ___X_CMD_XRC_SET_MAIN
    ___x_cmd_source "$___X_CMD_WHICH_ONE_RESULT"

    if [ -n "$___X_CMD_XRC_SET_MAIN" ]; then
        ___x_cmd_ldict_put ___X_CMD_XRC_SET_MAIN_DICT "${___X_CMD_WHICH_ONE_RESULT}" "${___X_CMD_XRC_SET_MAIN}"
        ___x_cmd_xrc_source_file_main_define_by_setmain
    fi
}


# EndSection

# Section 8: main entrance

# shellcheck disable=SC1091
xrc(){
    [ $# -eq 0 ] && set -- "help"
    local subcmd="$1";  shift
    case "$subcmd" in
        ""|help)
            printf "xrc     x-bash core function.
    Uasge:  xrc <lib> [<lib>...]
    Please visit our homepage for more information: https://x-cmd.com
SUBCOMMAND:
    cat|c           Show the script in text form.
    which|w         Download lib files and print the local path.
    update|u        Update file.
    cache           Provide cache filepath.
    clear           Clear the cache.
    ls              Show the cache modules.
" >&2
            ;;
        c|cat)
            if [ $# -gt 0 ]; then
                ___x_cmd_xrc_cat "$@"
                return
            fi
            cat >&2 <<A
xrc cat         Show the script in text form
    Uasge:  xrc  cat <lib> [<lib>...]
    Example: eval "$(xrc cat str)"
A
            return 1
            ;;
        w|which)
            if [ $# -gt 0 ]; then
                ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$@"
                printf "%s" "$___X_CMD_WHICH_ONE_RESULT"
                return
            fi
            cat >&2 <<A
xrc which       Download lib files and print the local path.
    Uasge:  xrc which <lib> [<lib>...]
    Example: source "$(xrc which str)"
A
            return 1
            ;;
        root)
            printf "%s" "$___X_CMD_ROOT"
            ;;
        mirror)
            ___x_cmd_mirror "$@"
            ;;
        export-all)
            ( xrc x-bash/xrc/lib/export &&  ___x_cmd_xrc_export_all "$@" )
            ;;
        update)
            local CACHE="$___X_CMD_ROOT/all.tgz"
            # rm -rf "$___X_CMD_ROOT" # Dangerous.
            local codesrc="${1:-$___X_CMD_CODESORUCE_REPO}"
            case "$codesrc" in
                x-cmd|dev|nightly)    ;;
                *)      printf "%s\n" "Exit because of unknown code src: $codesrc" >&2 ;;
            esac

            if ___x_cmd_httpget_gitx x-cmd "$codesrc" main "dist/all.tgz" "$CACHE" -; then
                (cd "$___X_CMD_ROOT" && tar xvf "$CACHE")
                rm "$CACHE"
                rm "$___X_CMD_ROOT/.boot/boot" && x boot setup
                ___X_CMD_XRC_MODULE_IMPORTED=
                ___x_cmd_source "$___X_CMD_ROOT"/xrc/latest
            fi
            ;;
        upgrade)
            ___X_CMD_XRC_MODULE_IMPORTED=
            rm -f "$___X_CMD_ROOT/.boot/boot" && eval "$(curl https://get.x-cmd.com)"
            ;;
        log)
            printf "WARN: xrc log deprecated, you should using 'x log' instead\n" >&2
            x log "$@"
            ;;
        ls)
            ls "$___X_CMD_ROOT"
            ;;  # If tar.gz, using tar ls. If folder, ls $folder
        setmain)
            ___x_cmd_xrc_set_main "$@"
            ;;
        reload)
            local ___X_CMD_XRC_RELOAD=1
            if [ "$#" -gt 0 ]; then
                ___x_cmd_xrc_source_file "$@"
            else
                ___x_cmd_xrc_source_file xrc/latest
            fi
            ;;
        _x_cmd_advise_json)
            xrc cat xrc/lib/xrc.json
            return 126
            ;;
        *)
            ___x_cmd_xrc_source_file "$subcmd" "$@"
            return
    esac
}
# EndSection

# Section 9: other initialization: advise, lazy loading: x, ldict, awk
x(){    unset -f x; xrc reload x-cmd/latest && x "$@";    }

if ___x_cmd_is_suitable_advise_env; then
    ___xrc_log debug "Using module advise for completion."
    xrc advise/latest && advise init xrc && advise init x
fi

alias xws="x ws"
alias xdev="x dev"

if [ -n "$ZSH_VERSION" ]; then
    alias -- +=xrc
else
    alias "+=xrc"
fi
# EndSection

# Section: Instance management. will be extracted to a file

# TODO: We could use list to replace this facility.
# ___x_cmd_instance_add class object
___x_cmd_instance_new(){
    local name="${2:?Provide object name}"
    name="${name#?}"
    eval "
function $name {
    $1 $2 \"\$@\"
}
"
}

___x_cmd_instance_del(){
    local name="${2:?Provide object name}"
    # TODO:
    if [ $# -gt 2 ];then
        eval "$@"
    fi
    name="${name#?}"
    if command -v "$name" 1>/dev/null 2>&2; then
        unset "$name"
    else
        printf "%s\n" "Instance not found: $O" >&2
        return 1
    fi
}

___x_cmd_instance_has(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "[ \"\$$name\" != \"\${$name#*@\${object}-*}\" ]"
}

___x_cmd_instance_add(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    if ! eval "[ \"\$$name\" != \"\${$name#*@\${object}-*}\" ]"; then
        eval "$name=\"\${$name}@\${object}-\""
    else
        printf "%s\n" "Object already enlisted." >&2
        return 1
    fi
}

# ___x_cmd_instance_rm class object
# shellcheck disable=SC2034
___x_cmd_instance_rm(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "$name=\"\${$name%@\${object}-*}\${$name##*@\${object}-}\""
}

# ___x_cmd_instance_rm class
___x_cmd_instance_list(){
    local class="${1:?Provide class name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "[ -z \"\${$name}\" ]" && return
    eval printf \"%s\" "\"\${$name}\"" | tr "-" "\n" | tr -d @
}

___x_cmd_instance_clear(){
    local class="${1:?Provide class name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "$name="
}

# EndSection

# TODO: &3 is a global var. Must be handled in the proper way.
if command -v curl >/dev/null; then
    ___x_cmd_httpget_inner(){
        local url="${1:?Provide url}"
        local cache="${2}"
        ___xrc_log debug "curl --dump - --output $cache --speed-time 5 --speed-limit 10 $url"

        if [ -z "$cache" ]; then
            exec 3>&1
            ___X_CMD_HTTP_GET_INNER_HEADER="$(curl --silent --dump - --output /dev/stderr --speed-time 5 --speed-limit 10 "$url" 2>&3)"
            exec 3>&-
        else
            ___X_CMD_HTTP_GET_INNER_HEADER="$(curl --silent --dump - --output "$cache" --speed-time 5 --speed-limit 10 "$url")"
        fi

        local code=$?
        printf "%s" "$___X_CMD_HTTP_GET_INNER_HEADER" | ___x_cmd_httpget_handle_resp_header "$url" "$code"
    }
elif command -v wget >/dev/null && command -v ssl_client 1>/dev/null; then
    ___x_cmd_httpget_inner(){
        local url="${1:?Provide url}"
        local cache="${2}"

        if [ -z "$cache" ]; then
            exec 3>&1
            ___X_CMD_HTTP_GET_INNER_HEADER="$(wget -T 5 -qS "$url" 1>&3 2>/dev/stdout)"
            exec 3>&-
        else
            ___X_CMD_HTTP_GET_INNER_HEADER="$(wget -T 5 -O "$cache" -qS "$url" 2>/dev/stdout)"
        fi

        local code=$?
        printf "%s" "$___X_CMD_HTTP_GET_INNER_HEADER" | ___x_cmd_httpget_handle_resp_header "$url" "$code"
    }
else
    xrc xrc/lib/request_curl && ___x_cmd_http_download_curl 1>/dev/null && ___x_cmd_httpget_inner(){
        local url="${1:?Provide url}"
        local cache="${2}"
        if [ -z "$cache" ]; then
            exec 3>&1
            ___X_CMD_HTTP_GET_INNER_HEADER="$(x curl --silent --dump - --output /dev/stderr --speed-time 5 --speed-limit 10 "$url" 2>&3)"
            exec 3>&-
        else
            ___X_CMD_HTTP_GET_INNER_HEADER="$(x curl --silent --dump - --output "$cache" --speed-time 5 --speed-limit 10 "$url")"
        fi

        local code=$?
        printf "%s" "$___X_CMD_HTTP_GET_INNER_HEADER" | ___x_cmd_httpget_handle_resp_header "$url" "$code"
    }
fi
