# . ./lib/region
# . ./lib/varctl
xrc ui/lib/region
xrc ui/lib/varctl

CODE="$(xrc cat awk/lib/default.awk awk/lib/json.awk awk/lib/jiter.awk )"

_x_cmd_ui_get_env_ls(){
    local kp="${1:-"."}"
    cat | awk -v keypath="$kp" "$CODE"'
{
    jiter_print_eqarr_after_tokenize($0, keypath, "\n", "\n")
}
' | awk "$CODE"'
function print_env_ls(item){
    if ($0 == "") return
    if ( PRINT_ENV_LS == 0 ) {
        if (item !~ /^[\[\{:,]$/) {
            if (item !~ /^[\]\}]$/) print substr(item, 2, length(item)-2) "\n" "--- env " item
            return
        }
        PRINT_ENV_LS = 1
    }
    jiter_skip( item )
    if (JITER_SKIP_LEVEL > 0) return
    PRINT_ENV_LS = 0
}
NR>1{
    print_env_ls($0)
}
'
}

___x_cmd_ui_categoryselect(){
    ___x_cmd_ui_categoryselect_mainloop "$@"
}

___x_cmd_ui_categoryselect_test_func_env(){
    local IFS="."
    local p=".$*"
    cat ./.x-cmd/dev/testcase/xenv_testdata | _x_cmd_ui_get_env_ls "$p"
}

___x_cmd_ui_categoryselect_test_func_ls(){
    local tmp="$(printf "\006")"
    if [ "$#" -eq 0 ]; then
        ls -A . | xargs stat -c "%n
--- ls %F$tmp%s$tmp%x$tmp%y$tmp%z$tmp%A$tmp%u/%U$tmp%g/%G" 2>/dev/null
        return
    fi

    local IFS="/"
    local p="$*"
    [ ! -d "$p" ] && return 1
    cd "$p"
    ls -A | xargs stat -c "%n
--- ls %F$tmp%s$tmp%x$tmp%y$tmp%z$tmp%A$tmp%u/%U$tmp%g/%G" 2>/dev/null
    cd - >/dev/null
    return 0
}

___x_cmd_ui_categoryselect_mainloop(){
    local func="$1"; shift
    ___x_cmd_ui_region_run ___x_cmd_ui_categoryselect_mainloop_recursive_first
}
___x_cmd_ui_category_control_awk_(){
    command awk \
        "$@" \
        -f "$___X_CMD_ROOT/awk/lib/default.awk" \
        -f "$___X_CMD_ROOT/awk/lib/str.awk" \
        -f "$___X_CMD_ROOT/awk/lib/wcwidth.awk" \
        -f "$___X_CMD_ROOT/awk/lib/ui.awk" \
        -f "$___X_CMD_ROOT/ui/lib/share.awk" \
        -f "$___X_CMD_ROOT/ui/lib/theme.awk" \
        -f "$___X_CMD_ROOT/ui/lib/categoryselect.awk"
        # -f "./lib/categoryselect.awk"
}

___x_cmd_ui_category_control_awk(){
    if [ "$(___x_cmd_awk impl)" = "mawk" ]; then
        ___x_cmd_ui_category_control_awk_ -W interactive "$@"
    else
        ___x_cmd_ui_category_control_awk_ "$@"
    fi
}

___x_cmd_ui_categoryselect_mainloop_recursive_first(){
    local nextlist
    local is_stopped=
    {
        ___x_cmd_pidofsubshell
        ___x_cmd_ui_categoryselect_mainloop_recursive_update_nextlist
        ___x_cmd_ui_categoryselect_mainloop_recursive 1
    } | {
        local PID_OF_UPSUBSHELL
        read -r PID_OF_UPSUBSHELL
        ___x_cmd_ui_category_control_awk
        kill -SIGPIPE "$PID_OF_UPSUBSHELL"
    }
}

___x_cmd_ui_categoryselect_mainloop_recursive_curlist_curitem(){
    printf "%s" "$curlist" | awk -v idx="$((curidx*2-1))" 'NR==idx{ print $0; exit(0) }'
}

___x_cmd_ui_categoryselect_mainloop_recursive_curlist_len(){
    printf "%s" "$curlist" | awk 'END{ print int(NR/2); }'
}

___x_cmd_ui_send_newlist(){
    printf "%s %d %d\n" "---" "$1" "$2"
    shift 2
    if [ "$#" -gt 0 ] ;then
        printf "%s\n" "$*"
    fi
    printf "%s\n" "---"
}

___x_cmd_ui_send_data(){
    printf "%s\n" "$*"
}

___x_cmd_ui_categoryselect_mainloop_recursive_sendview(){
    ticks="$((ticks+1))"
    printf "R:%s:%s:%s\n" "$ticks" "$COLUMNS" "$LINES" # send view
}

___x_cmd_ui_categoryselect_mainloop_recursive_update_nextlist(){
    nextlist="$("$func" "$@")"
    expandable=$?
    ___x_cmd_ui_categoryselect_mainloop_recursive_sendview

    if [ "$expandable" = 0 ]; then
        ___x_cmd_ui_send_newlist "$((curlevel+1))" 0 "$nextlist"
    else
        ___x_cmd_ui_send_newlist "$((curlevel+1))" -1
    fi
}

# Using calling stack to simulate list to avoid lacking of efficient array support in Posix Sh. Proudly implemented by me
___x_cmd_ui_categoryselect_mainloop_recursive(){
    local curlevel="${1:?Provide level}";             shift 1
    local curlist="${nextlist}"
    local curlistl
    curlistl="$(___x_cmd_ui_categoryselect_mainloop_recursive_curlist_len)"
    local curidx=1
    local curitem
    curitem="$(___x_cmd_ui_categoryselect_mainloop_recursive_curlist_curitem)"
    local newlist
    local expandable
    ___x_cmd_ui_categoryselect_mainloop_recursive_update_nextlist "$@" "$curitem"

    while [ -z "$is_stopped" ]; do
        if ! ___x_cmd_ui_getchar; then
            is_stopped=1
            break
        fi
        case "${___X_CMD_UI_GETCHAR_CHAR}" in
            UP)
                ___x_cmd_ui_varctl_num curidx 1 "$curlistl" dec
                curitem="$(___x_cmd_ui_categoryselect_mainloop_recursive_curlist_curitem)"
                ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                ___x_cmd_ui_categoryselect_mainloop_recursive_update_nextlist "$@" "$curitem"
                ;;
            DN)
                ___x_cmd_ui_varctl_num curidx 1 "$curlistl" inc
                curitem="$(___x_cmd_ui_categoryselect_mainloop_recursive_curlist_curitem)"
                ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                ___x_cmd_ui_categoryselect_mainloop_recursive_update_nextlist "$@" "$curitem"
                ;;
            LEFT)
                if [ "$curlevel" != 1 ]; then
                    ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                    ___x_cmd_ui_categoryselect_mainloop_recursive_sendview
                    nextlist="${curlist}"
                    break
                fi
                ;;
            RIGHT)
                curlistl="$(___x_cmd_ui_categoryselect_mainloop_recursive_curlist_len)"
                if [ "$expandable" = 0  ] && [ "$curlistl" -gt 0 ]; then
                    ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                    ___x_cmd_ui_categoryselect_mainloop_recursive "$((curlevel+1))" "$@" "$curitem"
                fi
                ;;
            *)  ___x_cmd_ui_send_data "C:$___X_CMD_UI_GETCHAR_TYPE:$___X_CMD_UI_GETCHAR_CHAR"
                ___x_cmd_ui_categoryselect_mainloop_recursive_sendview ;;
        esac
    done
}


# ___x_cmd_ui_categoryselect ___x_cmd_ui_categoryselect_test_func_env
# ___x_cmd_ui_categoryselect ___x_cmd_ui_categoryselect_test_func_ls
# echo "___X_CMD_UI_CATEGORYSELECT_FINAL_COMMAND:" "$___X_CMD_UI_CATEGORYSELECT_FINAL_COMMAND"
# echo "___X_CMD_UI_CATEGORYSELECT_CURRENT_ITEM:" "$___X_CMD_UI_CATEGORYSELECT_CURRENT_ITEM"
