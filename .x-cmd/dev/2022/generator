
___x_cmd_json_flat(){
    awk -v op=flat-leaf -f "$___X_CMD_JSON_AWK_PATH"
}

# ___x_cmd_json_list 1 2 3 true false "\"true\"" hello "Working\"a"
# ___x_cmd_json_list <<A
# 1
# 2
# 3
# true
# false
# "true"
# hello
# Working\"a
# A
# ___x_cmd_json_list '[ 1, 2, 3, "true", true, false, hello"Working, it\'s working ]'

___x_cmd_json_array(){
    local s=
    while [ $# -gt 0 ]; do
        case "$1" in
            true|false|null)    s="$s,$1"   ;;
            [*)                 s="$s,$1";;
            \{*)                s="$s,$1";;
            # =\"*)             s="$2,${1:1}"   ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$1" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]];
                    then s="$s,$1" ;
                    else s="$s,\"${1//\"/\\\"}\"" ;
                    fi
                else
                    s="$(printf "%s" "$z" | awk -v s="$s" '{if($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){ s= s "," $0 ; }else{ gsub("\"","\\\"",$0);  s=s "," $0; }}END{print s}')"
                fi
                ;;
        esac
        shift
    done
    printf "%s" "[${s#?}]"
}


if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then

# Actually, it could works in ash. But we don't know how to detect ash environment.
___x_cmd_json_escape(){
    local a="${1:?Provide string}"
    a="$(echo "${a//$'\\'/\\}")"
    a="$(echo "${a//$'\n'/\\n}")"
    a="$(echo "${a//$'\r'/\\n}")"
    a="$(echo "${a//$'\t'/\\t}")"
    a="$(echo "${a//$'\b'/\\b}")"
    a="$(echo "${a//\"/\\\"}")"
    echo "\"$a\""
}

else

# Using awk for posix sh
___x_cmd_json_escape(){
    # Notice, if RS="\033", extra endline exsits because of bug in awk.
    awk '
BEGIN{
    RS=""   # RS="\003"
}
{
    a=$0
    gsub(/"/, "\\\"", a)
    gsub(/\n/, "\\n", a)
    gsub(/\r/, "\\r", a)
    gsub(/\b/, "\\b", a)
    gsub(/\t/, "\\t", a)
    gsub(/\v/, "\\v", a)
    printf("\"%s\"", a)
}
' <<A
${1:?Provide string}
A
}

fi

# Posix sh version?
___x_cmd_json_unescape(){
    if [ $# -gt 0 ]; then
        eval echo "$@"
    else
        while read -r line; do
            eval echo -e "$line"
        done
    fi
}

# Reference: https://github.com/jpmens/jo/blob/master/jo.md
___x_cmd_json_dict(){
    printf "{\n"

    local key value
    local first=0
    for i in "$@"; do
        if [ "$first" -eq 0 ]; then
            first=1
        else
            printf ',\n'
        fi

        key=${i%%=*}
        if [ "$key" != "$i" ]; then
            value=${i#*=}

            case "$value" in
            true|false|null|\{*\}|\[*\]|\"*)
                printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value" ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$value" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]]; then
                            printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                else
                    if [ "$(printf "%s" "$value" | awk '{if ($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){print "1";}else{print "0";} }' )" = "1" ]; then
                        printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                fi
            esac
            continue
        fi

        key=${i%%\:*}
        value=${i#*\:}
        printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$(___x_cmd_json_escape "$value")"
    done
    printf "\n}"
}

___x_cmd_json_dict_compact(){
    printf "{"

    local key value
    local first=0
    for i in "$@"; do
        if [ "$first" -eq 0 ]; then
            first=1
        else
            printf ','
        fi

        key=${i%%=*}
        if [ "$key" != "$i" ]; then
            value=${i#*=}

            case "$value" in
            true|false|null|\{*\}|\[*\]|\"*)
                printf '%s:%s' "$(___x_cmd_json_escape "$key")" "$value" ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$value" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]]; then
                            printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                else
                    if [ "$(printf "%s" "$value" | awk '{if ($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){print "1";}else{print "0";} }' )" = "1" ]; then
                        printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                fi
            esac
            continue
        fi

        key=${i%%\:*}
        value=${i#*\:}
        printf '%s: %s' "$(___x_cmd_json_escape "$key")" "$(___x_cmd_json_escape "$value")"
    done
    printf "}"
}


# Scheme 1:
# out_color_key = "\033[0;35m"
# out_color_string = "\033[0;34m"
# out_color_number = "\033[0;32m"
# out_color_null = "\033[0;33m"   # "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# Scheme 2:
# out_color_key = "\033[1;34m"
# out_color_string = "\033[0;33m"
# out_color_number = "\033[1;35m"
# out_color_null = "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# Scheme 3:
# out_color_key = "\033[1;33m"
# out_color_string = "\033[0;34m"
# out_color_number = "\033[0;35m"
# out_color_null = "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# TODO:array
# ___x_cmd_json_awk_color1(){
#     local IFS=$' '
#     A=(
#     -v out_color_key="\033[0;35m"
#     -v out_color_string="\033[0;34m"
#     -v out_color_number="\033[0;32m"
#     -v out_color_null="\033[0;33m"
#     -v out_color_true="\033[7;32m"
#     -v out_color_false="\033[7;31m"
#     )
#     echo "${A[*]}"
# }

# TODO: Using JSON
# TODO: array
# ___x_cmd_json_table(){
#     local n="${1:?Provide colume number}"
#     shift
#     local arr=() final=() idx=0 line IFS

#     if [ $# -gt 0 ]; then
#         for line in "$@"; do
#             (( idx ++ ))
#             arr+=("$line")
#             if [ "$idx" -eq "$n" ]; then
#                 final+=("$(___x_cmd_json_array "${arr[@]}")")
#                 arr=()
#                 idx=0
#             fi

#         done
#     else
#         while read -r line; do
#             (( idx ++ ))
#             arr+=("$line")
#             if [ "$idx" -eq "$n" ]; then
#                 final+=("$(___x_cmd_json_array "${arr[@]}")")
#                 arr=()
#                 idx=0
#             fi
#         done
#     fi
#     ___x_cmd_json_array "${final[@]}"
# }

# ___x_cmd_json_attrlist(){
#     local arr=() final=() idx=0 line IFS var
#     eval var="\$${idx}"
#     while read -r line; do
#         (( idx ++ ))
#         arr+=("$var=$line")
#         if [ "$idx" -eq "$#" ]; then
#             final+=("$(___x_cmd_json_dict "${arr[@]}")")
#             arr=()
#             idx=0
#         fi
#     done

#     ___x_cmd_json_array "${final[@]}"
# }


# Move to json library
___x_cmd_json_from_kv(){
    local first=0
    local k v

    local IFS=$'\n'
    # Using consider using environment.
    local PARSE_KEY_STR="$*"

    while :; do
        read -r k || break
        read -r v || break

        if [ "$first" -eq 0 ]; then
            printf "{\n"
            first=1
        else
            printf ',\n'
        fi

        if echo "$PARSE_KEY_STR" | grep -q "$k"; then
            # TODO: using float
            if [ "$(printf "%s" "$v" | awk '{if ($0 ~ /^[1-9]+([0-9])*$/){print "1";}else{print "0";} }' )" = "1" ] || [ "$v" = true ] || [ "$v" = false ]; then
                printf '  "%s": %s' "$k" "$v"
                continue
            fi
        fi

        printf '  "%s": "%s"' "$k" "$v"
    done
    [ $first -ne 0 ] && printf "\n}"
}

# Simply json stringify
# ___x_cmd_json_from_kv(){
#     printf "{\n"
#     local first=0
#     local k v
#     for i in $(list.print); do

#         if [ "$first" -eq 0 ]; then
#             first=1
#         else
#             printf ',\n'
#         fi

#         k=$(echo -n "$i" | cut -d ':' -f 1)
#         v=$(echo -n "$i" | cut -d ':' -f 2)

#         printf '  "%s": "%s"' "$(str.unbase64 "$k")" "$(str.unbase64 "$v")"
#     done
#     printf "\n}"
# }

