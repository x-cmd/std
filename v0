# shellcheck shell=sh disable=SC2039,SC3043

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao

JSON_AWK_PATH="$(xrc which json/v0_walk.awk)"

# Section: main

# TODO: Using subcmd module to enhance.

json(){
    local op
    if [ $# -eq 0 ]; then
        op=help
    else
        op="${1}"
        shift
    fi

    case "$op" in
        help)   cat >&2 <<A
json    json utilities
        Uasge:  json subcommand [...arguments]
        Please visit following hosting repository for more information:
            https://gitee.com/x-bash/json
            https://github.com/x-bash/json
            https://gitlab.com/x-bash/json
            https://bitbucket.com/x-bash/json

Subcommand:
        var                 json var <variable-name> <data>. $(tput init)
                            Regulate the data to standard json, then putting into variable
        color|col|c         json color <variable-name>. $(tput init)
                            Colorize the formated json stored in variable
        push|append         json push <variable-name.<pattern>> <element>. $(tput init)
                            Putting the element at the end of the specified list in variable
        unshift|prepend     json unshift <variable-name.<pattern>> <element>.
                            Putting the element at the begin of the specified list in variable
        keys|key|k          json keys <variable-name.<pattern>>.
                            Printing the keys of the specified dictionary in variable
        values|val|v        json values <variable-name.<pattern>>.
                            Printing the values of the specified dictionary in variable
        shift|sh            json shift <variable-name.<pattern>>.
                            Shift the values of the specified list in variable
        pop|po              json pop <variable-name.<pattern>>.
                            Pop the values of the specified list in variable
        del|d               json del <variable-name.<pattern>>.
                            delete the values of the specified list in variable
        length|len          json len <variable-name.<pattern>>.
                            Print the length of the specified list or object in variable
        unescape
        <none>
A
        ;;
        var)                json_var        "$@" ;;
        color|col|c)        json_color      "$@" ;;
        push|append)        json_push       "$@" ;;
        unshift|prepend)    json_prepend    "$@" ;;
        put)                json_put        "$@" ;;
        keys|key|k)         json_keys       "$@" ;;
        values|val|v)       json_values     "$@" ;;
        query|q)            json_query      "$@" ;;
        del|d)              json_del        "$@" ;;
        shift|sh)           json_shift      "$@" ;;
        pop|po)             json_pop        "$@" ;;
        length|len)         json_length     "$@" ;;
        unescape)           json_unescape   "$@" ;;
        *)                  json q          "$op" "$@" ;;
    esac
}

# EndSection

# Section: functions

# We have a better design
json_var(){
    local varname="${1:?Provide variable name}"
    shift
    local s
    if [ $# -ne 0 ]; then
        s="$(awk -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"$@\"))
A
)"
    else
        s="$(awk -f "$JSON_AWK_PATH" -)"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

json_color(){
    if [ "$1" ]; then
        local varname="${1:?Provide variable name}"
        awk -v format=1 -v color=1 -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v format=1 -v color=1 -f "$JSON_AWK_PATH" -
    fi
}

# aaa.push()
json_push(){ json_append "$@"; }

# aaa.append()
json_append(){
    local keypath="${1:?Provide variable name}"
    local opv2="${2:?Provide value}"

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"
    [ "$varname" = "$keypath" ] && opv1="."
    shift 2

    local s
    if [ "$varname" ]; then
        s="$(awk -v op=append -v opv1="$opv1" -v opv2="$opv2" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)"
    else
        s="$(awk -v op=append -v opv1="$opv1" -v opv2="$opv2" -f "$JSON_AWK_PATH")"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

# aaa.prepend("value")
json_unshift(){ json_prepend "$@"; }
json_prepend(){
    local keypath=${1:?Provide variable name}
    local opv2="${2:?Provide value}"

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    shift 2

    local s
    if [ "$varname" ]; then
        s="$(awk -v op=prepend -v opv1="$opv1" -v opv2="$opv2" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)"
    else
        s="$(awk -v op=prepend -v opv1="$opv1" -v opv2="$opv2" -f "$JSON_AWK_PATH")"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

# jo b.b= 2

: <<'DOCTEST'
> b={a:1}
> json_put b.b 2
> echo "$b"
{"a":1,"b":"2"}
DOCTEST
json_put(){
    local keypath="${1:?Provide variable name}"
    local opv2="${2:?Provide value}"
    shift 2

    local varname="${keypath%%.*}"
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    local s
    if [ "$varname" ]; then
        s="$(awk -v op=put -v opv1="$opv1" -v opv2="$opv2" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)"
    else
        s="$(awk -v op=put -v opv1="$opv1" -v opv2="$opv2" -f "$JSON_AWK_PATH")"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

# jo b.b
: <<'DOCTEST'
> b=[1,2,3]
> json_values b
1
2
3
DOCTEST
json_values(){
    local op=values
    if [ "$1" = "-r" ]; then
        op="values-r"
        shift
    fi

    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1=""
    # TODO: why？Seems wrong
    # shift 2

    local s
    if [ "$varname" ]; then
        awk -v op="$op" -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op="$op" -v opv1="$opv1" -f "$JSON_AWK_PATH"
    fi
}

: <<'DOCTEST'
> b={a:1,b:2,c:3}
> json_values b
a
b
c
DOCTEST
json_keys(){
    local op=keys
    if [ "$1" = "-r" ]; then
        op=keys-r
        shift
    fi

    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1=""
    # TODO: why？Seems wrong
    # shift 2

    local s
    if [ "$varname" ]; then
        awk -v op="$op" -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op="$op" -v opv1="$opv1" -f "$JSON_AWK_PATH"
    fi
}

# jo b.b
json_query(){
    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    # shift 2

    if [ "$varname" ]; then
        awk -v op=extract -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op=extract -v opv1="$opv1" -f "$JSON_AWK_PATH" -
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> json_del b.[0]
> echo $b  # json_del
[2,3]
DOCTEST
json_del(){
    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    # shift 2

    if [ "$varname" ]; then
        if s="$(awk -v op=del -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)";     then
            local t=""
            while read -r s; do
                t+="$s"
            done <<A
$s
A
            [ -n "$t" ] && printf "%s\n" "$t"
            eval "$varname=\"\$t\""
        else return 1;  fi
    else
        awk -v op=del -v opv1="$opv1" -f "$JSON_AWK_PATH" | tail -n 1
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> json_shift b
> echo $b; # json_shift
[2,3]
DOCTEST
json_shift(){
    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    # shift 2

    if [ "$varname" ]; then
        if s="$(awk -v op=shift -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)";     then
            local t=""
            while read -r s; do
                t+="$s"
            done <<A
$s
A
            printf "%s\n" "$t"
            eval "$varname=\"\$t\""
        else return 1;  fi
    else
        awk -v op=shift -v opv1="$opv1" -f "$JSON_AWK_PATH" | tail -n 1
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> json_length b
3
DOCTEST
json_length(){
    local keypath="${1:?Provide variable name}"; shift

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."

    if [ "$varname" ]; then
        awk -v op=length -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op=length -v opv1="$opv1" -f "$JSON_AWK_PATH"
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> json_pop b
> echo $b # json_pop
[1,2]
DOCTEST

# TODO: json pop b :a  # values stored in symbol a
# TODO: json pop b @a  # all values stored in array b
json_pop(){
    local keypath="${1:?Provide variable name}"; shift

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."

    local s
    if [ "$varname" ]; then
        if s="$(awk -v op=pop -v opv1="$opv1" -f "$JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)";     then
            local t=""
            while read -r s; do
                t+="$s"
            done <<A
$s
A
            printf "%s\n" "$t"
            eval "$varname=\"\$t\""
        else return 1;  fi
    else
        awk -v op=pop -v opv1="$opv1" -f "$JSON_AWK_PATH" | tail -n 1
    fi
}

# EndSection

# Section: serialize and unserialize

json_flat(){
    awk -v op=flat-leaf -f "$JSON_AWK_PATH"
}

json_array(){
    local s=
    while [ $# -gt 0 ]; do
        case "$1" in
            true|false|null)    s="$s,$1"   ;;
            [*)                s="$s,$1";;
            \{*)              s="$s,$1";;
            # =\"*)             s="$2,${1:1}"   ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$1" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]];
                    then s="$s,$1" ;
                    else s="$s,\"${1//\"/\\\"}\"" ;
                    fi
                else
                    s="$(printf "%s" "$z" | awk -v s="$s" '{if($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){ s= s "," $0 ; }else{ gsub("\"","\\\"",$0);  s=s "," $0; }}END{print s}')"
                fi
                ;;
        esac
        shift
    done
    echo "[${s:1}]"
}


if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then

# Actually, it could works in ash. But we don't know how to detect ash environment.
json_escape(){
    local a="${1:?Provide string}"
    a="$(echo "${a//$'\\'/\\}")"
    a="$(echo "${a//$'\n'/\\n}")"
    a="$(echo "${a//$'\r'/\\n}")"
    a="$(echo "${a//$'\t'/\\t}")"
    a="$(echo "${a//$'\b'/\\b}")"
    a="$(echo "${a//\"/\\\"}")"
    echo "\"$a\""
}

else

# Using awk for posix sh
json_escape(){
    # Notice, if RS="\033", extra endline exsits because of bug in awk.
    awk '
BEGIN{
    RS=""   # RS="\003"
}
{
    a=$0
    gsub(/\"/, "\\\"", a)
    gsub(/\n/, "\\n", a)
    gsub(/\r/, "\\r", a)
    gsub(/\b/, "\\b", a)
    gsub(/\t/, "\\t", a)
    gsub(/\v/, "\\v", a)
    printf("\"%s\"", a)
}
' <<A
${1:?Provide string}
A
}

fi

# Posix sh version?
json_unescape(){
    if [ $# -gt 0 ]; then
        eval echo "$@"
    else
        while read -r line; do
            eval echo -e "$line"
        done
    fi
}

# Reference: https://github.com/jpmens/jo/blob/master/jo.md
json_dict(){
    printf "{\n"

    local key value
    local first=0
    for i in "$@"; do
        if [ "$first" -eq 0 ]; then
            first=1
        else
            printf ',\n'
        fi

        key=${i%%=*}
        if [ "$key" != "$i" ]; then
            value=${i#*=}

            case "$value" in
            true|false|null|\{*\}|\[*\]|\"*)
                printf '  %s: %s' "$(json_escape "$key")" "$value" ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$value" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]]; then
                            printf '  %s: %s' "$(json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(json_escape "$value")"
                    fi
                else
                    if [ "$(printf "%s" "$value" | awk '{if ($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){print "1";}else{print "0";} }' )" = "1" ]; then
                        printf '  %s: %s' "$(json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(json_escape "$value")"
                    fi
                fi
            esac
            continue
        fi

        key=${i%%\:*}
        value=${i#*\:}
        printf '  %s: %s' "$(json_escape "$key")" "$(json_escape "$value")"
    done
    printf "\n}"
}

json_dict_compact(){
    printf "{"

    local key value
    local first=0
    for i in "$@"; do
        if [ "$first" -eq 0 ]; then
            first=1
        else
            printf ','
        fi

        key=${i%%=*}
        if [ "$key" != "$i" ]; then
            value=${i#*=}

            case "$value" in
            true|false|null|\{*\}|\[*\]|\"*)
                printf '%s:%s' "$(json_escape "$key")" "$value" ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$value" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]]; then
                            printf '  %s: %s' "$(json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(json_escape "$value")"
                    fi
                else
                    if [ "$(printf "%s" "$value" | awk '{if ($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){print "1";}else{print "0";} }' )" = "1" ]; then
                        printf '  %s: %s' "$(json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(json_escape "$value")"
                    fi
                fi
            esac
            continue
        fi

        key=${i%%\:*}
        value=${i#*\:}
        printf '%s: %s' "$(json_escape "$key")" "$(json_escape "$value")"
    done
    printf "}"
}


# Scheme 1:
# out_color_key = "\033[0;35m"
# out_color_string = "\033[0;34m"
# out_color_number = "\033[0;32m"
# out_color_null = "\033[0;33m"   # "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# Scheme 2:
# out_color_key = "\033[1;34m"
# out_color_string = "\033[0;33m"
# out_color_number = "\033[1;35m"
# out_color_null = "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# Scheme 3:
# out_color_key = "\033[1;33m"
# out_color_string = "\033[0;34m"
# out_color_number = "\033[0;35m"
# out_color_null = "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# TODO:array
# json_awk_color1(){
#     local IFS=$' '
#     A=(
#     -v out_color_key="\033[0;35m"
#     -v out_color_string="\033[0;34m"
#     -v out_color_number="\033[0;32m"
#     -v out_color_null="\033[0;33m"
#     -v out_color_true="\033[7;32m"
#     -v out_color_false="\033[7;31m"
#     )
#     echo "${A[*]}"
# }

# TODO: Using JSON
# TODO: array
# json_table(){
#     local n="${1:?Provide colume number}"
#     shift
#     local arr=() final=() idx=0 line IFS

#     if [ $# -gt 0 ]; then
#         for line in "$@"; do
#             (( idx ++ ))
#             arr+=("$line")
#             if [ "$idx" -eq "$n" ]; then
#                 final+=("$(json_array "${arr[@]}")")
#                 arr=()
#                 idx=0
#             fi

#         done
#     else
#         while read -r line; do
#             (( idx ++ ))
#             arr+=("$line")
#             if [ "$idx" -eq "$n" ]; then
#                 final+=("$(json_array "${arr[@]}")")
#                 arr=()
#                 idx=0
#             fi
#         done
#     fi
#     json_array "${final[@]}"
# }

# json_attrlist(){
#     local arr=() final=() idx=0 line IFS var
#     eval var="\$${idx}"
#     while read -r line; do
#         (( idx ++ ))
#         arr+=("$var=$line")
#         if [ "$idx" -eq "$#" ]; then
#             final+=("$(json_dict "${arr[@]}")")
#             arr=()
#             idx=0
#         fi
#     done

#     json_array "${final[@]}"
# }


# Move to json library
json_from_kv(){
    local first=0
    local k v

    local IFS=$'\n'
    # Using consider using environment.
    local PARSE_KEY_STR="$*"

    while :; do
        read -r k || break
        read -r v || break

        if [ "$first" -eq 0 ]; then
            printf "{\n"
            first=1
        else
            printf ',\n'
        fi

        if echo "$PARSE_KEY_STR" | grep -q "$k"; then
            # TODO: using float
            if [ "$(printf "%s" "$v" | awk '{if ($0 ~ /^[1-9]+([0-9])*$/){print "1";}else{print "0";} }' )" = "1" ] || [ "$v" = true ] || [ "$v" = false ]; then
                printf '  "%s": %s' "$k" "$v"
                continue
            fi
        fi

        printf '  "%s": "%s"' "$k" "$v"
    done
    [ $first -ne 0 ] && printf "\n}"
}

# Simply json stringify
# json_from_kv(){
#     printf "{\n"
#     local first=0
#     local k v
#     for i in $(list.print); do

#         if [ "$first" -eq 0 ]; then
#             first=1
#         else
#             printf ',\n'
#         fi

#         k=$(echo -n "$i" | cut -d ':' -f 1)
#         v=$(echo -n "$i" | cut -d ':' -f 2)

#         printf '  "%s": "%s"' "$(str.unbase64 "$k")" "$(str.unbase64 "$v")"
#     done
#     printf "\n}"
# }

# EndSection

# Section: json facility using awk

___X_CMD_JSON_AWK_SRC="$(xrc cat awk/_v0/json.awk)"
___X_CMD_JSON_AWK_SRC="$(xrc cat awk/_v0/default.awk)
$___X_CMD_JSON_AWK_SRC
"

___json_awk_end(){
    local func=jiter_after_tokenize
    if [ -n "$ALREADY_TOKENIZED" ]; then
        func=jiter
    fi

        awk "$___X_CMD_JSON_AWK_SRC
{ $func(_, \$0); }
$1"

}

___json_awk_tokenize(){
    awk "$___X_CMD_JSON_AWK_SRC"'
{
    printf(jtokenize($0))
}
'
}

___json_awk_parse_flat_stream(){
    awk "$___X_CMD_JSON_AWK_SRC"'
{ jiter(_, $0) }'"
$1
"
}

___json_awk_parse_stream(){
    awk "$___X_CMD_JSON_AWK_SRC"'
{ jiter_after_tokenize(_, $0) }'"
$1
"
}

___json_awk_parse(){
    awk -v RS="$(printf "\001")" "$___X_CMD_JSON_AWK_SRC"'
{ r = $0 }
END{ json_parse(r, jobj) }'"
$1
"
}

___json_awk_parse_flat(){
    awk -v RS="$(printf "\001")" "$___X_CMD_JSON_AWK_SRC"'
{ r = $0 }
END{ ___json_parse(r, jobj) print jget(jobj, "3.1.id") }'"
$1
"
}

___json_awk_get(){
    local func=jiter_after_tokenize
    if [ -n "$ALREADY_TOKENIZED" ]; then
        func=jiter
    fi

    local IFS
    IFS="$(printf "\002")"

    local code
    if code="$(awk -v data="$*" "$___X_CMD_JSON_AWK_SRC
{ $func(_, \$0); }"'
END {
    arrl = split(data, arr, "\002")
    for (i=1; i<=arrl; ++i) {
        e = arr[i]
        idx = index(e, "=")
        if (idx <= 0) {
            exit(1)
            break
        }

        varname = substr(e, 1, idx-1)
        expr    = substr(e, idx+1)
        print varname "=" jget(_, expr)
    }
}
')"; then

        eval "$code"
    fi

}

___json_var(){
    local IFS="
"
    local varname
    local data
    while read -r data; do
        [ "$#" -le 0 ] && break
        eval "$1"="$data"
        shift
    done
}

___json_awk_table_flat_stream(){

    local key="$1"
    local keylist="$2"

    local SEP1="${SEP1:-"\002"}"
    local SEP2="${SEP2:-"\003"}"

    ___json_awk_parse_flat_stream '
END{
    print jjoin(_, "'"$key"'", "'"$SEP1"'", "'"$keylist"'", "'"$SEP2"'")
}
'
}

___json_awk_table_stream(){

    local key="$1"
    local keylist="$2"

    local SEP1="${SEP1:-"\002"}"
    local SEP2="${SEP2:-"\003"}"


    ___json_awk_parse_stream '
END{
    # print json_handle_jpath(".table.abc.1.name")
    # print jget(_, ".table.abc.1.name")
    print jjoin_to_table(_, "'"$key"'", "", "'"$SEP1"'", "'"$keylist"'", "'"$SEP2"'")
    # print jjoin(_, "'"$key"'", "", "\n", "'"$keylist"'", ", ")
}
'
}

___json_awk_str_compact(){
    awk "$___X_CMD_JSON_AWK_SRC"'
{ jiter(_, $0) }'"
END {
    json_stringify_machine(_, \""$1"\")
}
"
}

___json_awk_print_exact(){
    awk -v key="$1" "$___X_CMD_JSON_AWK_SRC"'

BEGIN{
    key = json_handle_jpath( key )
}
{
    jiter_print_exact_after_tokenize(_, $0, key)
}
'
}

# EndSection
