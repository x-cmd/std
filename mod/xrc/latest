# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao
# license:      GPLv3

# if curl --version 1>/dev/null 2>&1; then
# Section: Requirement & Initialize
[ -n "$KSH_VERSION" ] && alias local=typeset

___x_cmd_http_getfile(){
    local url="${1:?Provide url}"
    local cache="${2}"
    ___xrc_log debug curl --dump - --output "$cache" --speed-time 5 --speed-limit 10 "$url"

    # TODO: --speed-time 3

    if [ -z "$cache" ]; then
        exec 3>&1
        ___X_CMD_HTTP_GET_INNER_HEADER="$(curl --silent --dump - --output /dev/stderr --speed-time 5 --speed-limit 10 "$url" 2>&3)"
        exec 3>&-
    else
        ___X_CMD_HTTP_GET_INNER_HEADER="$(curl --silent --dump - --output "$cache" --speed-time 5 --speed-limit 10 "$url")"
    fi

    local code=$?
    local http_code
    http_code="$(printf "%s" "$___X_CMD_HTTP_GET_INNER_HEADER" | awk 'NR==1{ printf("%s", $2); }')"

    case "$http_code" in
        20*)   return 0 ;;
        40*)    ___xrc_log debug "HTTP_CODE: $http_code. Fail to retrieve file from: $1"
                return 4 ;;
        "")     ___xrc_log debug "Return code: $code. HTTP_CODE Unavialable. Fail to retrieve file from: $1"
                return 1 ;;
        *)      ___xrc_log debug "Unknow error. HTTP_CODE: $http_code. Fail to retrieve file from: $1"
                return 2 ;;
    esac
}

___xrc_log(){
    local level="$1"; shift
    [ "$level" = debug ] && return
    printf "[%s]: %s\n" "$level" "$@" 1>&2
}

___X_CMD_CUR_SHELL="sh"
if      [ -n "$ZSH_VERSION" ];  then    ___X_CMD_CUR_SHELL="zsh";  setopt aliases
elif    [ -n "$BASH_VERSION" ]; then    ___X_CMD_CUR_SHELL="bash"; shopt -s expand_aliases
elif    [ -n "$KSH_VERSION" ];  then    ___X_CMD_CUR_SHELL="ksh"
fi

# To prevent dash inline environment problem
___x_cmd_source(){
    . "$@"
}

TMPDIR=${TMPDIR:-$(dirname "$(mktemp -u)")/}    # It is posix standard. BUT NOT set in some cases.

if [ -z "$___X_CMD_ROOT" ]; then
    ___X_CMD_ROOT="$HOME/.x-cmd"           # boot will be placed in "$HOME/.x-cmd/boot"
    ___xrc_log debug "Setting env ___X_CMD_ROOT: $___X_CMD_ROOT"
    [ -d "$___X_CMD_ROOT" ] || mkdir -p "$___X_CMD_ROOT" || return 1 || exit 1
    PATH="$___X_CMD_ROOT/.bin:$PATH"
fi

# EndSection

# Section: network curl
___x_cmd_curl() {
    local url="${1:?Provide url}"
    local cache="$2"
    local cache_expiration="$3"

    local redirect_path=            # "&1"
    if [ -n "$cache" ]; then
        if [ -f "$cache" ]; then
            # days
            case "$cache_expiration" in
                "") # infinite time
                    ___xrc_log debug "Function ___x_cmd_curl() terminated. Because local cache existed with update flag unset: $cache"
                    return 0
                    ;;
                -)  # force update
                    ;;
                *)  # days
                    if [ -n "$(find "$cache" -mtime "-$cache_expiration" 2>/dev/null)" ]; then
                        ___xrc_log debug "Function ___x_cmd_curl() terminated. Because local cache existed within days: $cache_expiration"
                        return 0
                    fi
            esac
        fi

        # First make sure it works before webservice. Fail fast.
        mkdir -p "$(dirname "$cache")"
        redirect_path="$TMPDIR/x-bash-temp-download.$RANDOM"
    fi

    printf "URL is %s\n" "$url" >&2
    if ___x_cmd_http_getfile "$url" "$redirect_path"; then
        if [ -n "$cache" ]; then
            ___xrc_log debug "Copy the temp file to CACHE file: $cache"
            mv "$redirect_path" "$cache"
        fi
    else
        code=$?
        [ -n "$cache" ] && rm -f "$redirect_path"    # In centos, file in "$redirect_path" is write protected.
        return $code
    fi
}

# org reponame branch suburl
___x_cmd_curl_gitx(){   # Simple strategy
    local owner="${1:?Provide owner}"
    local reponame="${2:?Provide reponame}"
    local branch="${3:?Provide branch}"
    local suburl="${4:?Provide location like str}"
    local cache="${5}"
    local cache_expiration="${6}"

    local IFS

    local mirror_list
    mirror_list="$(___x_cmd_mirror)"

    local mirror
    local lineno=1
    local urlpath
    while read -r mirror; do
        # shellcheck disable=SC2059
        urlpath="$(printf "$mirror" "$owner" "$reponame" "${branch}" "$suburl")"
        ___x_cmd_curl "$urlpath" "$cache" "$cache_expiration"

        case $? in
            0)  if [ "$lineno" -ne 1 ]; then
                    ___xrc_log debug "Current default mirror is $mirror"
                    ___x_cmd_mirror "$mirror" "$(echo "$mirror_list" | awk "NR!=$lineno{ print \$0 }" )"

                    # Set CHINA_NET FLAG
                    case "$mirror" in
                        *gitee*)                    ___X_CMD_IN_CHINA_NET=1 ;;
                        *github*|*gitlab*)          ___X_CMD_IN_CHINA_NET=  ;;
                    esac
                fi
                return 0;;
            1)  ___xrc_log debug "Network unavailable."
                return 1;;
            4)  ___xrc_log debug "Resource Not Found."
                return 4;;
            *)
                ___xrc_log debug "Network unavailable Or Mirror is down: $urlpath"
                return 1;;
        esac
        lineno=$((lineno+1))
    done <<A
${mirror_list}
A
    return 1
}


___x_cmd_curl_gitx_official(){
    ___x_cmd_curl_gitx x-cmd "$___X_CMD_CODESORUCE_REPO" "${___X_CMD_CODESORUCE_REPO_BRANCH}" "${1:?Provide url}" "$2" "$3"
}

# EndSection

# Section: mirror

___X_CMD_CODESORUCE_REPO_BRANCH=${___X_CMD_CODESORUCE_REPO_BRANCH:-main}
___X_CMD_CODESORUCE_REPO=${___X_CMD_CODESORUCE_REPO:-x-cmd}

___x_cmd_mirror(){
    local fp="$___X_CMD_ROOT/.source.mirror.list"
    if [ $# -ne 0 ]; then
        local IFS="
";
        printf "%s" "$*" >"$fp"
        return
    fi

    # TODO: what if the mirror file is wrong or empty? ... We should have a solution for that.
    if [ -f "$fp" ]; then
        cat "$fp"
        return
    fi

    tee "$fp" <<A
https://raw.githubusercontent.com/%s/%s/%s/%s
https://gitee.com/%s/%s/raw/%s/%s
A

}

if [ "$___X_CMD_IN_CHINA_NET" = 1 ]; then
    ___x_cmd_mirror \
            "https://gitee.com/%s/%s/raw/%s/%s" \
            "https://raw.githubusercontent.com/%s/%s/%s/%s"
fi

case "$(___x_cmd_mirror | head -n1)" in
    *gitee*)    ___X_CMD_IN_CHINA_NET=1 ;;
    *)          ___X_CMD_IN_CHINA_NET=
esac
# EndSection

# Section: main entrance

___x_cmd_xrc_set_main(){
    ___X_CMD_XRC_SET_MAIN="${1:?Provide function}"
}

# shellcheck disable=SC1091
xrc(){
    [ $# -eq 0 ] && set -- "help"
    local subcmd="$1";  shift
    case "$subcmd" in
        ""|help)
            printf "xrc     x-bash core function.
    Uasge:  xrc <lib> [<lib>...]
    Please visit our homepage for more information: https://x-cmd.com
SUBCOMMAND:
    cat|c           Show the script in text form.
    which|w         Download lib files and print the local path.
    update|u        Update file.
    cache           Provide cache filepath.
    clear           Clear the cache.
    ls              Show the cache modules.
" >&2
            ;;
        c|cat)
            if [ $# -gt 0 ]; then
                ___x_cmd_xrc_cat "$@"
                return
            fi
            cat >&2 <<A
xrc cat         Show the script in text form
    Uasge:  xrc  cat <lib> [<lib>...]
    Example: eval "$(xrc cat str)"
A
            return 1;;
        w|which)
            if [ $# -gt 0 ]; then
                ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$@"
                printf "%s" "$___X_CMD_WHICH_ONE_RESULT"
                return
            fi
            cat >&2 <<A
xrc which       Download lib files and print the local path.
    Uasge:  xrc which <lib> [<lib>...]
    Example: source "$(xrc which str)"
A
            return 1 ;;
        root)
            printf "%s" "$___X_CMD_ROOT" ;;
        mirror)
            ___x_cmd_mirror "$@" ;;
        export-all)
            ( xrc x-bash/xrc/lib/export &&  ___x_cmd_xrc_export_all "$@" ) ;;
        update)
            (
                local CACHE="$___X_CMD_ROOT/all.tgz"
                # rm -rf "$___X_CMD_ROOT" # Dangerous.
                if ___x_cmd_curl_gitx_official "dist/all.tgz" "$CACHE" -; then
                    cd "$___X_CMD_ROOT" && tar xvf "$CACHE"
                    rm "$CACHE"
                    ___XRC_UDPATE=1
                    ___X_CMD_XRC_MODULE_IMPORTED=
                    ___x_cmd_source "$___X_CMD_ROOT"/xrc/latest
                fi
            )
            ;;
        upgrade)
            ___XRC_UDPATE=1
            ___X_CMD_XRC_MODULE_IMPORTED=
            rm -rf "$___X_CMD_ROOT/.boot/boot" && eval "$(curl https://get.x-cmd.com)"
            ;;
        log)
            printf "WARN: xrc log deprecated, you should using 'x log' instead\n" >&2
            x log "$@" ;;
        ls)
            ls "$___X_CMD_ROOT" ;;  # If tar.gz, using tar ls. If folder, ls $folder
        setmain)
            ___x_cmd_xrc_set_main "$@" ;;
        reload)
            if [ "$#" -gt 0 ]; then
                local ___X_CMD_XRC_RELOAD=1
                ___x_cmd_xrc_source_file "$@"
                return
            fi
            RELOAD=1 xrc xrc/latest; return ;;
        _x_cmd_advise_json)
            cat <<A
{
    "cat": {
        "#n": "ls $___X_CMD_ROOT | grep -v BASE64",
        "#desc": "Show the script in text form"
    },
    "which": {
        "#n": "ls $___X_CMD_ROOT | grep -v BASE64",
        "#desc": "Download lib files and print the local path"
    },
    "cache": "--- Provide cache filepath",
    "clear": "--- Clear the cache",
    "update": "--- Update file",
    "ls": "--- Show the cache modules",
    "upgrade": {},
    "reload": {},
    "root": {},
    "export-all": {},
    "mirror": {
        "#n": [
            "https://x-bash.gitee.io",
            "https://x-bash.github.io",
            "https://x-bash.gitlab.io",
            "https://bitbucket.com/x-bash/x-bash"
        ]
    }
}
A
            return 126
            ;;
        *)
            ___x_cmd_xrc_source_file "$subcmd" "$@"
            return
    esac
}
# EndSection

# Section: ldict
___X_CMD_LDICT(){
    local op="$1"; shift
    case "$op" in
        put)        ___x_cmd_ldict_put "$@" ;;
        get)        ___x_cmd_ldict_get "$@" ;;
        keys)       ___x_cmd_ldict_keys "$@" ;;
        print)      ___x_cmd_ldict_print "$@" ;;
        *)
            printf "Show help for ldict\n" >&2
            return 1
    esac
}

alias ldict="___X_CMD_LDICT"

___X_CMD_LDICT_SEP="$(printf "\001")"
___X_CMD_LDICT_KVSEP="$(printf "\002")"

___x_cmd_ldict_put(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"
    local value="${3:?Provide value}"

    ___x_cmd_ldict_rm "$name" "$key"

    eval "___X_CMD_LDICT_${name}=\"\${___X_CMD_LDICT_${name}:-\${___X_CMD_LDICT_SEP}}\${key}\${___X_CMD_LDICT_KVSEP}\${value}\${___X_CMD_LDICT_SEP}\""
}

___x_cmd_ldict_rm(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"

    local tmp
    eval "tmp=\"\${___X_CMD_LDICT_${name}#*\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}*\${___X_CMD_LDICT_SEP}}\""
    if eval [ \"\$tmp\" != \"\$"___X_CMD_LDICT_${name}"\" ]; then
        eval "___X_CMD_LDICT_${name}=\"\${___X_CMD_LDICT_${name}%%\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}*}\${___X_CMD_LDICT_SEP}\${tmp}\""
        return 0
    fi
    return 1
}

___x_cmd_ldict_has(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"

    local tmp
    eval "tmp=\"\${___X_CMD_LDICT_${name}#*\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}*\${___X_CMD_LDICT_SEP}}\""
    eval [ \"\$tmp\" != \"\$"___X_CMD_LDICT_${name}"\" ]
}

___x_cmd_ldict_get(){
    local name="${1:?Provide dict name}"
    local key="${2:?Provide key}"

    local tmp

    eval "tmp=\"\${___X_CMD_LDICT_${name}#*\${___X_CMD_LDICT_SEP}\${key}\${___X_CMD_LDICT_KVSEP}}\""

    if eval [ \"\$tmp\" != \"\$"___X_CMD_LDICT_${name}"\" ]; then
        printf "%s" "${tmp%%${___X_CMD_LDICT_SEP}*}"
    else
        return 1
    fi
}

___x_cmd_ldict_keys(){
    local name="${1:?Provide dict name}"
    eval printf \"%s\" \"\$"___X_CMD_LDICT_${name}"\" | awk -v RS="$___X_CMD_LDICT_SEP" -v FS="${___X_CMD_LDICT_KVSEP}" '
NR!=1{
    print $1
}'
}

___x_cmd_ldict_print(){
    local name="${1:?Provide dict name}"
    eval printf \"%s\" \"\$"___X_CMD_LDICT_${name}"\" | awk -v RS="$___X_CMD_LDICT_SEP" -v FS="${___X_CMD_LDICT_KVSEP}" '
NR!=1{
    print $1 " = " $2
}'
}

# EndSection

# Section: llist
___x_cmd_llist(){
    local op="$1"; shift
    case "$op" in
        init)           ___x_cmd_llist_init "$@" ;;
        shift)          ___x_cmd_llist_shift "$@" ;;
        unshift)        ___x_cmd_llist_unshift "$@" ;;
        push)           ___x_cmd_llist_push "$@" ;;
        pop)            ___x_cmd_llist_pop "$@" ;;
        has)            ___x_cmd_llist_has "$@" ;;
        print)          ___x_cmd_llist_print "$@" ;;
        *)
            printf "Show help for llist\n" >&2
            return 1
    esac
}

alias llist="___x_cmd_llist"

___x_cmd_llist_init(){
    local name="${1:?Provide list name}"
    eval "___x_cmd_llist_$name=\"\${___X_CMD_LDICT_SEP}\""
}

___x_cmd_llist_push(){
    local name="${1:?Provide list name}"
    local value="${2:?Provide value}"

    eval "___X_CMD_LLIST_${name}=\"\${___X_CMD_LLIST_${name}:-\${___X_CMD_LDICT_SEP}}\${value}\${___X_CMD_LDICT_SEP}\""
}

___x_cmd_llist_unshift(){
    local name="${1:?Provide list name}"
    local value="${2:?Provide value}"

    eval "___X_CMD_LLIST_${name}=\"\${___X_CMD_LDICT_SEP}\${value}\${___X_CMD_LLIST_${name}:-\${___X_CMD_LDICT_SEP}}\""
}

___x_cmd_llist_has(){
    local name="${1:?Provide dict name}"
    local value="${2:?Provide key}"

    local part1
    eval "part1=\"\${___X_CMD_LLIST_${name}#*\${___X_CMD_LDICT_SEP}\${value}\${___X_CMD_LDICT_SEP}}\""
    eval [ \"\$part1\" != \"\$"___X_CMD_LLIST_${name}"\" ]
}

___x_cmd_llist_print(){
    local name="${1:?Provide dict name}"
    eval printf \"%s\" \"\$"___X_CMD_LLIST_${name}"\" | awk -v RS="$___X_CMD_LDICT_SEP" '
NR!=1{
    print $1
}'
}
# EndSection

# Section: main entrance helper
___x_cmd_xrc_cat(){
    local file
    while [ $# -ne 0 ]; do
        local ___X_CMD_LOCAL_XRCPATH="$1";   shift

        if ! ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$___X_CMD_LOCAL_XRCPATH"; then
            printf "ERROR: Interrupted because resource not found. %s \n" "$___X_CMD_LOCAL_XRCPATH" >&2
            return 1
        fi

        cat "$___X_CMD_WHICH_ONE_RESULT"
    done
}

___X_CMD_XRC_MODULE_IMPORTED="
"

___x_cmd_xrc_source_file(){
    local ___X_CMD_WHICH_ONE_RESULT
    local ___X_CMD_LOCAL_XRCPATH

    while [ $# -ne 0 ]; do
        ___X_CMD_LOCAL_XRCPATH="$1";   shift

        if ! ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$___X_CMD_LOCAL_XRCPATH"; then
            printf "ERROR: Interrupted because resource not found. %s \n" "$___X_CMD_LOCAL_XRCPATH" >&2
            printf "%s\n" "return 1"
            return 1
        fi

        # Ask whether using http or outside resource.
        if [ "$___X_CMD_WHICH_ONE_RESOURCE_TYPE" = http ] && [ -z "$NOWARN" ]; then

            # We should do it before ___x_cmd_which_one
            printf "Sourcing script from untrusted location: %s\n" "$___X_CMD_LOCAL_XRCPATH"
            cat >&2 <<A
SECURITY WARNING! Sourcing script from untrusted location: $___X_CMD_WHICH_ONE_RESULT
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
> NOWARN=1 xrc "$___X_CMD_LOCAL_XRCPATH"
A
            printf "Input yes to continue. Otherwise exit > " >&2
            local ___X_CMD_LOCAL_INPUT
            read -r ___X_CMD_LOCAL_INPUT

            if [ "$___X_CMD_LOCAL_INPUT" != "yes" ]; then
                rm "$___X_CMD_WHICH_ONE_RESULT"
                printf "%s\n" "Exit because of a non yes output received: $___X_CMD_LOCAL_INPUT" >&2
                printf "%s\n" "return 1"
                return 1
            fi
        fi

        ___x_cmd_xrc_source_file_main "$___X_CMD_WHICH_ONE_RESULT"
    done
}

___x_cmd_xrc_source_file_main(){
    ___X_CMD_WHICH_ONE_RESULT="${1:?Provide exact file}"

    if [ -z "$___X_CMD_XRC_RELOAD" ]; then
        if [ "${___X_CMD_XRC_MODULE_IMPORTED#*
"$___X_CMD_WHICH_ONE_RESULT"
*}" != "${___X_CMD_XRC_MODULE_IMPORTED}" ]; then
            return    # exited already. skip
        fi
    fi

    ___X_CMD_XRC_MODULE_IMPORTED="
${___X_CMD_WHICH_ONE_RESULT}${___X_CMD_XRC_MODULE_IMPORTED}"

    ___X_CMD_XRC_SET_MAIN=
    ___x_cmd_source "$___X_CMD_WHICH_ONE_RESULT"

    if [ -n "$___X_CMD_XRC_SET_MAIN" ]; then
        ___x_cmd_ldict_put ___X_CMD_XRC_SET_MAIN_DICT "${___X_CMD_WHICH_ONE_RESULT}" "${___X_CMD_XRC_SET_MAIN}"
        # TODO: rename module
        ___X_CMD_XRC_SET_MAIN=
    fi
}

___x_cmd_search_path(){
    local cur="${1:?Provide starting path}"

    cur="$(cd "$cur" 1>/dev/null 2>&1 && pwd)"

    local relative_filepath="${2:?Provide relative filepath}"
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/$relative_filepath" ]; then
            printf "%s" "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}
# EndSection

# Section: which
# RETURN ___X_CMD_WHICH_ONE_RESULT
___x_cmd_which_one(){
    local RESOURCE_NAME=${1:?Provide resource name}

    ___X_CMD_WHICH_ONE_RESULT=

    local TGT
    ___X_CMD_WHICH_ONE_RESOURCE_TYPE=official
    case "$RESOURCE_NAME" in
        /*)
            ___X_CMD_WHICH_ONE_RESOURCE_TYPE=local
            ___xrc_log debug "Resource recognized as local file: $RESOURCE_NAME"
            ___X_CMD_WHICH_ONE_RESULT="$RESOURCE_NAME"
            return 0
            ;;
        http://*|https://*)
            ___X_CMD_WHICH_ONE_RESOURCE_TYPE=http
            ___xrc_log debug "Resource recognized as http resource: $RESOURCE_NAME"

            TGT="$___X_CMD_ROOT/.http_resource/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" ___x_cmd_curl "$RESOURCE_NAME"; then
                ___xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            else
                ___X_CMD_WHICH_ONE_RESULT="$TGT"
            fi
            ;;
        *@*/*)
            xrc hub/latest
            ___xcmd_hub_file_which "$RESOURCE_NAME"     # Will set ___X_CMD_WHICH_ONE_RESOURCE_TYPE=1 if from unknow source
            ;;
        ./*|../*)
            ___xrc_log debug "Resource recognized as local file with relative path: $RESOURCE_NAME"
            local tmp
            if tmp="$(cd "$(dirname "$RESOURCE_NAME")" || exit 1; pwd)"; then
                ___X_CMD_WHICH_ONE_RESOURCE_TYPE=local
                ___X_CMD_WHICH_ONE_RESULT="$tmp/$(basename "$RESOURCE_NAME")"
                return 0
            else
                ___xrc_log warn "Local file not exists: $RESOURCE_NAME"
                return 1
            fi
            ;;
        *)
            if [ -z "$___X_CMD_NO_LOCAL" ]; then
                # This is ONLY for x-cmd
                [ -f "$RESOURCE_NAME" ] && ___X_CMD_WHICH_ONE_RESULT="$RESOURCE_NAME" && return      # local file

                if TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
                    ___X_CMD_WHICH_ONE_RESOURCE_TYPE=workspace
                    ___X_CMD_WHICH_ONE_RESULT="$TGT/.x-cmd/$RESOURCE_NAME"
                    return                   # .x-cmd
                fi
            fi

            # x-bash module
            ___xrc_log debug "Resource recognized as x-bash module: $RESOURCE_NAME"
            local module="$RESOURCE_NAME"
            if [ "${RESOURCE_NAME#*/}" = "$RESOURCE_NAME" ] ; then
                module="$module/latest"         # If it is short alias like str (short for str/latest)
                ___xrc_log debug "Version suffix unavailable. Using \"latest\" by default: $module"
            fi

            TGT="$___X_CMD_ROOT/$module"
            [ -f "$TGT" ] && ___X_CMD_WHICH_ONE_RESULT="$TGT" && return 0
            # ___xrc_log debug "Module not found: $module"
            # return 1

            ___xrc_log info "Downloading resource=$RESOURCE_NAME to local cache: $TGT"
            ___x_cmd_curl_gitx_official "mod/$module" "$TGT" \
                && ___X_CMD_WHICH_ONE_RESULT="$TGT" && return 0

            ___xrc_log warn "ERROR: Fail to load module due to network error or other: $RESOURCE_NAME"
            return 1
    esac
}
# EndSection

# Section: Instance management.

# TODO: We could use list to replace this facility.
# ___x_cmd_instance_add class object
___x_cmd_instance_new(){
    local name="${2:?Provide object name}"
    name="${name#?}"
    eval "
function $name {
    $1 $2 \"\$@\"
}
"
}

___x_cmd_instance_del(){
    local name="${2:?Provide object name}"
    # TODO:
    if [ $# -gt 2 ];then
        eval "$@"
    fi
    name="${name#?}"
    if command -v "$name" 1>/dev/null 2>&2; then
        unset "$name"
    else
        printf "%s\n" "Instance not found: $O" >&2
        return 1
    fi
}

___x_cmd_instance_has(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "[ \"\$$name\" != \"\${$name#*@\${object}-*}\" ]"
}

___x_cmd_instance_add(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    if ! eval "[ \"\$$name\" != \"\${$name#*@\${object}-*}\" ]"; then
        eval "$name=\"\${$name}@\${object}-\""
    else
        printf "%s\n" "Object already enlisted." >&2
        return 1
    fi
}

# ___x_cmd_instance_rm class object
# shellcheck disable=SC2034
___x_cmd_instance_rm(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "$name=\"\${$name%@\${object}-*}\${$name##*@\${object}-}\""
}

# ___x_cmd_instance_rm class
___x_cmd_instance_list(){
    local class="${1:?Provide class name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "[ -z \"\${$name}\" ]" && return
    eval printf \"%s\" "\"\${$name}\"" | tr "-" "\n" | tr -d @
}

___x_cmd_instance_clear(){
    local class="${1:?Provide class name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "$name="
}

# EndSection

# Section: env

# TODO: using an environment to mark
___x_cmd_is_interative_tty(){
    [ "${-#*i}" != "$-" ]
}

___x_cmd_is_suitable_advise_env(){
    [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]
}

___x_cmd_awk(){
    xrc awk/latest && ___x_cmd_awk "$@"
}

___x_cmd_readlink_recursive(){
    if [ -L "${1:?Provide link}" ]; then
        local next_link
        next_link="$(readlink "${1}")" || return
        if [ "${next_link#/}" = "$next_link" ]; then
            next_link="$(dirname "${1}")/$next_link"
        fi
        ___x_cmd_readlink_recursive "$next_link"
    else
        [ ! -e "${1}" ] && return 1        # File Not Exists
        printf "%s" "$1"
    fi
}

if [ -n "$BASH_VERSION" ]; then
    ___X_CMD_SHELL=bash
elif [ -n "$ZSH_VERSION" ]; then
    ___X_CMD_SHELL=zsh
elif [ -n "$KSH_VERSION" ]; then
    ___X_CMD_SHELL=ksh
else
    ___X_CMD_SHELL="$(
        res="$(___x_cmd_readlink_recursive "$(command -v "$0")")"
        if [ "${res%dash}" != "$res" ]; then
            printf "%s" dash
        elif /bin/sh --help 2>&1 | grep BusyBox >/dev/null; then
            printf "%s" ash
        else
            printf "WARNING: %s\n" "Unknown shell." >&2
        fi
    )"
fi

# EndSection

# Section: other initialization: advise, initrc lazy loading
# [ -f "$(x initrc which)" ] && . "$(x initrc which)"
x(){    unset -f x; xrc reload x-cmd/latest && x ${1:+"$@"};    }

alias xws="x ws"
alias xdev="x dev"

if ___x_cmd_is_suitable_advise_env; then
    ___xrc_log debug "Using module advise for completion."
    xrc advise/latest && advise init xrc && advise init x
    # load all advise json from advise dir
    advise load
fi
# EndSection

# else
#     printf "boot[ERR]: Cannot found curl or wget for web resource downloader." >&2
#     return 1 2>/dev/null
#     ( return 1 )                # Provide error code 1
#     # return 1 || exit 1
# fi
