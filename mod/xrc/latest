# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263

if curl --version 1>/dev/null 2>&1; then
# Section: Requirement & Initialize
    [ -n "$KSH_VERSION" ] && alias local=typeset

    ___x_cmd_http_get_inner(){
        ___X_CMD_CURL_RETURN="$(printf "\r")"
        ___X_CMD_CURL_HEADER=""

        echo curl -i "$@" >&2

        {
            while read -r line; do
                [ "$line" = "$___X_CMD_CURL_RETURN" ] && break
                ___X_CMD_CURL_HEADER="$___X_CMD_CURL_HEADER
$line"
            done
            cat
        } <<A
$(curl -i "$@")
A
    }

    ___x_cmd_http_get_response_header(){
        printf "%s" "$___X_CMD_CURL_HEADER"
    }

    ___x_cmd_http_get_response_header_code(){
        ___x_cmd_http_get_response_header | awk 'NR==2{ printf($2); }'
    }

    ___x_cmd_http_get(){
        ___xrc_log debug "curl -i ${XRC_MAX_TIME+--max-time $XRC_MAX_TIME} ${1:?Provide target URL}"

        if [ -z "$XRC_MAX_TIME" ]; then
            ___x_cmd_http_get_inner "$1" 2>/dev/null
        else
            # Other solution: --speed-time 5 --speed-limit 10, disconnect if less than 10kb, and last for 5 seconds.
            # eval curl ${XRC_MAX_TIME+--max-time $XRC_MAX_TIME} --fail "\"\${1}\"" 2>/dev/null
            ___x_cmd_http_get_inner --max-time $XRC_MAX_TIME "$1" 2>/dev/null
        fi

        local code=$?
        local http_code
        http_code="$(___x_cmd_http_get_response_header_code)"

        case "$http_code" in
            20*)   return 0 ;;
            40*)    ___xrc_log debug "HTTP_CODE: $http_code. Fail to retrieve file from: $1"
                    return 4 ;;
            "")     ___xrc_log debug "Return code: $code. HTTP_CODE Unavialable. Fail to retrieve file from: $1"
                    return 1 ;;
            *)      ___xrc_log debug "Unknow error. HTTP_CODE: $http_code. Fail to retrieve file from: $1"
                    return 2 ;;
        esac
    }

___xrc_log(){
    local level="$1"; shift
    [ "$level" = debug ] && return
    printf "[%s]: %s\n" "$level" "$@" 1>&2
}

___X_CMD_CUR_SHELL="sh"
if      [ -n "$ZSH_VERSION" ];  then    ___X_CMD_CUR_SHELL="zsh";  setopt aliases
elif    [ -n "$BASH_VERSION" ]; then    ___X_CMD_CUR_SHELL="bash"; shopt -s expand_aliases
elif    [ -n "$KSH_VERSION" ];  then    ___X_CMD_CUR_SHELL="ksh"
fi

TMPDIR=${TMPDIR:-$(dirname "$(mktemp -u)")/}    # It is posix standard. BUT NOT set in some cases.

if [ -z "$___X_CMD_ROOT" ]; then
    ___xrc_log debug "Setting env ___X_CMD_ROOT: $___X_CMD_ROOT"
    ___X_CMD_ROOT="$HOME/.x-cmd"           # boot will be placed in "$HOME/.x-cmd/boot"
    mkdir -p "$___X_CMD_ROOT" || return 1 || exit 1
    PATH="$___X_CMD_ROOT/.bin:$PATH"
fi

if [ -f "$___X_CMD_ROOT/.tgz/core.tgz" ]; then
    ___X_CMD_COER_TGZ_FILES_CACHE="
$(tar tf "$___X_CMD_ROOT/.tgz/core.tgz")"
    ___X_CMD_COER_TGZ_MOD_CACHE="
$(printf "%s" "$___X_CMD_COER_TGZ_FILES_CACHE" | awk -v FS=/ '{ print $1; }' | uniq)"
fi

# EndSection

# Section: network & mirror
___x_cmd_curl() {
    local REDIRECT=/dev/stdout
    if [ -n "$CACHE" ]; then
        if [ -z "$___XRC_UPDATE" ] && [ -f "$CACHE" ]; then
            ___xrc_log debug "Function ___x_cmd_curl() terminated. Because local cache existed with update flag unset: $CACHE"
            return 0
        fi
        # First make sure it works before webservice. Fail fast.
        mkdir -p "$(dirname "$CACHE")"
        REDIRECT="$TMPDIR/x-bash-temp-download.$RANDOM"
    fi

    if ___x_cmd_http_get "$1" 1>"$REDIRECT"; then
        if [ -n "$CACHE" ]; then
            ___xrc_log debug "Copy the temp file to CACHE file: $CACHE"
            mv "$REDIRECT" "$CACHE"
        fi
    else
        code=$?
        [ -n "$CACHE" ] && rm -f "$REDIRECT"    # In centos, file in "$REDIRECT" is write protected.
        return $code
    fi
}

___X_CMD_BRANCH=main

___x_cmd_mirror(){
    local fp="$___X_CMD_ROOT/.source.mirror.list"
    if [ $# -ne 0 ]; then
        mkdir -p "$(dirname "$fp")"
        local IFS="
";
        printf "%s" "$*" >"$fp"
        return
    fi
    if [ ! -f "$fp" ]; then
        ___x_cmd_mirror \
            "https://raw.githubusercontent.com/x-cmd/x-cmd/$___X_CMD_BRANCH/mod/%s/%s" \
            "https://gitee.com/x-cmd/x-cmd/raw/$___X_CMD_BRANCH/mod/%s/%s"
        #     "https://raw.githubusercontent.com/%s/%s/$___X_CMD_BRANCH/%s" \
        #     "https://gitee.com/%s/%s/raw/$___X_CMD_BRANCH/%s"
    fi
    cat "$fp"
}

if [ "$___X_CMD_IN_CHINA_NET" = 1 ]; then
    ___x_cmd_mirror \
            "https://gitee.com/x-cmd/x-cmd/raw/$___X_CMD_BRANCH/mod/%s/%s" \
            "https://raw.githubusercontent.com/x-cmd/x-cmd/$___X_CMD_BRANCH/mod/%s/%s"
fi

case "$(xrc mirror|head -n1)" in
    *gitee*)    ___X_CMD_IN_CHINA_NET=1 ;;
    *)          ___X_CMD_IN_CHINA_NET=
esac
# EndSection

# Section: main entrance
xrc(){
    [ $# -eq 0 ] && set -- "help"
    local subcmd="$1";  shift
    case "$subcmd" in
        ""|help)
            printf "xrc     x-bash core function.
    Uasge:  xrc <lib> [<lib>...]
    Please visit our homepage for more information: https://x-cmd.com
SUBCOMMAND:
    cat|c           Show the script in text form.
    which|w         Download lib files and print the local path.
    update|u        Update file
    upgrade         Upgrade xrc from 'https://get.x-cmd.com/script'
    cache           Provide cache filepath
    clear           Clear the cache
    ls              Show the cache modules.
" >&2
            ;;
        c|cat)
            if [ $# -gt 0 ]; then
                eval "$(___X_CMD_XRC_EVAL_SOURCE="" ___x_cmd_xrc_source_file_source "$@")"
                return
            fi
            cat >&2 <<A
xrc cat         Show the script in text form
    Uasge:  xrc  cat <lib> [<lib>...]
    Example: eval "$(xrc cat str)"
A
            return 1;;
        w|which)
            if [ $# -gt 0 ]; then
                ___x_cmd_which_one "$@"
                return
            fi
            cat >&2 <<A
xrc which       Download lib files and print the local path.
    Uasge:  xrc which <lib> [<lib>...]
    Example: source "$(xrc which str)"
A
            return 1 ;;
        root)
            printf "%s" "$___X_CMD_ROOT" ;;
        mirror)
            ___x_cmd_mirror "$@" ;;
        export-all)
            ( xrc x-bash/xrc/_v0/export &&  ___xcmd_xrc_export_all "$@" ) ;;
        update)
            ( xrc x-bash/xrc/_v0/update &&  xrc_update "$@" ) ;;
        log)
            printf "WARN: xrc log deprecated, you should using 'x log' instead\n"
            x log "$@" ;;
        ls)
            ls "$___X_CMD_ROOT" ;;  # If tar.gz, using tar ls. If folder, ls $folder
        reload)
            if [ "$#" -gt 0 ]; then
                local ___XRC_RELOAD=1
                eval "$(___X_CMD_XRC_EVAL_SOURCE=1 ___x_cmd_xrc_source_file_source "$@")"
                return
            fi
            RELOAD=1 xrc xrc/latest; return ;;
        *)
            eval "$(___X_CMD_XRC_EVAL_SOURCE=1 ___x_cmd_xrc_source_file_source "$subcmd" "$@")"
            return
    esac
}
# EndSection

# Section: main entrance helper
___X_CMD_XRC_MODULE_IMPORTED=""
___x_cmd_xrc_source_file_source(){

    local code

    local last="cat"
    while [ $# -ne 0 ]; do
        local xrcpath=$1;   shift

        local XRC_MAX_TIME=3        # Consider one file is less than 100KB, bandwidth at least 35KB/s.
        file="$(___x_cmd_which_one "$xrcpath")"
        code=$?

        if [ -n "$___X_CMD_XRC_EVAL_SOURCE" ]; then
            # This is running
            # Ask whether using http or outside resource.
            if [ "$___X_CMD_UNTRUSTED_RESOURCE" = 1 ] && [ -z "$NOWARN" ]; then
                printf "Sourcing script from unknown location: %s\n" "$xrcpath"
                cat >&2 <<A
SECURITY WARNING! Sourcing script from unknown location: $1
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
> NOWARN=1 xrc "$1"
A
                printf "Input yes to continue. Otherwise exit > " >&2
                local input
                read -r input

                if [ "$input" != "yes" ]; then
                    echo "Exit becaause detect a non yes output: $input" >&2
                    return 1
                fi
            fi
        fi

        case "$code" in
            1)
                printf "Interrupted because resource not found." >&2
                return 1 ;;
            0)
                if [ "${last%%\ *}" = cat ]; then
                    last="$last $file"
                else
                    eval tar Oxvf "$last"
                    last="cat $file"
                fi ;;
            101)
                local targz=${file%\ *}
                local fp=${file#*\ }
                if [ "${last%%\ *}" = "$targz" ]; then
                    last="$last $fp"
                else
                    if [ "$last" != cat ]; then
                        eval "$last"
                    fi
                    last="$file"
                fi ;;
        esac

        if [ -z "$___X_CMD_XRC_EVAL_SOURCE" ]; then
            if [ -z "$___XRC_RELOAD" ]; then
                if [ "${___X_CMD_XRC_MODULE_IMPORTED#
$file
}" != "${___X_CMD_XRC_MODULE_IMPORTED}" ]; then
                    shift
                    continue    # exixted already. skip
                fi
            fi
            ___X_CMD_XRC_MODULE_IMPORTED="${___X_CMD_XRC_MODULE_IMPORTED}
$file
"
            printf "%s" "
___X_CMD_XRC_MODULE_IMPORTED=\"\$___X_CMD_XRC_MODULE_IMPORTED
$file
\""
        fi
    done

    if [ "$last" != cat ]; then
        eval "$last"
    fi
}

___x_cmd_curl_gitx(){   # Simple strategy
    local mod="${1:?Provide location like str}"
    local mod_repo=${mod%%/*}
    local mod_subpath=${mod#*/}

    local IFS

    local mirror_list
    mirror_list="$(xrc mirror)"

    local mirror
    local lineno=1
    local urlpath
    while read -r mirror; do
        # shellcheck disable=SC2059
        urlpath="$(printf "$mirror" "$mod_repo" "$mod_subpath")"
        ___x_cmd_curl "$urlpath"

        case $? in
            0)  if [ "$lineno" -ne 1 ]; then
                    ___xrc_log debug "Current default mirror is $mirror"
                    xrc mirror "$mirror" "$(echo "$mirror_list" | awk "NR!=$lineno{ print \$0 }" )"

                    # Set CHINA_NET FLAG
                    case "$mirror" in
                        *gitee*)                    ___X_CMD_IN_CHINA_NET=1 ;;
                        *github*|*gitlab*)          ___X_CMD_IN_CHINA_NET=  ;;
                    esac
                fi
                return 0;;
            1)  ___xrc_log debug "Network unavailable."
                return 1;;
            4)  ___xrc_log debug "Resource Not Found."
                return 4;;
            *)
                ___xrc_log debug "Network unavailable Or Mirror is down: $urlpath"
                return 1;;
        esac
        lineno=$((lineno+1))
    done <<A
${mirror_list}
A
    return 1
}

___x_cmd_search_path(){
    local cur="${1:?Provide starting path}"

    cur="$(cd "$cur" 1>/dev/null 2>&1 && pwd)"

    local relative_filepath="${2:?Provide relative filepath}"
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/$relative_filepath" ]; then
            printf "%s" "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}

___x_cmd_which_one_file(){
    local module=${1:?Provide module}
    local TGT="${2:?Provide tgt}"

    if [ -z "$___XRC_UPDATE" ] && [ -f "$TGT" ]; then
        printf "%s" "$TGT"
        return
    fi

    ___xrc_log info "Dowloading resource=$module to local cache: $TGT"
    if ! CACHE="$TGT" ___x_cmd_curl_gitx "$module"; then
        local code=$?
        case $code in
            4)      ___xrc_log error "ERROR: Module Inexisted: $module" ;;
            *)      ___xrc_log error "ERROR: Fail to load module due to network error or other: $module" ;;
        esac
        return 1
    fi
    printf "%s" "$TGT"
}

___x_cmd_which_one_tar(){
    # If match in core.tar.gz

    local mod_path=${1}
    local mod_root=${mod_path%%/*}

    if [ -n "$___X_CMD_COER_TGZ_MOD_CACHE" ]; then
        local res="${___X_CMD_COER_TGZ_MOD_CACHE#
$mod_root
}"
        if [ "$res" != "$___X_CMD_COER_TGZ_MOD_CACHE" ]; then
            printf "%s %s" "$mod_path" "$___X_CMD_ROOT/.tgz/core.tgz"
            return 0
        fi
    fi

    # TODO: check and download.
    local CACHE="$___X_CMD_ROOT/.tgz/$mod_root.tgz"
    local webfile="$mod_root/$mod_root.tgz"
    if ! ___x_cmd_curl_gitx "$webfile"; then
        local code=$?
        case $code in
            4)      ___xrc_log warn "Module Tar Inexisted: $webfile" ;;
            *)      ___xrc_log error "ERROR: Fail to load module due to network error or other: $webfile" ;;
        esac
        return 1
    fi

    return 0
}

___x_cmd_which_one(){
    local RESOURCE_NAME=${1:?Provide resource name}

    local TGT
    ___X_CMD_UNTRUSTED_RESOURCE=0
    case "$RESOURCE_NAME" in
        /*)
            ___xrc_log debug "Resource recognized as local file: $RESOURCE_NAME"
            printf "%s" "$RESOURCE_NAME"
            return 0
            ;;
        http://*|https://*)
            ___X_CMD_UNTRUSTED_RESOURCE=1
            ___xrc_log debug "Resource recognized as http resource: $RESOURCE_NAME"

            TGT="$___X_CMD_ROOT/.http_resource/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" ___x_cmd_curl "$RESOURCE_NAME"; then
                ___xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            else
                printf "%s" "$TGT"
            fi
            ;;
        *@*/*)
            xrc hub/v0
            ___xcmd_hub_file_which "$RESOURCE_NAME"     # Will set ___X_CMD_UNTRUSTED_RESOURCE=1 if from unknow source
            ;;
        ./*|../*)
            ___xrc_log debug "Resource recognized as local file with relative path: $RESOURCE_NAME"
            local tmp
            if tmp="$(cd "$(dirname "$RESOURCE_NAME")" || exit 1; pwd)"; then
                printf "%s" "$tmp/$(basename "$RESOURCE_NAME")"
                return 0
            else
                ___xrc_log warn "Local file not exists: $RESOURCE_NAME"
                return 1
            fi
            ;;
        *)
            [ -f "$RESOURCE_NAME" ] && printf "%s" "$RESOURCE_NAME" && return      # local file

            if TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
                printf "%s" "$TGT/.x-cmd/$RESOURCE_NAME"
                return                   # .x-cmd
            fi

            TGT="$___X_CMD_ROOT/$module"
            [ -f "$TGT" ] && printf "%s" "$TGT" && return 0

            # x-bash module
            ___xrc_log debug "Resource recognized as x-bash module: $RESOURCE_NAME"
            local module="$RESOURCE_NAME"
            if [ "${RESOURCE_NAME#*/}" = "$RESOURCE_NAME" ] ; then
                module="$module/latest"         # If it is short alias like str (short for str/latest)
                ___xrc_log debug "Version suffix unavailable. Using \"latest\" by default: $module"
            fi

            if ___x_cmd_which_one_tar "$module"; then
                return 101
            fi

            # TGT="$___X_CMD_ROOT/$module"
            ___x_cmd_which_one_file "$module" "$___X_CMD_ROOT/$module"
    esac
}
# EndSection

# Section: other initialization: advise, initrc lazy loading
# [ -f "$(x initrc which)" ] && . "$(x initrc which)"
x(){    unset -f x; xrc reload x-cmd/v0 && x ${1:+"$@"};    }

if [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]; then
    ___xrc_log debug "Using module advise for completion."
    xrc advise/v0
    advise init xrc - <<A
{
    "cat|c": {
        "#n": "ls $___X_CMD_ROOT | grep -v BASE64"
    },
    "which|w": {
        "#n": "ls $___X_CMD_ROOT | grep -v BASE64"
    },
    "cache": {},
    "clear": {},
    "mirror": {
        "#n": [
            "https://x-bash.gitee.io",
            "https://x-bash.github.io",
            "https://x-bash.gitlab.io",
            "https://bitbucket.com/x-bash/x-bash"
        ]
    }
}
A
fi
# EndSection

else
    printf "boot[ERR]: Cannot found curl or wget for web resource downloader." >&2
    return 1 2>/dev/null
    ( return 1 )                # Provide error code 1
    # return 1 || exit 1
fi
