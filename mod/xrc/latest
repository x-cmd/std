# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao
# license:      GPLv3

# if curl --version 1>/dev/null 2>&1; then
# Section: Requirement & Initialize
[ -n "$KSH_VERSION" ] && alias local=typeset

___x_cmd_http_getfile(){
    local url="${1:?Provide url}"
    local cache="${2:?Provide local cache}"
    ___xrc_log debug curl --dump - --output "$cache" --speed-time 5 --speed-limit 10 "$url"

    # TODO: --speed-time 3
    ___X_CMD_HTTP_GET_INNER_HEADER="$(curl --dump - --output "$cache" --speed-time 5 --speed-limit 10 "$url")"

    local code=$?
    local http_code
    http_code="$(printf "%s" "$___X_CMD_HTTP_GET_INNER_HEADER" | awk 'NR==1{ printf("%s", $2); }')"

    case "$http_code" in
        20*)   return 0 ;;
        40*)    ___xrc_log debug "HTTP_CODE: $http_code. Fail to retrieve file from: $1"
                return 4 ;;
        "")     ___xrc_log debug "Return code: $code. HTTP_CODE Unavialable. Fail to retrieve file from: $1"
                return 1 ;;
        *)      ___xrc_log debug "Unknow error. HTTP_CODE: $http_code. Fail to retrieve file from: $1"
                return 2 ;;
    esac
}

___xrc_log(){
    local level="$1"; shift
    [ "$level" = debug ] && return
    printf "[%s]: %s\n" "$level" "$@" 1>&2
}

___X_CMD_CUR_SHELL="sh"
if      [ -n "$ZSH_VERSION" ];  then    ___X_CMD_CUR_SHELL="zsh";  setopt aliases
elif    [ -n "$BASH_VERSION" ]; then    ___X_CMD_CUR_SHELL="bash"; shopt -s expand_aliases
elif    [ -n "$KSH_VERSION" ];  then    ___X_CMD_CUR_SHELL="ksh"
fi

# To prevent dash inline environment problem
___x_cmd_source(){
    . "$@"
}

TMPDIR=${TMPDIR:-$(dirname "$(mktemp -u)")/}    # It is posix standard. BUT NOT set in some cases.

if [ -z "$___X_CMD_ROOT" ]; then
    ___X_CMD_ROOT="$HOME/.x-cmd"           # boot will be placed in "$HOME/.x-cmd/boot"
    ___xrc_log debug "Setting env ___X_CMD_ROOT: $___X_CMD_ROOT"
    mkdir -p "$___X_CMD_ROOT" || return 1 || exit 1
    PATH="$___X_CMD_ROOT/.bin:$PATH"
fi

# EndSection

# Section: network & mirror
___x_cmd_curl() {
    local REDIRECT="&1"
    if [ -n "$CACHE" ]; then
        if [ -z "$___X_CMD_CURL_UPDATE" ] && [ -f "$CACHE" ]; then
            ___xrc_log debug "Function ___x_cmd_curl() terminated. Because local cache existed with update flag unset: $CACHE"
            return 0
        fi
        # First make sure it works before webservice. Fail fast.
        mkdir -p "$(dirname "$CACHE")"
        REDIRECT="$TMPDIR/x-bash-temp-download.$RANDOM"
    fi

    printf "URL is %s\n" "$1" >&2
    if ___x_cmd_http_getfile "$1" "$REDIRECT"; then
        if [ -n "$CACHE" ]; then
            ___xrc_log debug "Copy the temp file to CACHE file: $CACHE"
            mv "$REDIRECT" "$CACHE"
        fi
    else
        code=$?
        [ -n "$CACHE" ] && rm -f "$REDIRECT"    # In centos, file in "$REDIRECT" is write protected.
        return $code
    fi
}

___X_CMD_BRANCH=main

___x_cmd_mirror(){
    local fp="$___X_CMD_ROOT/.source.mirror.list"
    if [ $# -ne 0 ]; then
        mkdir -p "$(dirname "$fp")"
        local IFS="
";
        printf "%s" "$*" >"$fp"
        return
    fi
    if [ ! -f "$fp" ]; then
        ___x_cmd_mirror \
            "https://raw.githubusercontent.com/x-cmd/x-cmd/$___X_CMD_BRANCH/mod/%s" \
            "https://gitee.com/x-cmd/x-cmd/raw/$___X_CMD_BRANCH/mod/%s"
    fi
    cat "$fp"
}

if [ "$___X_CMD_IN_CHINA_NET" = 1 ]; then
    ___x_cmd_mirror \
            "https://gitee.com/x-cmd/x-cmd/raw/$___X_CMD_BRANCH/mod/%s" \
            "https://raw.githubusercontent.com/x-cmd/x-cmd/$___X_CMD_BRANCH/mod/%s"
fi

case "$(___x_cmd_mirror | head -n1)" in
    *gitee*)    ___X_CMD_IN_CHINA_NET=1 ;;
    *)          ___X_CMD_IN_CHINA_NET=
esac
# EndSection

# Section: main entrance

# shellcheck disable=SC1091
xrc(){
    [ $# -eq 0 ] && set -- "help"
    local subcmd="$1";  shift
    case "$subcmd" in
        ""|help)
            printf "xrc     x-bash core function.
    Uasge:  xrc <lib> [<lib>...]
    Please visit our homepage for more information: https://x-cmd.com
SUBCOMMAND:
    cat|c           Show the script in text form.
    which|w         Download lib files and print the local path.
    update|u        Update file.
    cache           Provide cache filepath.
    clear           Clear the cache.
    ls              Show the cache modules.
" >&2
            ;;
        c|cat)
            if [ $# -gt 0 ]; then
                ___x_cmd_xrc_cat "$@"
                return
            fi
            cat >&2 <<A
xrc cat         Show the script in text form
    Uasge:  xrc  cat <lib> [<lib>...]
    Example: eval "$(xrc cat str)"
A
            return 1;;
        w|which)
            if [ $# -gt 0 ]; then
                ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$@"
                printf "%s" "$___X_CMD_WHICH_ONE_RESULT"
                return
            fi
            cat >&2 <<A
xrc which       Download lib files and print the local path.
    Uasge:  xrc which <lib> [<lib>...]
    Example: source "$(xrc which str)"
A
            return 1 ;;
        root)
            printf "%s" "$___X_CMD_ROOT" ;;
        mirror)
            ___x_cmd_mirror "$@" ;;
        export-all)
            ( xrc x-bash/xrc/_v0/export &&  ___x_cmd_xrc_export_all "$@" ) ;;
        update)
            (
                local CACHE="$___X_CMD_ROOT/all.tgz"
                # rm -rf "$___X_CMD_ROOT" # Dangerous.
                if ___x_cmd_curl_gitx "../dist/all.tgz"; then
                    cd "$___X_CMD_ROOT" && tar xvf "$CACHE"
                    rm "$CACHE"
                    ___XRC_UDPATE=1
                    ___X_CMD_XRC_MODULE_IMPORTED=
                    ___x_cmd_source "$___X_CMD_ROOT"/xrc/latest
                fi
            )
            ;;
        upgrade)
            ___XRC_UDPATE=1
            ___X_CMD_XRC_MODULE_IMPORTED=
            rm -rf "$___X_CMD_ROOT/.boot/boot" && eval "$(curl https://get.x-cmd.com)"
            ;;
        log)
            printf "WARN: xrc log deprecated, you should using 'x log' instead\n" >&2
            x log "$@" ;;
        ls)
            ls "$___X_CMD_ROOT" ;;  # If tar.gz, using tar ls. If folder, ls $folder
        reload)
            if [ "$#" -gt 0 ]; then
                local ___X_CMD_XRC_RELOAD=1
                ___x_cmd_xrc_source_file "$@"
                return
            fi
            RELOAD=1 xrc xrc/latest; return ;;
        _x_cmd_advise_json)
            cat <<A
{
    "cat": {
        "#n": "ls $___X_CMD_ROOT | grep -v BASE64",
        "#desc": "Show the script in text form"
    },
    "which": {
        "#n": "ls $___X_CMD_ROOT | grep -v BASE64",
        "#desc": "Download lib files and print the local path"
    },
    "cache": "--- Provide cache filepath",
    "clear": "--- Clear the cache",
    "update": "--- Update file",
    "ls": "--- Show the cache modules",
    "upgrade": {},
    "reload": {},
    "root": {},
    "export-all": {},
    "mirror": {
        "#n": [
            "https://x-bash.gitee.io",
            "https://x-bash.github.io",
            "https://x-bash.gitlab.io",
            "https://bitbucket.com/x-bash/x-bash"
        ]
    }
}
A
            return 126
            ;;
        *)
            ___x_cmd_xrc_source_file "$subcmd" "$@"
            return
    esac
}
# EndSection

# Section: main entrance helper
___x_cmd_xrc_cat(){
    local file
    while [ $# -ne 0 ]; do
        local ___X_CMD_LOCAL_XRCPATH="$1";   shift

        if ! ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$___X_CMD_LOCAL_XRCPATH"; then
            printf "ERROR: Interrupted because resource not found. %s \n" "$___X_CMD_LOCAL_XRCPATH" >&2
            return 1
        fi

        cat "$___X_CMD_WHICH_ONE_RESULT"
    done
}

___X_CMD_XRC_MODULE_IMPORTED=""
___x_cmd_xrc_source_file(){
    local ___X_CMD_WHICH_ONE_RESULT
    local ___X_CMD_LOCAL_XRCPATH

    while [ $# -ne 0 ]; do
        ___X_CMD_LOCAL_XRCPATH="$1";   shift

        if ! ___X_CMD_NO_LOCAL=1 ___x_cmd_which_one "$___X_CMD_LOCAL_XRCPATH"; then
            printf "ERROR: Interrupted because resource not found. %s \n" "$___X_CMD_LOCAL_XRCPATH" >&2
            printf "%s\n" "return 1"
            return 1
        fi

        # Ask whether using http or outside resource.
        if [ -n "$___X_CMD_UNTRUSTED_RESOURCE" ] && [ -z "$NOWARN" ]; then

            # We should do it before ___x_cmd_which_one
            printf "Sourcing script from untrusted location: %s\n" "$___X_CMD_LOCAL_XRCPATH"
            cat >&2 <<A
SECURITY WARNING! Sourcing script from untrusted location: $___X_CMD_WHICH_ONE_RESULT
If you confirm this script is secure and want to skip this warning for some purpose, use the following code.
> NOWARN=1 xrc "$___X_CMD_LOCAL_XRCPATH"
A
            printf "Input yes to continue. Otherwise exit > " >&2
            local ___X_CMD_LOCAL_INPUT
            read -r ___X_CMD_LOCAL_INPUT

            if [ "$___X_CMD_LOCAL_INPUT" != "yes" ]; then
                rm "$___X_CMD_WHICH_ONE_RESULT"
                printf "%s\n" "Exit because of a non yes output received: $___X_CMD_LOCAL_INPUT" >&2
                printf "%s\n" "return 1"
                return 1
            fi
        fi

        if [ -z "$___X_CMD_XRC_RELOAD" ]; then
            if [ "${___X_CMD_XRC_MODULE_IMPORTED#*
"$___X_CMD_WHICH_ONE_RESULT"
*}" != "${___X_CMD_XRC_MODULE_IMPORTED}" ]; then
                [ $# -gt 0 ] && shift
                continue    # exited already. skip
            fi
        fi

        ___X_CMD_ENABLE_AUTO_RUN="" ___x_cmd_source "$___X_CMD_WHICH_ONE_RESULT"
        ___X_CMD_XRC_MODULE_IMPORTED="$___X_CMD_XRC_MODULE_IMPORTED
$___X_CMD_WHICH_ONE_RESULT"

    done
}

___x_cmd_curl_gitx(){   # Simple strategy
    local suburl="${1:?Provide location like str}"

    local IFS

    local mirror_list
    mirror_list="$(___x_cmd_mirror)"

    local mirror
    local lineno=1
    local urlpath
    while read -r mirror; do
        # shellcheck disable=SC2059
        urlpath="$(printf "$mirror" "$suburl")"
        ___x_cmd_curl "$urlpath"

        case $? in
            0)  if [ "$lineno" -ne 1 ]; then
                    ___xrc_log debug "Current default mirror is $mirror"
                    ___x_cmd_mirror "$mirror" "$(echo "$mirror_list" | awk "NR!=$lineno{ print \$0 }" )"

                    # Set CHINA_NET FLAG
                    case "$mirror" in
                        *gitee*)                    ___X_CMD_IN_CHINA_NET=1 ;;
                        *github*|*gitlab*)          ___X_CMD_IN_CHINA_NET=  ;;
                    esac
                fi
                return 0;;
            1)  ___xrc_log debug "Network unavailable."
                return 1;;
            4)  ___xrc_log debug "Resource Not Found."
                return 4;;
            *)
                ___xrc_log debug "Network unavailable Or Mirror is down: $urlpath"
                return 1;;
        esac
        lineno=$((lineno+1))
    done <<A
${mirror_list}
A
    return 1
}

___x_cmd_search_path(){
    local cur="${1:?Provide starting path}"

    cur="$(cd "$cur" 1>/dev/null 2>&1 && pwd)"

    local relative_filepath="${2:?Provide relative filepath}"
    while [ ! "$cur" = "" ]; do
        if [ -f "$cur/$relative_filepath" ]; then
            printf "%s" "$cur"
            return 0
        fi
        cur=${cur%/*}
    done
    return 1
}
# EndSection

# Section: which
# RETURN ___X_CMD_WHICH_ONE_RESULT
___x_cmd_which_one(){
    local RESOURCE_NAME=${1:?Provide resource name}

    ___X_CMD_WHICH_ONE_RESULT=

    local TGT
    ___X_CMD_UNTRUSTED_RESOURCE=
    case "$RESOURCE_NAME" in
        /*)
            ___xrc_log debug "Resource recognized as local file: $RESOURCE_NAME"
            ___X_CMD_WHICH_ONE_RESULT="$RESOURCE_NAME"
            return 0
            ;;
        http://*|https://*)
            ___X_CMD_UNTRUSTED_RESOURCE=http
            ___xrc_log debug "Resource recognized as http resource: $RESOURCE_NAME"

            TGT="$___X_CMD_ROOT/.http_resource/BASE64-URL-$(printf "%s" "$RESOURCE_NAME" | base64 | tr -d '\r\n')"
            if ! CACHE="$TGT" ___x_cmd_curl "$RESOURCE_NAME"; then
                ___xrc_log debug "ERROR: Fail to load http resource due to network error or other: $RESOURCE_NAME "
                return 1
            else
                ___X_CMD_WHICH_ONE_RESULT="$TGT"
            fi
            ;;
        *@*/*)
            xrc hub/v0
            ___xcmd_hub_file_which "$RESOURCE_NAME"     # Will set ___X_CMD_UNTRUSTED_RESOURCE=1 if from unknow source
            ;;
        ./*|../*)
            ___xrc_log debug "Resource recognized as local file with relative path: $RESOURCE_NAME"
            local tmp
            if tmp="$(cd "$(dirname "$RESOURCE_NAME")" || exit 1; pwd)"; then
                ___X_CMD_UNTRUSTED_RESOURCE="$tmp/$(basename "$RESOURCE_NAME")"
                return 0
            else
                ___xrc_log warn "Local file not exists: $RESOURCE_NAME"
                return 1
            fi
            ;;
        *)
            if [ -z "$___X_CMD_NO_LOCAL" ]; then
                # This is ONLY for x-cmd
                [ -f "$RESOURCE_NAME" ] && ___X_CMD_WHICH_ONE_RESULT="$RESOURCE_NAME" && return      # local file

                if TGT="$(___x_cmd_search_path . ".x-cmd/$RESOURCE_NAME")"; then
                    ___X_CMD_UNTRUSTED_RESOURCE=workspace
                    ___X_CMD_WHICH_ONE_RESULT="$TGT/.x-cmd/$RESOURCE_NAME"
                    return                   # .x-cmd
                fi
            fi

            # x-bash module
            ___xrc_log debug "Resource recognized as x-bash module: $RESOURCE_NAME"
            local module="$RESOURCE_NAME"
            if [ "${RESOURCE_NAME#*/}" = "$RESOURCE_NAME" ] ; then
                module="$module/latest"         # If it is short alias like str (short for str/latest)
                ___xrc_log debug "Version suffix unavailable. Using \"latest\" by default: $module"
            fi

            TGT="$___X_CMD_ROOT/$module"
            [ -f "$TGT" ] && ___X_CMD_WHICH_ONE_RESULT="$TGT" && return 0
            # ___xrc_log debug "Module not found: $module"
            # return 1

            ___xrc_log info "Downloading resource=$RESOURCE_NAME to local cache: $TGT"
            CACHE="$TGT" ___x_cmd_curl_gitx "$module" && ___X_CMD_WHICH_ONE_RESULT="$TGT" && return 0

            ___xrc_log warn "ERROR: Fail to load module due to network error or other: $RESOURCE_NAME"
            return 1
    esac
}
# EndSection

# Section: Instance management.

# ___x_cmd_instance_add class object
___x_cmd_instance_new(){
    local name="${2:?Provide object name}"
    name="${name#?}"
    eval "
function $name {
    $1 $2 \"\$@\"
}
"
}

___x_cmd_instance_del(){
    local name="${2:?Provide object name}"
    # TODO:
    if [ $# -gt 2 ];then
        eval "$@"
    fi
    name="${name#?}"
    if command -v "$name" 1>/dev/null 2>&2; then
        unset "$name"
    else
        printf "%s\n" "Instance not found: $O" >&2
        return 1
    fi
}

___x_cmd_instance_has(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "[ \"\$$name\" != \"\${$name#*@\${object}-*}\" ]"
}

___x_cmd_instance_add(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    if ! eval "[ \"\$$name\" != \"\${$name#*@\${object}-*}\" ]"; then
        eval "$name=\"\${$name}@\${object}-\""
    else
        printf "%s\n" "Object already enlisted." >&2
        return 1
    fi
}

# ___x_cmd_instance_rm class object
# shellcheck disable=SC2034
___x_cmd_instance_rm(){
    local class="${1:?Provide class name}"
    local object="${2:?Provide object name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "$name=\"\${$name%@\${object}-*}\${$name##*@\${object}-}\""
}

# ___x_cmd_instance_rm class
___x_cmd_instance_list(){
    local class="${1:?Provide class name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "[ -z \"\${$name}\" ]" && return
    eval printf \"%s\" "\"\${$name}\"" | tr "-" "\n" | tr -d @
}

___x_cmd_instance_clear(){
    local class="${1:?Provide class name}"
    local name="___X_CMD_INSTANCE_$class"
    eval "$name="
}

# EndSection

# Section: env

# TODO: using an environment to mark
___x_cmd_is_interative_tty(){
    [ "${-#*i}" != "$-" ]
}

___x_cmd_is_suitable_advise_env(){
    [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]
}

___x_cmd_awk(){
    xrc awk/latest && ___x_cmd_awk "$@"
}

___x_cmd_readlink_recursive(){
    if [ -L "${1:?Provide link}" ]; then
        local next_link
        next_link="$(readlink "${1}")" || return
        if [ "${next_link#/}" = "$next_link" ]; then
            next_link="$(dirname "${1}")/$next_link"
        fi
        ___x_cmd_readlink_recursive "$next_link"
    else
        [ ! -e "${1}" ] && return 1        # File Not Exists
        printf "%s" "$1"
    fi
}

if [ -n "$BASH_VERSION" ]; then
    ___X_CMD_SHELL=bash
elif [ -n "$ZSH_VERSION" ]; then
    ___X_CMD_SHELL=zsh
elif [ -n "$KSH_VERSION" ]; then
    ___X_CMD_SHELL=ksh
else
    ___X_CMD_SHELL="$(
        res="$(___x_cmd_readlink_recursive "$(command -v "$0")")"
        if [ "${res%dash}" != "$res" ]; then
            printf "%s" dash
        elif /bin/sh --help 2>&1 | grep BusyBox >/dev/null; then
            printf "%s" ash
        else
            printf "WARNING: %s\n" "Unknown shell." >&2
        fi
    )"
fi

# EndSection

# Section: other initialization: advise, initrc lazy loading
# [ -f "$(x initrc which)" ] && . "$(x initrc which)"
x(){    unset -f x; xrc reload x-cmd/v0 && x ${1:+"$@"};    }

alias xws="x ws"

if ___x_cmd_is_suitable_advise_env; then
    ___xrc_log debug "Using module advise for completion."
    xrc advise/v0 && advise init xrc && advise init x
    # load all advise json from advise dir
    advise load
fi
# EndSection

# else
#     printf "boot[ERR]: Cannot found curl or wget for web resource downloader." >&2
#     return 1 2>/dev/null
#     ( return 1 )                # Provide error code 1
#     # return 1 || exit 1
# fi
