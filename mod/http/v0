# shellcheck shell=sh # xrc
# shellcheck disable=SC2039,SC3043

# Desgin by Li Junhao and his friends in Zhongshan, Guangdong, China.
# Please visit https://github.com/x-bash/http for LICENSE.

xrc dict/latest
xrc param/latest
xrc str

http() {
    local O=${1#@}
    if [ "$O" != "$1" ]; then
        shift
    else
        O="_HTTP_DEFAULT"
    fi

    O="___X_BASH_HTTP_${O}"

    param:dsl      '
subcommands:
    new             "create a new client and set it to name"
    make            "make a new client"
    browse          "open browser"
    dict            "inner dict"
    cd              "enter into the subpath relative to current path"
    path            "set the path"
    qs              "set the default query string parameter"
    header          "set the default header"
    body            "set the default attribute in body"
    request|req     "launch a http request"
    head            "launch a head request"
    get             "launch a head request"
    post            "launch a post request"
    put             "launch a put request"
    patch           "launch a patch request"
    delete          "launch a delete request"
    graphql|gq      "launch a graphql request"
    resp|response   "get the response information of latest request"
'
    param:run
    if [ -z "$PARAM_SUBCMD" ]; then
        ___http_cli "$@"
        return
    fi
    "___http_${PARAM_SUBCMD}" "$@"
}

############################
# Section 1: Instantiation & Utilities
# Section 2: Dict & Path
# Section 3: Header
# Section 4: QueryString & Body
# Section 5: Request & Response
# Section 6: CRUD -- post get put delete
############################

############################
# Section 1: Instantiation & Utilities
############################
___http_new(){
    if alias "$O" 2>/dev/null; then
        http_log warn "alias $O already exists."
        return
    fi
    
    ___http_make "$@"
    # shellcheck disable=SC2139
    alias "$name=http @$name"
}

___http_del(){
    local result
    if result="$(alias "$O" 2>/dev/null)"; then
        result="${result#alias }"
        if [ "$result"  = "$O='dict @$O'" ]; then
            ___http_free "$@" && unalias "$O"
            return
        fi
    fi
    printf "%s" "No such dict instance: $O" >&2
}

___http_make() {
    dict @$O make
    [ -n "$1" ] && dict @$O put url "${1}"
}

http make # http :_HTTP_DEFAULT make

___http_free() {
    dict @$O free
}

x log init http

___http_browse() {
    local BROWSER=${BROWSER:-$BROWSER}
    local website=${1:?Provide websites}
    if [ -n "$BROWSER" ]; then
        $BROWSER "$website"
    elif uname -a | grep -q Darwin; then
        open -a "/Applications/Safari.app" "$website"
    elif command -v xdg-open >/dev/null; then
        xdg-open "$website"
    elif command -v gnome-open >/dev/null; then
        gnome-open "$website"
    else
        http_log debug "Could not detect the web browser to use."
        return 1
    fi
}

############################
# Section 2: Dict & Path
############################
___http_dict() {
    case $# in
        1) dict @$O get "${1:?Provide dict key}" ;;
        2) dict @$O put "${1:?Provide dict key}" "${2:?Provide dict value}" ;;
        *)
            echo "More than 2 variable provided" >&1
            return 2
            ;;
    esac
}

# TODO: how to cd back
___http_cd() {
    local target_url="${1:?Provide url}"

    if [ "${target_url#http://}" != "$target_url" ] || [ "${target_url#https://}" != "$target_url" ]; then
        dict @$O put url "$target_url"
    else
        local URL
        URL="$(dict @$O get url)"
        dict @$O put url "${URL%/}/${target_url#/}"
    fi
}

___http_path() {
    local url
    url="$(dict @$O get url)"
    if [ -z "$url" ]; then
        printf "%s" "$1"
    else
        printf "%s" "${url%/}/${1#/}"
    fi
}

############################
# Section 3: Header
############################

: <<'DOCTEST'
> ___http_make git https://api.git.com
> O=git ___http_qs token token123
> O=git ___http_header content-type application/json
> O=git ___http_header accept application/json
> O=git ___http_header
content-type: application/json
accept: application/json
DOCTEST
___http_header() {
    param:dsl      '
subcommands:
    dump                "dump header"
    get                 "get header"
    put                 "put header"
    mput                "mput header"
    remove              "remove header"
    type|content-type   "set the content-type"
    referer             "set the referer"
    agent|user-agent    "set the user-agent"
'
    param:run
    if [ -z "$PARAM_SUBCMD" ]; then
        ___http_header dump "$@"
        return
    fi
    "______http_header_${PARAM_SUBCMD}" "$@"
}

# shellcheck disable=SC2120
______http_header_dump(){
    case "${1:-""}" in
        json)
            dict @$O scope header | ___dict_pjson
            ;;
        curl)
            ______http_header_dump | while read -r line; do
                printf " -H \"%s\" " "$line"
            done
            ;;
        *) 
            dict @$O scope header | ITEM_SEP="\n" KV_SEP=": " ___dict_pprint ;;
        
    esac
}

______http_header_get(){
    dict @$O get header "${1:?header key}"
}

______http_header_put(){
    dict @$O put header "${1:?header key}" "${2:?value}"
}

______http_header_mput(){
    for i in "$@"; do
        # if [[ "$i" = *=* ]]; then
        if [ "$i" != "${i%%=*}" ]; then
            ______http_header_put "${i%=*}" "${i##*=}"
        else
            ______http_header_put "$i"
        fi
    done
}

______http_header_remove(){
    for i in "$@"; do
        dict @$O drop header "$i"
    done
}

______http_header_type(){
    # TODO: Using another individual mapping
    ______http_header_content_type "$@"
}

______http_header_referer(){
    ______http_header_put Referer "${1:?Referer}"
}

# # TODO: add more user-agent types, like mozilla, chrome, ie, etc.
______http_header_agent(){
    ______http_header_put User-Agent "${1:?User agent}"
}

# ___http_header(){
#     echo "$(___http_header_dump)
# $HEADER
# "
# }

# TODO: Introducing file with multiple candidates
if [ -n "$ZSH_VERSION" ]; then
    ___http_header_CONTENT_TYPE_LSIT=('application/json' 'application/text' 'application/xml'
     'application/yml' 'application/json;charset=utf-8')
    else
    ___http_header_CONTENT_TYPE_LSIT="
application/json
application/text
application/xml
application/yml
application/json;charset=utf-8
"
fi


# TODO: add more content-type
______http_header_content_type() {
    if [ $# -eq 0 ]; then
        if ___http_header_get "Content-Type"; then
            return 0
        else
            printf "Candiates are as below: \n%s" "$___http_header_CONTENT_TYPE_LSIT"
            return 1
        fi
    fi

    # TODO: Introducing file with multiple candidates
    local i
    local IFS="
"
    local target="${1:?Content-Type candidates like application/json}"

    for i in $___http_header_CONTENT_TYPE_LSIT; do
        if str_regex "$i" "$target"; then
            http_log debug "Add header: Content-Type=$i"
            ___http_header put "Content-Type" "$i"
            return 0
        fi
    done
    http_log debug "Add header: Content-Type=$target"
    ___http_header put "Content-Type" "$target"
}

# alias http.header.content-type.eq.json+utf8='______http_header_content_type_eq "application/json;charset=utf-8";'

############################
# Section 4: QueryString & Body
############################
# Notice: ___http_qs_put will put the empty value

: <<'DOCTEST'
> ___http_make git https://api.git.com
> O=git ___http_qs token token123
> O=git ___http_header put content-type application/json
> O=git ___http_header put accept application/json
> O=git ___http_qs dump json
{
  "token": "token123"
}
DOCTEST
___http_qs() {
    param:dsl      '
subcommands:
    dump                    "get all qs"
    get                     "get qs"
    put                     "put qs"
    remove                  "remove qs"
    mput                    "set more qs"
'
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___http_qs dump "$@"
        return
    fi

    "______http_qs_${PARAM_SUBCMD}" "$@"
}

______http_qs_dump(){
    case "$1" in
        json)
            dict @$O scope qs | ___dict_pjson
            ;;
        curl)
            local line
            printf "%s" " -G "
            dict @$O scope qs | KV_SEP="=" ___dict_pprint | while read -r line; do
                # printf "--data-urlencode \"%s\" " "$line"
                printf " %s " "--data-urlencode $line"
            done
            ;;
        *) dict @$O scope qs | KV_SEP="=" ___dict_pprint ;;
    esac
}

______http_qs_get(){
    dict @$O get qs "${1:?header key}"
}

______http_qs_put(){
    local header_key="${1:?header key}"
    if [ $# -eq 1 ]; then
        eval dict @$O put qs "\$header_key" "\$${header_key}"
    else
        dict @$O put qs "$header_key" "$2"
    fi
}

______http_qs_remove(){
    dict @$O drop qs "${1:?header key}"
}

______http_qs_mput(){
    # Notice 1: `___http_qs_put abc=``  will put the entry { abc: "" }
    # Notice 2: `abc=; ___http_qs_put abc` will NOT put any entry
    local value
    local i
    for i in "$@"; do
        # if [[ "$i" = *=* ]]; then
        if [ "$i" != "${i%%=*}" ]; then
            ______http_qs_put "${i%%=*}" "${i#*=}"
        else
            eval value="\"\$${i}\""
            [ -n "$value" ] && ______http_qs_put "$i" "$value"
        fi
    done
}

: <<'DOCTEST'
> ___http_make git https://api.git.com
> O=git ___http_body token token123
> O=git ___http_header put content-type application/json
> O=git ___http_header put accept application/json
> O=git ___http_body_dump_json
{
  "token": "token123"
}
DOCTEST

___http_body() {
    param:dsl      '
subcommands:
    dump                "dump the body. "dump json" will dump the body in json form"
    get                 "get the value by key in body"
    put                 "put the kv pair in body"
    remove              "remove the kv pair in body by key"
    mput                "put multiple kv pair in body"
'
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___http_resp body "$@"
        return
    fi

    "______http_body_${PARAM_SUBCMD}" "$@"
}

______http_body_dump(){
    local O="${O:?Provide Object name}"
    case "$1" in
        json)       dict @$O scope body | ___dict_pjson        ;;
        *)          dict @$O scope body ;;
    esac
}

______http_body_get(){
    dict "@$O" get body "${1:?body key}"
}

______http_body_put(){
    local body_key="${1:?body key}"
    if [ $# -eq 1 ]; then
        eval dict "@$O" put body "\$body_key" "\$${body_key}"
    else
        dict "@$O" put body "$body_key" "$2"
    fi
}
______http_body_remove(){
    dict "@$O" drop body "${1:?body key}"
}

______http_body_mput(){
    # Notice 1: `___http_qs_put abc=""`  will put the entry { abc: "" }
    # Notice 2: `abc=; ___http_qs_put abc` will NOT put any entry
    local value
    local i
    for i in "$@"; do
        # if [[ "$i" = *=* ]]; then
        if [ "$i" != "${i%%=*}" ]; then
            ______http_body_put "${i%=*}" "${i##*=}"
        else
            eval value="\"\$${i}\""
            [ -n "$value" ] && ______http_body_put "$i" "$value"
        fi
    done
}

############################
# Section 5: Request & Response
############################
___http_resp() {
    param:dsl      '
subcommands:
    header|h            "Show header of latest response"
    body|b              "Show body of latest response"
    header_filepath     "show header filepath of latest response"
    body_filepath       "show body filepath of latest response"
'
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___http_resp body "$@"
        return
    fi

    "______http_resp_${PARAM_SUBCMD}" "$@"
}

______http_resp_header(){
    if [ -z "$1" ]; then
        cat "$(______http_resp_header_filepath)"
    else
        local filepath
        filepath="$(______http_resp_header_filepath)"
        local filter=${1:?provide filter} A
        A="$(grep "$filter:" "$filepath")"
        A="${A##$filter: }"
        printf "%s" "${A%"${A##*[![:space:]]}"}"
    fi
}

______http_resp_header_filepath(){
    printf "%s" "${TMPDIR%/}/x-cmd-x-bash-std-http-header.$O"
}

______http_resp_body(){
    cat "$(______http_resp_body_filepath)"
}

______http_resp_body_filepath(){
    printf "%s" "${TMPDIR%/}/x-cmd-x-bash-std-http-body.$O"
}

# #1: path; #2 data
___http_request() {
    local IFS=" "
    local X=${X:-get}
    local data=${2:-"$D"}

    local paths
    paths="$(___http_path "$1")"
    if [ -z "$data" ]; then
        data="$(___http_body dump json "")"
    fi
    local tmp
    tmp=$(mktemp)
    echo "$data" >"$tmp"
    # TODO: Display the data if only if body is text and data is NOT a lot
    # http_log debug "body is: $data"
    # [ -n "$DEBUG" ] && echo "body is: $data" >&2

    local header_filepath data_filepath
    header_filepath="$(___http_resp header_filepath)"
    data_filepath="$(___http_resp body_filepath)"

    if [ "$X" = GET ] || [ "$X" = DELETE ] || [ "$X" = HEAD ]; then
        http_log debug curl -D "$header_filepath" -X "$X" "$(______http_qs_dump curl)" "$(______http_header_dump curl)" "$paths"
        eval curl -D "$header_filepath" -X "$X" "$(______http_qs_dump curl)" "$(______http_header_dump curl)" "$paths" 1>"$data_filepath" 2>/dev/null #2>(http_log debug)
    else
        http_log debug curl -D "$header_filepath" -X "$X" "$(______http_header_dump curl)" -d "@$tmp" "$paths"
        eval curl -D "$header_filepath" -X "$X" "$(______http_header_dump curl)" -d "@$tmp" "$paths" 1>"$data_filepath" 2>/dev/null #2>(http_log debug)
    fi
    rm "$tmp"

    http_log debug "Response Header is: $(cat "$header_filepath")"

    local a b c
    # shellcheck disable=SC2034
    read -r a b c <<A
    "$(cat "$header_filepath")"
A
    if [ -n "$b" ] && [ "$b" -ge 200 ] && [ "$b" -le 299 ]; then
        cat "$data_filepath"
        return 0
    fi

    printf "HttpCode is %s, Code is 1\n" "$b" >&2
    return 1
}

____http_request_json_body() (# Notice: Using subshell
    url=$1
    shift
    ___http_body mput "$@"
    ___http_request "$url" "$(___http_body dump json "")"
)

############################
# Section 6: CRUD -- post get put delete
############################

# crud
___http_get() (# Notice: Using subshell
    url=$1
    shift
    ___http_qs mput "$@"
    X=GET ___http_request "$url"
)

___http_post() {
    local op="$1"; shift;
    case "$op" in
        json)   ___http_header put Content-Type application/json
                X=POST ____http_request_json_body "$@"
                ;;
         # TODO: add more data form.
        form)   : ;;
        text)   : ;;
        bin)    : ;;
        *)      X=POST ___http_request "$op" "$@" ;;
    esac
}

___http_put() {
    local op="$1"; shift;
    case "$op" in
        json)   ___http_header put Content-Type application/json
                X=PUT ____http_request_json_body "$@" ;;
        # TODO: add more data form.
        form)   ;;
        text)   ;;
        bin)    ;;
        *)      X=PUT ___http_request "$@" ;;
    esac
}
___http_patch() {
    local op="$1"; shift;
    case "$op" in
        json)   ___http_header put Content-Type application/json
                X=PATCH ____http_request_json_body "$@" 
                ;;
        # TODO: add more data form.
        form)   ;;
        text)   ;;
        bin)    ;;
        *)      X=PATCH ___http_request "$@" ;;
    esac
}

___http_delete() { X=DELETE ___http_request "$@"; }
___http_head() { X=HEAD ___http_request "$@"; }

############################
# Section 7: GraphQL -- graphql
############################s

___http_graphql() {
    local op="$1"; shift
    case "$op" in
        q|query)
            local url=$1; shift
            ___http_graphql execute "$1" "query { $2 }"
            ;;
        qj|query-json)
            local url=$1; shift
            ___http_graphql execute-json "$1" "{ \"query\": \"{ $2 }\""
            ;;
        e|execute)
            if [ -z $url ]; then
                local url=$1; shift
            fi
            http header put content-type application/graphql
            ___http_post $url "$1"
            ;;
        ej|execute-json)
            if [ -z $url ]; then
                local url=$1; shift
            fi
            http header put content-type application/json
            ___http_post $url "$1"
            ;;
        *)
            ___http_graphql execute "$op" "$@"
            ;;
    esac
}

___http_cli(){
    xrc ps1env/latest
    ps1env init "http >"
    ps1env alias + "http"
    ps1env alias :h "http help"
    local IFS
    local subcmd
    while read -r subcmd; do
        ps1env alias "+$subcmd" "http $subcmd"
    done <<A
$(http _param_list_subcmd)
A

}

if [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]; then
    xrc advise/latest
    advise http
fi

# TODO: Honor set-cookie
# TODO: http service, using python Simple HTTPSERVER or other implementation
# TODO: ?
