# Author:       Li Junhao   l@x-cmd.com     # xrc
# shellcheck    shell=sh    disable=SC2039,SC3043

# Section: main
xrc dict
xrc param
___x_cmd_http() {
    local O="${O:-_HTTP_DEFAULT}"
    if [ "${1#@}" != "$1" ]; then
        O="${1#@}"
        shift
    fi
    O="___X_BASH_HTTP_${O}"

    param:dsl      '
subcommands:
    new             "create a new client and set it to name"
    make            "make a new client"
    browse          "open browser"
    dict            "inner dict"
    cd              "enter into the subpath relative to current path"
    path            "set the path"
    qs              "set the default query string parameter"
    header          "set the default header"
    body            "set the default attribute in body"
    request|req     "launch a http request"
    head            "launch a head request"
    get             "launch a head request"
    post            "launch a post request"
    put             "launch a put request"
    patch           "launch a patch request"
    delete          "launch a delete request"
    graphql|gq      "launch a graphql request"
    resp|response   "get the response information of latest request"
'
    param:run
    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_http_cli "$@"
        return
    fi
    "___x_cmd_http_${PARAM_SUBCMD}" "$@"
}

___x_cmd_http_cli(){
    xrc ps1env
    ps1env init "http"
    ps1env alias + "http"
    ps1env alias :h "http help"
    local IFS
    local subcmd
    while read -r subcmd; do
        ps1env alias "+$subcmd" "http $subcmd"
    done <<A
$(http _param_list_subcmd)
A

}

# EndSection

x log init http

# Section 1: Instantiation & Utilities
___x_cmd_http_new(){
    if alias "$O" 2>/dev/null; then
        http_log warn "alias $O already exists."
        return
    fi

    ___x_cmd_http_make "$@"
    # shellcheck disable=SC2139
    alias "$name=O=$name http"
}

___x_cmd_http_del(){
    local result
    if result="$(alias "$O" 2>/dev/null)"; then
        result="${result#alias }"
        if [ "$result"  = "$O='O=$O dict'" ]; then
            ___x_cmd_http_free "$@" && unalias "$O"
            return
        fi
    fi
    printf "%s" "No such dict instance: $O" >&2
}

___x_cmd_http_make() {
    O=$O dict  make
    [ -n "$1" ] && O=$O dict put url "${1}"
}


___x_cmd_http_free() {
    O=$O dict free
}


___x_cmd_http_browse() {
    local BROWSER=${BROWSER:-$BROWSER}
    local website=${1:?Provide websites}
    if [ -n "$BROWSER" ]; then
        $BROWSER "$website"
    elif uname -a | grep -q Darwin; then
        open -a "/Applications/Safari.app" "$website"
    elif command -v xdg-open >/dev/null; then
        xdg-open "$website"
    elif command -v gnome-open >/dev/null; then
        gnome-open "$website"
    else
        http_log debug "Could not detect the web browser to use."
        return 1
    fi
}

# EndSection

# Section 2: Dict & Path
___x_cmd_http_dict() {
    case $# in
        1) O=$O dict get "${1:?Provide dict key}" ;;
        2) O=$O dict put "${1:?Provide dict key}" "${2:?Provide dict value}" ;;
        *)
            echo "More than 2 variable provided" >&1
            return 2
            ;;
    esac
}

# TODO: how to cd back
___x_cmd_http_cd() {
    local target_url="${1:?Provide url}"

    if [ "${target_url#http://}" != "$target_url" ] || [ "${target_url#https://}" != "$target_url" ]; then
        O=$O dict put url "$target_url"
    else
        local URL
        URL="$(O=$O dict get url)"
        O=$O dict put url "${URL%/}/${target_url#/}"
    fi
}

___x_cmd_http_path() {
    local url
    url="$(O=$O dict get url)"
    if [ -z "$url" ]; then
        printf "%s" "$1"
    else
        printf "%s" "${url%/}/${1#/}"
    fi
}

# EndSection

# Section 3: Header

: <<'DOCTEST'
> ___x_cmd_http_make git https://api.git.com
> O=git ___x_cmd_http_qs token token123
> O=git ___x_cmd_http_header content-type application/json
> O=git ___x_cmd_http_header accept application/json
> O=git ___x_cmd_http_header
content-type: application/json
accept: application/json
DOCTEST
___x_cmd_http_header() {
    param:dsl      '
subcommands:
    dump                "dump header"
    get                 "get header"
    put                 "put header"
    mput                "mput header"
    remove              "remove header"
    type|content-type   "set the content-type"
    referer             "set the referer"
    agent|user-agent    "set the user-agent"
'
    param:run
    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_http_header dump "$@"
        return
    fi
    "______x_cmd_http_header_${PARAM_SUBCMD}" "$@"
}

# shellcheck disable=SC2120
______x_cmd_http_header_dump(){
    case "${1:-""}" in
        json)
            O=$O dict scope header | ___dict_pjson
            ;;
        curl)
            ______x_cmd_http_header_dump | while read -r line; do
                printf " -H \"%s\" " "$line"
            done
            ;;
        *)
            O=$O dict scope header | ITEM_SEP="\n" KV_SEP=": " ___dict_pprint ;;

    esac
}

______x_cmd_http_header_get(){
    O=$O dict get header "${1:?header key}"
}

______x_cmd_http_header_put(){
    O=$O dict put header "${1:?header key}" "${2:?value}"
}

______x_cmd_http_header_mput(){
    for i in "$@"; do
        # if [[ "$i" = *=* ]]; then
        if [ "$i" != "${i%%=*}" ]; then
            ______x_cmd_http_header_put "${i%=*}" "${i##*=}"
        else
            ______x_cmd_http_header_put "$i"
        fi
    done
}

______x_cmd_http_header_remove(){
    for i in "$@"; do
        O=$O dict drop header "$i"
    done
}

______x_cmd_http_header_type(){
    # TODO: Using another individual mapping
    ______x_cmd_http_header_content_type "$@"
}

______x_cmd_http_header_referer(){
    ______x_cmd_http_header_put Referer "${1:?Referer}"
}

# # TODO: add more user-agent types, like mozilla, chrome, ie, etc.
______x_cmd_http_header_agent(){
    ______x_cmd_http_header_put User-Agent "${1:?User agent}"
}

# ___x_cmd_http_header(){
#     echo "$(___x_cmd_http_header_dump)
# $HEADER
# "
# }

# TODO: Introducing file with multiple candidates
if [ -n "$ZSH_VERSION" ]; then
    ___x_cmd_http_header_CONTENT_TYPE_LSIT=('application/json' 'application/text' 'application/xml'
     'application/yml' 'application/json;charset=utf-8')
    else
    ___x_cmd_http_header_CONTENT_TYPE_LSIT="
application/json
application/text
application/xml
application/yml
application/json;charset=utf-8
"
fi


# TODO: add more content-type
______x_cmd_http_header_content_type() {
    if [ $# -eq 0 ]; then
        if ___x_cmd_http_header_get "Content-Type"; then
            return 0
        else
            printf "Candiates are as below: \n%s" "$___x_cmd_http_header_CONTENT_TYPE_LSIT"
            return 1
        fi
    fi

    # TODO: Introducing file with multiple candidates
    local i
    local IFS="
"
    local target="${1:?Content-Type candidates like application/json}"

    for i in $___x_cmd_http_header_CONTENT_TYPE_LSIT; do
        if str_regex "$i" "$target"; then
            http_log debug "Add header: Content-Type=$i"
            ___x_cmd_http_header put "Content-Type" "$i"
            return 0
        fi
    done
    http_log debug "Add header: Content-Type=$target"
    ___x_cmd_http_header put "Content-Type" "$target"
}

# alias http.header.content-type.eq.json+utf8='______x_cmd_http_header_content_type_eq "application/json;charset=utf-8";'

# EndSection

# Section 4: QueryString & Body
# Notice: ___x_cmd_http_qs_put will put the empty value

: <<'DOCTEST'
> ___x_cmd_http_make git https://api.git.com
> O=git ___x_cmd_http_qs token token123
> O=git ___x_cmd_http_header put content-type application/json
> O=git ___x_cmd_http_header put accept application/json
> O=git ___x_cmd_http_qs dump json
{
  "token": "token123"
}
DOCTEST
___x_cmd_http_qs() {
    param:dsl      '
subcommands:
    dump                    "get all qs"
    get                     "get qs"
    put                     "put qs"
    remove                  "remove qs"
    mput                    "set more qs"
'
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_http_qs dump "$@"
        return
    fi

    "______x_cmd_http_qs_${PARAM_SUBCMD}" "$@"
}

______x_cmd_http_qs_dump(){
    case "$1" in
        json)
            O=$O dict scope qs | ___dict_pjson
            ;;
        curl)
            local line
            printf "%s" " -G "
            O=$O dict scope qs | KV_SEP="=" ___dict_pprint | while read -r line; do
                # printf "--data-urlencode \"%s\" " "$line"
                printf " %s " "--data-urlencode $line"
            done
            ;;
        *) O=$O dict scope qs | KV_SEP="=" ___dict_pprint ;;
    esac
}

______x_cmd_http_qs_get(){
    O=$O dict get qs "${1:?header key}"
}

______x_cmd_http_qs_put(){
    local header_key="${1:?header key}"
    if [ $# -eq 1 ]; then
        eval O=$O dict put qs "\$header_key" "\$${header_key}"
    else
        O=$O dict put qs "$header_key" "$2"
    fi
}

______x_cmd_http_qs_remove(){
    O=$O dict drop qs "${1:?header key}"
}

______x_cmd_http_qs_mput(){
    # Notice 1: `___x_cmd_http_qs_put abc=``  will put the entry { abc: "" }
    # Notice 2: `abc=; ___x_cmd_http_qs_put abc` will NOT put any entry
    local value
    local i
    for i in "$@"; do
        # if [[ "$i" = *=* ]]; then
        if [ "$i" != "${i%%=*}" ]; then
            ______x_cmd_http_qs_put "${i%%=*}" "${i#*=}"
        else
            eval value="\"\$${i}\""
            [ -n "$value" ] && ______x_cmd_http_qs_put "$i" "$value"
        fi
    done
}

: <<'DOCTEST'
> ___x_cmd_http_make git https://api.git.com
> O=git ___x_cmd_http_body token token123
> O=git ___x_cmd_http_header put content-type application/json
> O=git ___x_cmd_http_header put accept application/json
> O=git ___x_cmd_http_body_dump_json
{
  "token": "token123"
}
DOCTEST

___x_cmd_http_body() {
    param:dsl      '
subcommands:
    dump                "dump the body. "dump json" will dump the body in json form"
    get                 "get the value by key in body"
    put                 "put the kv pair in body"
    remove              "remove the kv pair in body by key"
    mput                "put multiple kv pair in body"
'
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_http_resp body "$@"
        return
    fi

    "______x_cmd_http_body_${PARAM_SUBCMD}" "$@"
}

______x_cmd_http_body_dump(){
    local O="${O:?Provide Object name}"
    case "$1" in
        json)       O=$O dict scope body | ___dict_pjson        ;;
        *)          O=$O dict scope body ;;
    esac
}

______x_cmd_http_body_get(){
    dict "@$O" get body "${1:?body key}"
}

______x_cmd_http_body_put(){
    local body_key="${1:?body key}"
    if [ $# -eq 1 ]; then
        eval dict "@$O" put body "\$body_key" "\$${body_key}"
    else
        dict "@$O" put body "$body_key" "$2"
    fi
}
______x_cmd_http_body_remove(){
    dict "@$O" drop body "${1:?body key}"
}

______x_cmd_http_body_mput(){
    # Notice 1: `___x_cmd_http_qs_put abc=""`  will put the entry { abc: "" }
    # Notice 2: `abc=; ___x_cmd_http_qs_put abc` will NOT put any entry
    local value
    local i
    for i in "$@"; do
        # if [[ "$i" = *=* ]]; then
        if [ "$i" != "${i%%=*}" ]; then
            ______x_cmd_http_body_put "${i%=*}" "${i##*=}"
        else
            eval value="\"\$${i}\""
            [ -n "$value" ] && ______x_cmd_http_body_put "$i" "$value"
        fi
    done
}

# EndSection

# Section 5: Request & Response
___x_cmd_http_resp() {
    param:dsl      '
subcommands:
    header              "Show header of latest response"
    body                "Show body of latest response"
    header_filepath     "show header filepath of latest response"
    body_filepath       "show body filepath of latest response"
'
    param:run

    if [ -z "$PARAM_SUBCMD" ]; then
        ___x_cmd_http_resp body "$@"
        return
    fi

    "______x_cmd_http_resp_${PARAM_SUBCMD}" "$@"
}

______x_cmd_http_resp_header(){
    if [ -z "$1" ]; then
        cat "$(______x_cmd_http_resp_header_filepath)"
    else
        local filepath
        filepath="$(______x_cmd_http_resp_header_filepath)"
        local filter=${1:?provide filter} A
        A="$(grep "$filter:" "$filepath")"
        A="${A##$filter: }"
        printf "%s" "${A%"${A##*[![:space:]]}"}"
    fi
}

______x_cmd_http_resp_header_filepath(){
    printf "%s" "${TMPDIR%/}/x-cmd-x-bash-std-http-header.$O"
}

______x_cmd_http_resp_body(){
    cat "$(______x_cmd_http_resp_body_filepath)"
}

______x_cmd_http_resp_body_filepath(){
    printf "%s" "${TMPDIR%/}/x-cmd-x-bash-std-http-body.$O"
}

# #1: path; #2 data

# TODO: next time review
___x_cmd_http_request() {
    local IFS=" "
    local X=${X:-get}
    local data=${2:-"$D"}

    local paths
    paths="$(___x_cmd_http_path "$1")"
    if [ -z "$data" ]; then
        data="$(___x_cmd_http_body dump json "")"
    fi
    local tmp
    tmp=$(mktemp)
    if [ "$data" = "-" ];then
        tmp="$data"
    else
        printf "%s" "$data" >"$tmp"
    fi
    # TODO: Display the data if only if body is text and data is NOT a lot
    # http_log debug "body is: $data"
    # [ -n "$DEBUG" ] && echo "body is: $data" >&2

    local header_filepath data_filepath
    header_filepath="$(___x_cmd_http_resp header_filepath)"
    data_filepath="$(___x_cmd_http_resp body_filepath)"

    if [ "$X" = GET ] || [ "$X" = DELETE ] || [ "$X" = HEAD ]; then
        http_log debug curl -D "$header_filepath" -X "$X" "$(______x_cmd_http_qs_dump curl)" "$(______x_cmd_http_header_dump curl)" "$paths"
        eval curl -D "$header_filepath" -X "$X" "$(______x_cmd_http_qs_dump curl)" "$(______x_cmd_http_header_dump curl)" "$paths" 1>"$data_filepath" 2>/dev/null #2>(http_log debug)
    else
        http_log debug curl -D "$header_filepath" -X "$X" "$(______x_cmd_http_header_dump curl)" -d "@$tmp" "$paths"
        eval curl -D "$header_filepath" -X "$X" "$(______x_cmd_http_header_dump curl)" -d "@$tmp" "$paths" 1>"$data_filepath" 2>/dev/null #2>(http_log debug)
    fi
    rm "$tmp"

    http_log debug "Response Header is: $(cat "$header_filepath")"

    local a b c
    # shellcheck disable=SC2034
    read -r a b c <<A
    "$(cat "$header_filepath")"
A
    if [ -n "$b" ] && [ "$b" -ge 200 ] && [ "$b" -le 299 ]; then
        cat "$data_filepath"
        return 0
    fi

    printf "HttpCode is %s, Code is 1\n" "$b" >&2
    return 1
}

____x_cmd_http_request_json_body() (    # Notice: Using subshell
    url=$1
    shift
    ___x_cmd_http_body mput "$@"
    ___x_cmd_http_request "$url" "$(___x_cmd_http_body dump json "")"
)

# EndSection

# Section 6: CRUD -- post get put delete
# crud
___x_cmd_http_get() (   # Notice: Using subshell
    url=$1
    shift
    ___x_cmd_http_qs mput "$@"
    X=GET ___x_cmd_http_request "$url"
)

___x_cmd_http_post() {
    local content_op="$1"; shift;
    case "$content_op" in
        json)   ___x_cmd_http_header put Content-Type application/json
                X=POST ____x_cmd_http_request_json_body "$@"
                ;;
         # TODO: add more data form.
        form)   : ;;
        text)   : ;;
        bin)    : ;;
        *)      X=POST ___x_cmd_http_request "$content_op" "$@" ;;
    esac
}

___x_cmd_http_put() {
    local content_op="$1"; shift;
    case "$content_op" in
        json)   ___x_cmd_http_header put Content-Type application/json
                X=PUT ____x_cmd_http_request_json_body "$@" ;;
        # TODO: add more data form.
        form)   ;;
        text)   ;;
        bin)    ;;
        *)      X=PUT ___x_cmd_http_request "$content_op" "$@" ;;
    esac
}
___x_cmd_http_patch() {
    local content_op="$1"; shift;
    case "$content_op" in
        json)   ___x_cmd_http_header put Content-Type application/json
                X=PATCH ____x_cmd_http_request_json_body "$@"
                ;;
        # TODO: add more data form.
        form)   ;;
        text)   ;;
        bin)    ;;
        *)      X=PATCH ___x_cmd_http_request "$@" ;;
    esac
}

___x_cmd_http_delete() { X=DELETE ___x_cmd_http_request "$@"; }
___x_cmd_http_head() { X=HEAD ___x_cmd_http_request "$@"; }

# EndSection

# Section 7: GraphQL -- graphql
___x_cmd_http_graphql() {
    local op="$1"; shift
    case "$op" in
        query)
            local url=${1:?Provide URL}
            local body="query { ${2:?Provide GRAPHQL} }"
            shift 2
            ___x_cmd_http_graphql execute "$url" "$body" "$@"
            ;;
        query-json)
            local url=${1:?Provide URL}
            local body
            body="{ \"query\": $(jo quote "{ ${2:?Provide GRAPHQL} }")"
            shift 2
            ___x_cmd_http_graphql execute-json "$url" "$body" "$@"
            ;;
        execute)
            http header put content-type application/graphql
            ___x_cmd_http_post "$@"   # TODO:
            ;;
        execute-json)
            http header put content-type application/json
            ___x_cmd_http_post "$@"   # TODO:
            ;;
        *)
            ___x_cmd_http_graphql execute "$op" "$@"
            ;;
    esac
}
# EndSection

# TODO: Honor set-cookie
# TODO: http service, using python Simple HTTPSERVER or other implementation
# TODO: ?

xrc setmain ___x_cmd_http
