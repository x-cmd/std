# shellcheck shell=sh disable=SC3043 # xrc
# author:       Li Junhao           l@x-cmd.com

___x_cmd_log() {
    case "$1" in
        :*)                                     ___x_cmd_log_pr "$@" ;;
        "")                                     ___x_cmd_log_help; return 1 ;;
        help|-H|-h|--help)          shift;      ___x_cmd_log_help; return 1 ;;

        init)                       shift;      ___x_cmd_log_init "$@" ;;
        init1)                      shift;      ___x_cmd_log_init1 "$@" ;;

        init0)                      shift;      ___x_cmd_log_init0 "$@" ;;
        init01)                     shift;      ___x_cmd_log_init01 "$@" ;;
        init02)                     shift;      ___x_cmd_log_init02 "$@" ;;

        redirect)                   shift;      ___x_cmd_log_redirect "$@" ;;

        timestamp)                  shift;      ___x_cmd_log_timestamp "$@" ;;
        view)                       shift;      ___x_cmd_log_view "$@" ;;
        *)
            while [ "$#" -gt 0 ]; do
                case "$1" in
                    */*)                        ___x_cmd_log_set_level "${1%/*}" "${1#*/}" ;;
                    +*)                         ___x_cmd_log_set_level "${1#+}" debug ;;
                    -*)                         ___x_cmd_log_set_level "${1#-}" info ;;
                    *)                          ___x_cmd_log_set_level "$1" info
                esac
                shift
            done
    esac
}

# Section: init regular log

# Application Module

___x_cmd_log_init1(){
    ___x_cmd_log_init_inner "$@" 1
}

___x_cmd_log_init(){
    ___x_cmd_log_init_inner "$@" 1 2 3 4
}

___x_cmd_log_init_inner(){
    local logger_name="${1:?Provide logger name}"
    shift

    local var="___X_CMD_LOG__$logger_name"

    eval "$var=\${$var:-2}"
    eval "___X_CMD_LOG__0_$logger_name="

    # deprecated
    eval "${logger_name}_log(){     ___x_cmd_log_pr $logger_name \"\$@\";   }"

    local level_name
    for level_code in 1 2 3 4; do
        level_name="$(___x_cmd_log_level_code2name "$level_code")"
        eval "alias ${logger_name}:$level_name='test $level_code -lt \"\${___X_CMD_LOG__${logger_name}:-2}\" || O=${logger_name} ___x_cmd_log_pr_${level_name}'"
    done
}

# EndSection


# Section: redirect view

___x_cmd_log_redirect(){
    local folder="$___X_CMD_ROOT_TMP/log/$$"
    mkdir -p "$folder"
    "$@" 2>"$folder/$(date +%s)"
}

___x_cmd_log_view(){
    awk -f "$___X_CMD_ROOT_MOD/log/lib/view.awk"
}

# EndSection

# Section: zero cost log

# DEBUG + INFO + WARN + ERROR: For those module
___x_cmd_log_init0(){
    ___x_cmd_log_init0_inner "$@" 1 2 3 4
}

# High Efficiency Module. Like str, list, dict: DEBUG
___x_cmd_log_init01(){
    ___x_cmd_log_init0_inner "$@" 1
}

# DEBUG + INFO
___x_cmd_log_init02(){
    ___x_cmd_log_init0_inner "$@" 1 2
}

___x_cmd_log_init0_inner(){
    local logger_name="${1:?Provide logger name}"
    shift
    local var="___X_CMD_LOG__$logger_name"

    eval "$var=\${$var:-2}"
    eval "___X_CMD_LOG__0_$logger_name=1"

    local level_target_code
    eval level_target_code="\${$var}"

    local level_code
    local level_name
    for level_code in "$@"; do
        level_name="$(___x_cmd_log_level_code2name "$level_code")"
        if [ "$level_code" -lt "$level_target_code" ]; then
            alias "${logger_name}:${level_name}"=" : # "
        else
            alias "${logger_name}:${level_name}"="O=${logger_name} ___x_cmd_log_pr_${level_name}"
        fi
    done

    eval "$var=$level_code"
}

# EndSection

# Section: level

___x_cmd_log_level_name(){
    case "${1:?Provide name}" in
        debug|info|warn|error)      printf "%s" "$1" ;;
        *)                          printf "%s" info ;;
    esac
}

___x_cmd_log_level_name2code(){
    case "${1:?Provide name}" in
        debug)      printf "%s" 1 ;;
        info)       printf "%s" 2 ;;
        warn)       printf "%s" 3 ;;
        error)      printf "%s" 4 ;;
        *)          printf "%s" 2 ;;
    esac
}

___x_cmd_log_level_code2name(){
    case "${1:?Provide code}" in
        1)      printf "%s" debug ;;
        2)      printf "%s" info ;;
        3)      printf "%s" warn ;;
        4)      printf "%s" error ;;
        *)      printf "%s" info ;;
    esac
}

___x_cmd_log_set_level(){
    local logger_name="${1:?Provide loggername}"

    local level="${2:?Provide level}"
    local level_code="${3}"

    level="$(___x_cmd_log_level_name "$level")"

    if [ -z "$level_code" ]; then
        level_code="$(___x_cmd_log_level_name2code "$level")"
    fi

    local var="___X_CMD_LOG__${logger_name}"

    if eval test -z "\$___X_CMD_LOG__0_$logger_name"; then
        eval "$var=$level_code"
    else
        eval "$var=$level_code"
        if [ -d "$___X_CMD_ROOT/$logger_name" ]; then
            ___x_cmd_log_pr "${O:-$logger_name}" warn "Reload the logger by reload the module"
            xrc:inner "$logger_name/latest"
        fi
    fi

    # eval "$O:debug  \"Level of logger [\$logger_name] is set to [\$level]\""
    ___x_cmd_log_pr log debug "Level of logger [$logger_name] is set to [$level]"
}

___x_cmd_log_show_level(){
    while [ $# -gt 0 ]; do
        printf "%s = %s\n" "$1" "$(eval ___x_cmd_log_level_code2name "\$___X_CMD_LOG__$1")"
        shift
    done
}

# EndSection

# Section: timestamp help
___x_cmd_log_timestamp(){
    local arg="${1:?Provide timestamp}"
    case "$arg" in
        on)     ___X_CMD_LOG__TIMESTAMP_FORMAT="+%H:%M:%S" ;;
        off)    ___X_CMD_LOG__TIMESTAMP_FORMAT= ;;
        *)      printf "Try customized timestamp format wit date command:\n"
                date "$arg" || return 1
                ___X_CMD_LOG__TIMESTAMP_FORMAT="$arg"
    esac
}

___x_cmd_log_help(){
    printf '%s' '
x log     log control facility
    Usage:
        x log init [ module ]
        x log [... +module | -module | module/log-level ]
Subcommand:
    init <module>:                  Generate function "<module>_log"
    timestamp < on | off | <format> >:
                                    off, default setting. shutdown the timestamp output in log
                                    on, default format is +%H:%M:%S
                                    <format>, customized timestamp format like "+%H:%M:%S", "+%m/%d-%H:%M:%S"
Example:
    Change debug log level for module json:
            x log json/debug   or   x log +json
            x log json/info    or   x log -json
            x log json/warn
            x log json/error
'

}
# EndSection

# Section: printer
# TODO: To move xrc_log
___X_CMD_LOG_C_TF=

___X_CMD_LOG__TIMESTAMP_FORMAT=      # "+%H:%M:%S"      # Enable Timestamp.

___X_CMD_LOG_C_MSG="${___X_CMD_LOG_C_MSG:-""}"
___X_CMD_LOG_C_DEBUG="${___X_CMD_LOG_C_DEBUG:-"\\033[0;32m"}"
___X_CMD_LOG_C_INFO="${___X_CMD_LOG_C_INFO:-"\\033[1;36m"}"
___X_CMD_LOG_C_WARN="${___X_CMD_LOG_C_WARN:-"\\033[1;33m"}"
___X_CMD_LOG_C_ERROR="${___X_CMD_LOG_C_ERROR:-"\\033[1;31m"}"

___X_CMD_LOG_C_TIMESTAMP_BEGIN="${___X_CMD_LOG_C_WARN:-"["}"
___X_CMD_LOG_C_TIMESTAMP_END="${___X_CMD_LOG_C_WARN:-"]"}"

___x_cmd_log_pr(){
    case "${2:?Provide level}" in
        debug)      eval "test 1 -ge \"\${___X_CMD_LOG__${1#:}:-2}\"" && { local O="${1#:}"; shift 2; L=DBG C="$___X_CMD_LOG_C_DEBUG"  ___x_cmd_log_0 "$@"; } ;;
        info)       eval "test 2 -ge \"\${___X_CMD_LOG__${1#:}:-2}\"" && { local O="${1#:}"; shift 2; L=INF C="$___X_CMD_LOG_C_INFO"   ___x_cmd_log_0 "$@"; } ;;
        warn)       eval "test 3 -ge \"\${___X_CMD_LOG__${1#:}:-2}\"" && { local O="${1#:}"; shift 2; L=WRN C="$___X_CMD_LOG_C_WARN"   ___x_cmd_log_0 "$@"; } ;;
        error)      eval "test 4 -ge \"\${___X_CMD_LOG__${1#:}:-2}\"" && { local O="${1#:}"; shift 2; L=ERR C="$___X_CMD_LOG_C_ERROR"  ___x_cmd_log_0 "$@"; } ;;
        *)          eval "test 3 -ge \"\${___X_CMD_LOG__${1#:}:-2}\"" && { local O="${1#:}"; shift 1; L=INF C="$___X_CMD_LOG_C_INFO"   ___x_cmd_log_0 "$@"; } ;;
    esac
}

___x_cmd_log_pr_debug(){
    L=DBG C="$___X_CMD_LOG_C_DEBUG"  ___x_cmd_log_0 "$@"
}

___x_cmd_log_pr_info(){
    L=INF C="$___X_CMD_LOG_C_INFO"  ___x_cmd_log_0 "$@"
}

___x_cmd_log_pr_warn(){
    L=WRN C="$___X_CMD_LOG_C_WARN"  ___x_cmd_log_0 "$@"
}

___x_cmd_log_pr_error(){
    L=ERR C="$___X_CMD_LOG_C_ERROR"  ___x_cmd_log_0 "$@"
}

___x_cmd_log_0(){
    local IFS=" "
    local timestamp

    if [ -n "$___X_CMD_LOG_C_TF" ] || [ -t 2 ]; then
        if [ -n "$___X_CMD_LOG__TIMESTAMP_FORMAT" ]; then
            timestamp="$(date "${___X_CMD_LOG__TIMESTAMP_FORMAT}")"
            timestamp="${___X_CMD_LOG_C_TIMESTAMP_BEGIN}${timestamp}${___X_CMD_LOG_C_TIMESTAMP_END} "
        fi

        if [ $# -gt 0 ]; then
            printf "${timestamp}${C}[%s] <%s>: \033[0m${___X_CMD_LOG_C_MSG:-"$C"}%s\033[0m\n" "$L" "$O" "$*"
        else
            printf "${timestamp}${C}[%s] <%s>:" "$L" "$O"
            cat | awk 'NR==1{ print($0) }; NR>=2{ print("> " $0); }; END{ printf("%s", "\033[0m"); }'
        fi
    else
        [ -n "$___X_CMD_LOG__TIMESTAMP_FORMAT" ] && timestamp="$(date "${___X_CMD_LOG__TIMESTAMP_FORMAT}") "
        if [ $# -gt 0 ]; then
            printf "${timestamp}[%s] <%s>: %s\n" "$L" "$O" "$*"
        else
            printf "${timestamp}[%s] <%s>:" "$L" "$O"
            cat | awk 'NR==1{ print($0) }; NR>=2{ print("> " $0); }; }'
        fi
    fi >&2
}

# EndSection

# Section: completer, Maybe we can use advise.json to replace it for advise module can support the following function.
# shellcheck disable=SC3010,SC2154
___x_cmd_log_completer(){

    case "$cur" in
        "")
            printf "%s\n" "+"
            printf "%s\n" "-"
            ls "$___X_CMD_ROOT" | grep -v BASE64  | awk '{ print $0 "/"; }'
            ;;
        */*)
            printf "%s\n" "${cur%/*}/debug"
            printf "%s\n" "${cur%/*}/verbose"
            printf "%s\n" "${cur%/*}/warn"
            printf "%s\n" "${cur%/*}/error"
            ;;
        +*)   ls "$___X_CMD_ROOT" | grep -v BASE64 | awk '{ print "+" $0; }' ;;
        -*)   ls "$___X_CMD_ROOT" | grep -v BASE64 | awk '{ print "-" $0; }' ;;
        *)
            ls "$___X_CMD_ROOT" | grep -v BASE64 | awk -v cur="$cur" '
    BEGIN { arr_len=0; }
    $0~"^"cur{
        arr_len += 1
        arr[arr_len] = $0;
        if ( $0 !~ /\/$/ ) arr[arr_len] = arr[arr_len] "/"
    }
    END {
        if (arr_len != 1) {
            for (i=1; i<=arr_len; ++i) print arr[i]
        } else {
            # It is useful! The completion seemed to pause before "/"
            print arr[1] "verbose"
            print arr[1] "debug"
            print arr[1] "warn"
            print arr[1] "error"
        }
    }
'
            ;;
    esac
}
# EndSection

