# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263    # xrc

# Section: full_version ls_local ls_remote

# TODO: Not proper implemented
___x_cmd_env_common_full_version(){
    local candidate="${1:?Provide candidate}"
    local version="${2}"

    if [ -z "$version" ]; then
        ___x_cmd_env_"$candidate"_ls_remote "$version" "$3" | awk 'END{ if (NR<=0) { exit(1) } else print $1;}'
    fi
    printf "%s\n" "$version"
}

___x_cmd_env_common_ls_local(){
    local candidate="${1:?Provide candidate}"
    if [ -d "$___X_CMD_ENV_PATH/$candidate/versions" ]; then
        ls "$___X_CMD_ENV_PATH/$candidate/versions"
    fi
}

___x_cmd_env_common_la(){
    :
}
# EndSection

# Section: use file
___x_cmd_env_common_init_file_add(){
    local candidate="$1"
    local version_path="$2"

    if [ ! -f "$___X_CMD_ROOT/.env/env/use" ]; then
        printf "%s\n" "$version_path" > "$___X_CMD_ROOT/.env/env/use"
    fi

    ___x_cmd_env_common_init_file_rm "$candidate"
    printf "%s\n" "$version_path" >> "$___X_CMD_ROOT/.env/env/use"
}

___x_cmd_env_common_init_file_rm(){
    local candidate="$1"
    local content
    content="$(grep -v "$candidate" < "$___X_CMD_ROOT/.env/env/use")"
    printf "%s\n" "$content" > "$___X_CMD_ROOT/.env/env/use"
}
# EndSection

# Section: use, try, ws

___x_cmd_env_common_use(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide version}"
    local use_shims="${3:-""}"

    if ! ___x_cmd_env_util_is_downloaded "$candidate" "$version" 2>/dev/null; then
        # TODO: Add prompt: download from the website.
        printf "%s" "Not downloaded" >&2
        return 0
    fi

    local version_path
    if [ -z "$use_shims" ]; then
        version_path="${___X_CMD_ENV_PATH}/$candidate/versions/$version/bin"
    else
        version_path="${___X_CMD_ENV_PATH}/$candidate/shims"
        ___x_cmd_env_util_make_shim_dir "$candidate" "${version}" || return 1
    fi

    ___x_cmd_env_util_add_path "$version_path" || return 1

    ___x_cmd_env_common_init_file_add "$candidate" "$version_path" && \
        # ___x_cmd_modfile_add "$___X_CMD_ROOT/.env/env/use" "$version_path" && \
            printf "%s\n" "$version" > "$___X_CMD_ENV_PATH/$candidate/version" && \
                env_log info "Using $candidate $version -> $___X_CMD_ENV_PATH/$candidate/version"
}

___x_cmd_env_common_try(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide version}"
    local version_path="${3:-"$___X_CMD_ENV_PATH/$candidate/versions/$version/bin"}"

    ___x_cmd_env_util_is_downloaded "$candidate" "$version" 2>/dev/null || return 1
    ___x_cmd_env_util_add_path "$version_path" && \
        env_log info "Setting ${candidate} ${version} in current Shell."
}

# EndSection

# Section: current

___x_cmd_env_common_current(){
    local candidate="${1:?Provide candidate}"
    local candidate_path
    candidate_path="$(command -v "$candidate")"

    # No any candidate version
    if [ -z "$candidate_path" ]; then
        env_log error "No version of $candidate detected, please install it first! "
        return 1

    # After try and no candidate version in xenv, but has candidate version in current shell.
    elif [ "$candidate_path" != "$___X_CMD_ENV_PATH/$candidate/shims/$candidate" ]; then
        local try_path="${candidate_path#*"versions/"}"
        try_path="${try_path%%/*}"
        if [ "$try_path" != "$candidate" ] && [ -n "$try_path" ]; then
            printf "%s\n" "$try_path"
        else
            printf "%s\n" "system"
        fi
        return 0

    # Use(shims)
    else
        local version
        if ! version=$(___x_cmd_env_util_shims_which_version "$candidate"); then
            env_log error "No version of $candidate detected, please download it first! "
            return 1
        fi

        local exactly_path="$___X_CMD_ENV_PATH/$candidate/versions/$version/bin/$candidate"
        if [ ! -f "$exactly_path" ]; then
            env_log error "No such file: $exactly_path"
            return 1
        fi

        printf "%s\n" "$version"
    fi
}
# EndSection

# Section: download

___x_cmd_env_common_download(){
    local candidate="${1:?Provide canddidate}"
    local version="${2:?Provide version}"

    if ___x_cmd_env_util_is_downloaded "$candidate" "$version" 2>/dev/null ; then
        env_log info "Already downloaded $candidate $version"
        return 0
    fi

    if ! ___x_cmd_env_run_common_if_notfound download_archive "$candidate" "$version"; then
        env_log error "Failed to download $candidate $version"
        return 1
    fi

    if ! ___x_cmd_env_run_common_if_notfound unpack "$candidate" "$version"; then
		env_log error "Failed to unpack $candidate of version: $version."
		return 1
	fi
}

# EndSection

# Section: install, uninstall
___x_cmd_env_common_install(){
    local candidate="${1:?Provide canddidate}"
    local version="${2:?Provide version}"
    local use_shims="${3:-""}"

    env_log info "Installing $candidate $version"
    if ! ___x_cmd_env_run_common_if_notfound download "$candidate" "$version"; then
        env_log error "Failed to installed $candidate of version: $version."
        return 1
    fi

    ___x_cmd_env_common_use "$candidate" "$version" "$use_shims" || return 1
    env_log info "Successfully installed $candidate $version"
}

___x_cmd_env_common_uninstall(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide the version}"
    env_log info "Uninstalling $1 $2"

    local candidate_path="$___X_CMD_ENV_PATH/${candidate}/versions/${version}"
    if [ -d "$candidate_path" ]; then
        rm -rf "${candidate_path}"
    else
        env_log  warn "This ${candidate} ${version} is no exist."
        return 1
    fi
    ___x_cmd_env_common_init_file_rm "$candidate"
    # TODO: remove the shims from $PATH
}
# EndSection

# Section: which, exec
___x_cmd_env_common_which(){
    local candidate="${1:?Provide candidate}"
    local candidate_path
    candidate_path="$(command -v "$candidate")"

    if [ "$candidate_path" != "$___X_CMD_ENV_PATH/$candidate/shims/$candidate" ]; then
        command -v "$candidate"
        return 0
    fi

    local version
    if version=$(___x_cmd_env_util_shims_which_version "$candidate"); then
        local exactly_path="$___X_CMD_ENV_PATH/$candidate/versions/$version/bin/$candidate"
        if [ ! -f "$exactly_path" ]; then
            env_log error "No such file: $exactly_path"
            return 1
        fi
        printf "%s\n" "$exactly_path"
    fi
}

___x_cmd_env_common_exec(){
    local candidate="${1:?Provide candidate}"
    local version="${2:?Provide version}"; shift 2
    ___x_cmd_env_util_is_downloaded "${candidate}" "${version}" 2>/dev/null || return 1
    PATH="${___X_CMD_ENV_PATH}/${candidate}/versions/${version}/bin:$PATH" "${candidate}" "$@"
}
# EndSection

# Section: ui_catsel

___x_cmd_env_common_rec(){
    local cmd="$1"
    local space="${2:-""}"
    eval "$cmd" | while read -r line ; do
        if [ -n "$line" ] ; then
            CODE="${CODE}
${space}  \"$line\":{"

            ___x_cmd_env_common_rec "$cmd $line" "$space  "

            CODE="${CODE%,}
${space}  },"
        fi
    done
}

___x_cmd_env_common_gen(){
    if [ -f "${___X_CMD_ENV_PATH}/${candidate}/cache/${candidate}.json" ]; then
        return 0
    fi
    local CODE="{"
    local candidate="$1"
    cmd="x env ___x_cmd_ui_catsel $candidate"
    ___x_cmd_env_common_rec "$cmd"
    printf "%s" "${CODE%,}
}" > "${___X_CMD_ENV_PATH}/${candidate}/cache/${candidate}.json"
}
# EndSection