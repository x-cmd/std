# shellcheck shell=sh
# shellcheck disable=SC2089,SC3043
___X_CMD_XRC_MODULE_IMPORTED=
xrc dict
xrc assert
x log init dict
x log dict

f(){
    dict @aaa put 1 0 "Access type"
    dict @aaa put 1 1 "atype"
    dict @aaa put w 2 "public"
    dict @aaa put 1 3 "="
    dict @aaa put 1 4 "12[0-9]+"
}

q(){
    f
    dict @aaa get 1 0
    dict @aaa get 1 1
    dict @aaa get w 2
    dict @aaa get 1 3
    dict @aaa get 1 4
}

test_scope_get(){
    assert_stdout "q" <<A
Access type
atype
public
=
12[0-9]+
A
}

test_dict_setup(){
    dict @b free
    dict @b make
    dict @b put 1 a
    dict @b put 2 b
    dict @b put "2 \" 3 " b
    dict @b put 3 c
}

test_dict_has(){
    test_dict_setup
    assert_t dict @b has 2
    assert_f dict @b has 4
}

test_dict_size(){
    test_dict_setup
    assert "$(dict @b size)" = 4
}

test_dict_is_empty(){
    dict @b free
    dict @b make
    assert_t dict @b is_empty
    dict @b put 1 a
    assert_f dict @b is_empty
}

test___x_cmd_dict___pget(){
    test_dict_setup
    assert "$(dict @b get 2)" = b
}

test___x_cmd_dict___pscope(){
    dict @b del 2>/dev/null
    # dict_log "Testcase 's object-name \"$(command -v b 2>&1)\""
    dict @b new
    # dict_log "Testcase 's object-name $(command -v b)"
    b put el user edwinjhlee
    b put lt user lteam
    b put el password goforit
    b put lt password 2008

    local expected='user=edwinjhlee
password=goforit'

    if [ -n "${BASH_VERSION}" ]; then
        case "${BASH_VERSION}" in
            3*|4.0*|4.1*)
                expected='user=edwinjhlee
password=goforit'
                ;;
            *)
        esac
    fi

    assert_stdout "dict @b scope el | ___x_cmd_dict_pprint" <<A
${expected}
A

    local expected2='{
  "password": "2008",
  "user": "lteam"
}'

    if [ -n "${BASH_VERSION}" ]; then
        case "${BASH_VERSION}" in
            3*|4.0*|4.1*);;
            *)
                expected2='{
  "password": "2008",
  "user": "lteam"
}'
                ;;
        esac
    else

    assert_stdout "dict @b scope lt | ___x_cmd_dict_pjson" <<A
${expected2}
A
    fi
}

test_dict_dump_json(){
    test_dict_setup
    local expected='{
  "3": "c",
  "2": "b",
  "1": "a",
  "2 \" 3 ": "b"
}'

    if [ -n "${BASH_VERSION}" ]; then
        case "${BASH_VERSION}" in
            3*|4.0*|4.1*)
                expected='{
  "1": "a",
  "2": "b",
  "2 \" 3 ": "b",
  "3": "c"
}'
                ;;
            4*) expected='{
  "2 \" 3 ": "b",
  "1": "a",
  "2": "b",
  "3": "c"
}' ;;
        esac
    elif [ -n "${ZSH_VERSION}" ]; then
        expected='{
  "1": "a",
  "2": "b",
  "3": "c",
  "2 \" 3 ": "b"
}'
    fi

    assert_stdout "dict @b json" <<A
${expected}
A
}

test_dict_load_json(){
    dict @b free
    dict_log "test1: ___X_BASH_DICT_b:${___X_BASH_DICT_b}"
    dict @b make

    local expected
    local test_json='{
  "3": "c",
  "2 \" 3 ": "b",
  "1": "a",
  "2": "b"
}'

    # BUG: dict_load_json does not work in zsh with spaces in keys
    dict @b load_json "${test_json}"
    dict_log "test2: ___X_BASH_DICT_b:${___X_BASH_DICT_b}"
    dict_log "test2: ___X_BASH_DICT_b:$(dict @b dump)"
    expected="$test_json"

    if [ -n "${BASH_VERSION}" ]; then
        case "${BASH_VERSION}" in
            3*|4.0*|4.1*);;
            4*)
                expected='{
  "1": "a",
  "2": "b",
  "3": "c",
  "2 \\" 3": "b"
}';;
            *)
                expected='{
  "3": "c",
  "2": "b",
  "1": "a",
  "2 \\" 3": "b"
}';;
        esac
    elif [ -n "${ZSH_VERSION}" ]; then
        expected='{
  "1": "a",
  "2": "b",
  "3": "c",
  "2 \\" 3": "b"
}'
    fi

    assert_stdout "dict @b json" <<A
${expected}
A
}

test___x_cmd_dict___premove(){
    test_dict_setup
    assert_f dict @b remove 4
    assert_t dict @b has 2
    dict @b drop 2
    assert_f dict @b has 2
}

test___x_cmd_dict___pdrop(){
    test_dict_setup
    assert_t dict @b drop "\"[1-3]+"\"
    assert_f dict @b has 1
    assert_f dict @b has 5
}

< ./testcase/v0_test awk '$0~/^test_[^\(]+\(\)/{ gsub(/\(\)\{/, "", $0); print $0 }' | while read -r line; do
    echo "Testing Function: $line"
    if ! $line; then
        echo "======= fail at function: $line" >&2
        break
    fi
done