# shellcheck shell=sh disable=SC3043
# shellcheck disable=SC2039

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao


# Section: main

# example of dict
#   dict put key1 value1
#   dict :a put key2 value2
dict(){
    local op="${1:?Provide op}"
    local O=${op#@}
    if [ "$O" = "$op" ]; then
    # without : prefix, to set the blank O
        O=
        shift
    else
        op="${2:-help}"
        [ $# -gt 1 ] && shift 2
    fi

    case "$op" in
        new)                _dict_new "$@"   ;;
        del)                _dict_del "$@"   ;;
        make)               ___dict_make "$@"   ;;
        free)               _dict_free "$@"  ;;
        get)                ___dict_get "$@" ;;
        put)                ___dict_put "$@" ;;
        scope)              ___dict_scope "$@"   ;;
        remove)             ___dict_remove "$@" ;;
        clear)              ___dict_clear "$@" ;;
        drop)               ___dict_drop "$@" ;;
        dropr)              ___dict_dropr "$@" ;;
        grep)               ___dict_grep "$@" ;;
        grepr)              ___dict_grepr "$@" ;;
        iter)               ___dict_iter "$@" ;;
        load)               ___dict_load "$@" ;;
        load_json)          ___dict_load_json "$@" ;;
        dump)               ___dict_dump "$@" ;;
        json)               _dict_json "$@" ;;
        size)               ___dict_size "$@" ;;
        has)                _dict_has "$@"  ;;
        is_empty)           _dict_is_empty "$@" ;;
        _x_cmd_advise_json) _dict_x_cmd_advise_json "$@" ;;
        *)                  : help ;;
    esac
}

_dict_x_cmd_advise_json(){
    cat <<A
{
    "new"       : null,
    "del"       : null,
    "free"      : null,
    "get"       : null,
    "put"       : null,
    "scope"     : null,
    "remove"    : null,
    "drop"      : null,
    "dropr"     : null,
    "grep"      : null,
    "grepr"     : null,
    "iter"      : null,
    "load"      : null,
    "dump"      : null,
    "json"      : null,
    "size"      : null,
    "is_empty"  : null,
    "@"         : "___x_cmd_instance_list dict"
}
A
    return 126

}

# EndSection

# Section: Life cycle

_dict_new(){
    local O="${O:?list_name}"
    O="${O#@}"
    ___x_cmd_instance_new "dict" "@$O" "$@"
}

_dict_del(){
    if command -v "$O" 1>/dev/null 2>&1; then
        _dict_free "$@" && unset "$O"
        return
    fi
    printf "%s\n" "No such dict instance: $O" >&2
}

_dict_free(){
    local O="${O:?Please provide dict_name for _dict_free}"
    ___x_cmd_instance_rm "dict" "$O"
    eval "unset ___X_BASH_DICT_$O"
}

# EndSection

# Section: has is_empty

# 001 for \n
# 002 for "
DICT_SEP="$(printf "\003")"
DICT_KV_SEP="$(printf "\004")"
DICT_KEYS_SEP="$(printf "\005")"

_dict_has(){
    ___dict_get "$@" > /dev/null
}

_dict_is_empty(){
    [ "$(___dict_size)" -eq 0 ]
}

# EndSection

# Section: print pprint grep filter

_dict_pgrep(){
    AWK_CODE="( keyline ~ key )" _dict_premove "$@"
}

_dict_pdrop() {
    AWK_CODE="! (keyline ~ key)" _dict_premove "$@"
}

# drop_by_idx, drop_by_regex, drop_by_glob
_dict_premove() {
    [ $# -eq 0 ] && printf "%s\n" "Accept more than one argument." >&2

    local IFS="${DICT_KEYS_SEP}"
    local AWK_CODE
    AWK_CODE=${AWK_CODE:-"keyline != key"}
    {
        printf "%s${DICT_SEP}" "$*"
        cat
    } | awk -v RS="${DICT_SEP}" '
        NR==1 { key = $0;   ORS=RS;   len=0   }
        NR>=2 {
            if (NR % 2 == 0) {  # key
                keyline = $0
            } else {
                if ('"$AWK_CODE"')  print keyline ORS $0
                else                len = len - 1
            }
        }
        END   {
            if (len < 0) {
                printf("%s", (keyline + len))
                exit 0
            } else {
                printf("%s", keyline)
                exit 1
            }
        }
    ' -
}

_dict_pput(){
    {
        local s
        local IFS="${DICT_KEYS_SEP}"
        s="$*"
        printf "%s${DICT_SEP}%s${DICT_SEP}" "${s%${DICT_KEYS_SEP}*}" "${s##*${DICT_KEYS_SEP}}";
        cat
    } | awk -v RS="${DICT_SEP}" '

        BEGIN { sw = 0; ORS = RS;   }
        NR==1 { key = $0            }
        NR==2 { val = $0            }
        NR>=3 {
            if (NR % 2 == 1) { # key
                keyline = $0
            } else {
                if (keyline == key) {
                    print keyline RS val
                    valline = ""
                    sw = 1
                } else {
                    print keyline RS $0
                }
            }
        }
        END   {
            if (sw == 1)    printf("%s", keyline)
            else {
                print key RS val
                printf("%s", (keyline+1))
            }
        }
    ' -
}

_dict_pget(){
    local IFS="${DICT_KEYS_SEP}"
    {
        printf "%s${DICT_SEP}" "$*"
        cat
    } | awk -v RS="${DICT_SEP}" '
        NR==1 {
            tgt = $0;   tgt_len = length(tgt);  exit_code = 1
        }
        NR>=2 {
            if (NR % 2 == 0) {  # key
                keyline = $0
            } else {
                if (keyline == tgt) {
                    print $0
                    exit_code = 0
                    exit
                }
            }
        }
        END {
            exit exit_code
        }
    ' -
}

_dict_pfilter(){
    local s
    local AWK_CODE=""

    case $# in
        0)  exit 4;;
        1)
            AWK_CODE="keyline == tgt"
            s="$1" ;;
        *)
            local IFS="${DICT_KEYS_SEP}"
            s="$*";
            AWK_CODE="substr(keyline, 1, tgt_len) == tgt" ;;
    esac

    {
        printf "%s${DICT_SEP}" "$s"
        cat
    } | awk -v RS="${DICT_SEP}" '
        NR==1 {
            tgt = $0;   tgt_len = length(tgt);  exit_code = 1
        }
        NR>=2 {
            if (NR % 2 == 0) {  # key
                keyline = $0
            } else {
                if ('"${AWK_CODE}"') {
                    print $0
                    exit_code = 0
                    exit
                }
            }
        }
        END {
            exit exit_code
        }
    ' -
}

# ___dict_scope <key1> <key2> <key3>
_dict_pscope(){
    {
        local IFS="${DICT_KEYS_SEP}"
        printf "%s${DICT_KEYS_SEP}${DICT_SEP}" "$*"
        cat
    } | awk -v RS="${DICT_SEP}" '
        NR==1 {
            key = $0;   ORS=RS;   len=0
            key_len = length(key)
        }
        NR>=2 {
            if (NR % 2 == 0) {  # key
                keyline = $0
            } else {
                if (substr(keyline, 1, key_len) == key) {
                    print substr(keyline, key_len+1) ORS $0
                    len = len + 1
                }
            }
        }
        END {
            printf("%s", len)
        }
    ' -
}

DICT_SEP="$(printf "\003")"
_dict_map_awk(){
    # TODO: modify_key(key, value)
    # TODO: modify_value(key, value)
    awk -v RS="${DICT_SEP}" "$1""


    " -
}

# EndSection

# Section: json print pprint

_dict_json(){
    ___dict_dump | ___dict_pjson "$@"
}

___dict_dump_json(){
    ___dict_dump | ___dict_pjson
}

___dict_load_json(){
    ___dict_load <<A
$(printf "%s" "$1" | ___dict_pjsonparse)
A
}

# ___dict_dump
___dict_pjson(){

    cat | awk -v RS="${DICT_SEP}" '
        BEGIN { len = $0;   result = "{";     quote = "\002";}
        NR>=1 {
            if (NR % 2 == 1) { # key
                key = $0
            } else {
                if (NR == 2)    result = result "\n  "  quote key quote ": " quote $0 quote
                else            result = result ",\n  " quote key quote ": " quote $0 quote
            }
        }
        END   {
            result = result "\n}"

            # gsub("\001", "\\n", result)
            gsub("\"", "\\\"", result)
            gsub("\002", "\"", result)
            gsub("\v", "\\v", result)
            gsub("\b", "\\b", result)
            gsub("\t", "\\t", result)
            gsub("\r", "\\r", result)
            printf("%s", result)
        }
    ' -
}

___dict_pjsonparse(){
    awk -v op=flat-leaf -f "$(xrc which json/v0_walk.awk)" \
        | awk 'BEGIN{ORS="\003"} { start=index($0, "\"")
          tmp=index($0, "--->")
          print substr($0,start+1,tmp-start-3) "\003" substr($0,tmp+start+3,length($0)-tmp-6)
        } END{ print NR }'
}

___dict_print(){
    ___dict_dump | ___dict_pprint "$@"
}

___dict_pprint(){
    {
        printf "${ITEM_SEP:-"\\n"}${DICT_SEP}${KV_SEP:-"="}${DICT_SEP}"
        cat
    } | awk -v RS="${DICT_SEP}" '
            NR==1 {     ORS = $0            }
            NR==2 {     KV_SEP  = $0        }
            NR>=3 {
                if (NR % 2 == 1)    key = $0
                else                print  key KV_SEP $0
            }
        ' -
}

# EndSection

# Section: Adviser and select implementation according to specific shell

if [ -n "${BASH_VERSION}" ]; then
    case "${BASH_VERSION}" in
        3*|4.0*|4.1*)
            xrc dict/_v0/str
            # . ./_v0/str
            ;;
        *)
            xrc dict/_v0/bash4
            ;;
    esac
elif [ -n "${ZSH_VERSION}" ]; then
    xrc dict/_v0/zsh
else
    xrc dict/_v0/str
fi

if [ -z "$XRC_NO_ADVISE" ] && [ -n "${BASH_VERSION}${ZSH_VERSION}" ] && [ "${-#*i}" != "$-" ]; then
    # if you use xrc that you must have advise
    # xrc advise/latest
    advise dict
fi

# EndSection
