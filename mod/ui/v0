# shellcheck shell=sh disable=SC3043

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao

# For some advancing usage. Refer to http://linuxcommand.org/lc3_adv_tput.php

# tput: https://www.gnu.org/software/termutils/manual/termutils-2.0/html_chapter/tput_1.html

# Section : ui major function and facilities and init
ui(){
    local f=$1
    case "$f" in
        http://* | https://* | ftp://* |ftps://* | git://* )    ui_url "$f"             ;;
        :)                                                      ui_print_var "$@"       ;; # TODO
        progressbar|probar)     shift;                          ___ui_progressbar "$@"     ;; 
        cmd|cmdline)            shift;                          ui_cmdline "$@"         ;;
        table)                  
            shift; 
            command -v ___ui_table >/dev/null || xrc ui/_v0/table;        
            ___ui_table  "$@"
            ;;
        #TODO: need to review
        select|choice|sel)               
            shift
            command -v ___x_cmd_ui_select >/dev/null || xrc ui/_v0/select
            ___x_cmd_ui_select "$@"
            ;;
        form)
            shift
            command -v ___x_cmd_ui_prompt_form >/dev/null || xrc ui/_v0/form
            ___x_cmd_ui_prompt_form "$@"
            ;;
        tf)
            shift
            command -v ___x_cmd_ui_tf >/dev/null || xrc ui/_v0/truefalse
            ___x_cmd_ui_tf "$@"
            ;;
        animate)
            shift
            command -v ___x_cmd_ui_animate >/dev/null || xrc ui/_v0/animate
            ___x_cmd_ui_animate "$@"
            ;;
        spin)
            shift
            ___x_cmd_ui_spin "$@" ;;
        sep)        shift; ui_seperator "$@" ;;
        sep1)       shift; ui_seperator1 "$@" ;;
        sep2)       shift; ui_seperator2 "$@" ;;
        sep3)       shift; ui_seperator3 "$@" ;;

        prompt)                 shift; xrc ui/_v0/prompt;       ___ui_prompt "$@"       ;;
        md|markdown)            shift; xrc ui/_v0/markdown;     ___ui_markdown "$@"     ;;
        cols)                                                   printf "%s" "$COLUMNS"  ;;
        rows)                                                   printf "%s" "$LINES"    ;;
        *)                                                      ui_style "$@"           ;;
    esac
}

# EndSection

# Section : init

# Thank ryenus, iRaS and Mekcki for answers in https://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window
ui_init_lines_columns(){
    local IFS
    IFS=" "
    read -r LINES COLUMNS <<A
$(stty size)
A
}
ui_init_lines_columns

if read -p " " -e ___UI_TMP_TEST 1>/dev/null 2>/dev/null <<A
hi
A
then

___ui_read(){
    local varname="${1:?Provide varname}"
    read -p " " -e -r "$varname"
}

else

___ui_read(){
    local varname="${1:?Provide varname}"
    printf "%s" " "
    read -r "$varname"
}
fi

___UI_TMP_TEST=

# EndSection

# Section : ui style

___x_cmd_ui_colorcode(){
    case "$1" in
        black)      printf 0 ;;
        red)        printf 1 ;;
        green)      printf 2 ;;
        yellow)     printf 3 ;;
        blue)       printf 4 ;;
        magenta)    printf 5 ;;
        cyan)       printf 6 ;;
        white)      printf 7 ;;
    esac
}

if command -v tput 1>/dev/null 2>&1; then

ui_tput(){
    local op="$1"; shift
    case "$op" in
        cursor_read)                ui_cursor_read "$@";;
        screen)                     ui_screen "$@" ;;

        sc|cursor_save)             tput sc ;;
        rc|cursor_restore)          tput rc ;;

        cnorm|cursor_normal)        tput cnorm ;;
        cvvis|cursor_show)          tput cvvis ;;
        civis|cursor_hide)          tput civis ;;

        smcup|screen_save)          tput smcup ;;
        rmcup|screen_restore)       tput rmcup ;;
        
        
        *)                          tput "$op" "$@" ;;
    esac
}


else

ui_tput(){
    local op="$1"; shift
    case "$op" in
        cursor_read)                ui_cursor_read "$@";;
        screen)                     ui_screen "$@" ;;

        sc|cursor_save)             printf "\0337" ;;
        rc|cursor_restore)          printf "\0338" ;;

        cnorm|cursor_normal)        printf "\033[34h\033[?25h" ;;
        cvvis|cursor_show)          printf "\033[34l" ;;
        civis|cursor_hide)          printf "\033[?25l" ;;

        smcup|screen_save)          printf "\033[?1049h" ;;
        rmcup|screen_restore)       printf "\033[?1049l" ;;
        
        el)                         printf "\033[K" ;;
        el1)                        printf "\033[1K" ;;
        cuu)                        printf "\033[%sA" "${2:?Provide number of line to move up}" ;;
    esac
}

fi

ui_style(){
    local IFS=" "
    while [ $# -gt 0 ]; do
        case "$1" in
            dim|debug)                                              printf "\033[2m"                                            ;; # tput dim;;
            info)                                                   printf "\033[1;36m"                                         ;;
            error)                                                  printf "\033[1;31m"                                         ;;
            warn)                                                   printf "\033[1;33m"                                         ;;
            normal)                                                 printf "\033[0m"                                            ;;  # tput bold
            bold)                                                   printf "\033[1m"                                            ;;  # tput bold
            underline|smul)                                         printf "\033[4m"                                            ;; # tput dim;;
            rmul)                                                   printf "\033[24m"                                           ;; # tput dim;;
            black|red|green|yellow|blue|magenta|cyan|white)         printf "\033[3$(___x_cmd_ui_colorcode "$1")m"               ;;
            bfg-*)                                                  printf "\033[1;3$(___x_cmd_ui_colorcode "${1#bfg-}")m"      ;;
            hfg-*)                                                  printf "\033[9$(___x_cmd_ui_colorcode "${1#hfg-}")m"        ;;
            rgbfg-*)                                                printf "\033[38;5;${1#rgbfg-}m"                             ;;
            bg-*)                                                   printf "\033[4$(___x_cmd_ui_colorcode "${1#bg-}")m"         ;;
            hbg-*)                                                  printf "\033[10$(___x_cmd_ui_colorcode "${1#hbg-}")m"       ;;
            rgbbg-*)                                                printf "\033[48;5;${1#rgbbg-}m"                             ;;
            rev)                                                    printf "\033[7m"                                            ;;
            end)                                                    printf "\033[0m"                                            ;;
            reset)                                                  tput reset                                                  ;;
            --)                                                     shift; printf "%s\033[0m" "$*"; return ;;
            *)                                                      printf "%s\033[0m" "$*"; return
        esac
        shift
    done
}

# EndSection

# Section : cmdline URL, seperator, seperator2

ui_cmdline(){
    local prompt=${1:-">"}

    # if [ ! -t 0 ]; then
    if [ $# -gt 1 ]; then
        shift;
        printf "$(ui bold yellow)${prompt} $(ui normal white)%s$(ui end)\n" "$*"
    else
        local line
        while read -r line; do
            printf "$(ui bold yellow)${prompt} $(ui normal white)%s$(ui end)\n" "$line"
        done
    fi
}

ui_url(){
    printf "$(ui smul)%s$(ui rmul)" "${1:?Provide URL}"
}

ui_draw_seperator(){
    local sep=""
    local _i=1
    local maxw
    maxw="$(ui cols)"
    while [ "$_i" -lt "$maxw" ];do
        sep="$sep""${1:-—}" 
        _i="$((_i+1))"
    done
    printf "$sep\n" 
}

# TODO: Seq is an external command.
ui_seperator(){
    local sep 
    local maxw
    maxw="$(ui cols)"
    sep="$(seq -f "${1:-—}" -s '' "$maxw")"
    echo "$sep"
}

ui_seperator2(){
    local sep 
    local maxw
    maxw=$(( $(ui cols) / 2 ))
    sep="$(seq -f "${1:-—}" -s '' "$maxw")"
    echo "$sep"
}

ui_seperator3(){
    local sep 
    local maxw
    maxw=$(( $(ui cols) / 3 ))
    sep="$(seq -f "${1:-—}" -s '' "$maxw")"
    echo "$sep"
}

___x_cmd_ui_spin(){
    local c=$(( $1 % 4 ))
    local i
    case "$c" in
        0)  printf "\\"  ;;
        1)  printf "|"   ;;
        2)  printf "/"   ;;
        3)  printf "-"   ;;
    esac
}

# EndSection

# Section : progress

# shellcheck disable=SC2120
___ui_progressbar(){
    local maxw=80
    [ "$COLUMNS" -lt "$maxw" ] && maxw=$COLUMNS

    if [ -n "$3" ]; then    printf "%s\n" "$3"
    else                    cat;         
    fi | awk -v ch="${1:-\*}" -v other="${2:-" "}" -v maxw="$COLUMNS" '
function str_rep(char, number, _i, _s) {
    for (   _i=1; _i<=number; ++_i  ) _s = _s char
    return _s
}

function print_progressbar(percent,         _width, _space, _stars, _s){
    _width = maxw - 30
    _stars = _width
    _stars = int(_stars * percent / 100)
    _space = _width - _stars

    s = str_rep(ch, _stars) str_rep(other, _space)
    
    if (percent == 100)     printf("( DONE! )|%s|", s)
    else                    printf("( %3d %% )|%s|", percent, s)
}

NR==1{  
    print_progressbar($0)
    fflush()
}
NR>=2{
    printf("\r")
    print_progressbar($0)
    fflush()
}
'
}

___ui_progressbar_test(){
    for i in $(seq 0 100); do
        printf "%s\n" "$i"
        sleep 0.01s
    done | ___ui_progressbar
}

# EndSection

# Section : tput facility: cursor


# reference: https://unix.stackexchange.com/questions/88296/get-vertical-cursor-position/183121#183121
ui_cursor_read(){
    local cv 
    local ch 
    local IFS
    # tput u7                  # Inquire for cursor position
    # read -sdR CURPOS         # Read cursor position
    # IFS=\; read cv ch <<<"${CURPOS#$'\e['}" # split $CURPOS

    # TODO: Use something better
    # IFS=';' read -sdR -p $'\E[6n' cv ch
    IFS=';' read -sdR -p "$(printf "\033[6n")" cv ch
    cv="${cv#*[}"

    case $# in
        0) echo "$cv $ch";;
        1) eval "$1=$cv";;
        *) 
            eval "$1=$cv"; 
            eval "$2=$ch";;
    esac
}

___ui_line_count(){
    local maxw="$COLUMNS"
    local n
    local IFS
    local linenum=0
    while read -r n; do
        linenum=$(( linenum + ( ${#n} + maxw - 1 ) / maxw ))
    done
    printf "%s" "$linenum"
}

# EndSection



# Section : screen design -- tput screen facility

ui_screen() {
    ui_tput screen_save
    eval "$@"
    ui_tput screen_restore
}

ui_banner() {
    # echo -n ${BG:-$UI_BG_BLUE}${FG:-$UI_FG_WHITE}
    local FG
    local BG
    FG=$(tput setaf "${1:-$UI_WHITE}")
    BG=$(tput setab "${2:-$UI_BLUE}")
    echo "$FG$BG"
    clear
    cat
}

RUN_CMD_WITH_INFO() {
    local INFO=$1
    shift 1
    INFO "======================\n"
    INFO "$INFO\n"
    INFO "======================\n"
    eval "$@"
}

RUN_CMD_WITH_STEP() {
    local STEP=$1
    local INFO="STEP $STEP: $2"
    shift 2
    RUN_CMD_WITH_INFO "$INFO" "$@"
}

# EndSection

# Section : interactive component
_______ui_check_cmd_run(){
    local msg="${1:?Please Provide message}"; shift

    # TODO: Consider using trap or other method to interrupt the par animation
    local filepath
    filepath="$TMPDIR/_______ui_check_cmd_run.$$.$(date +%s).txt"
    {
        eval "$@"
        printf "%s" "$?" > "$filepath"
    } | {
        local i="-"
        local FMT="\r$(ui blue)$(ui bold)%s       $(ui end)$(ui yellow)%s$(ui end)"
        printf "$FMT" "$i" "$msg"
        while [ ! -f "$filepath" ]; do
            sleep 0.1
            case "$i" in
                -)  i="\\"  ;;
                \\) i="|"   ;;
                \|) i="/"   ;;
                /)  i="-"   ;;
            esac
            printf "$FMT" "$i" "$msg"
        done
        return "$(cat "$filepath"; rm "$filepath" 2>/dev/null)"
    }
}

ui_check_cmd(){
    local msg="${1:?Please Provide message}";    
    if _______ui_check_cmd_run "$@"; then
        printf "\r$(ui green)$(ui bold)%s       %s$(ui end)"  "√" "$msg"
    else
        local code=$?
        printf "\r$(ui red)$(ui bold)%s       %s$(ui end)"    "X" "$msg"
        return "$code"
    fi
}
# EndSection

# Section other unused
# Maybe not useful
___ui_yesno() {
    local p
    while true; do
        printf "%s" "$1 (Input 'y' for yes or 'n' for no):"
        ___ui_read p
        # remove space
        case $p in
            y)          return 0 ;;
            n)          return 1 ;;
        esac
    done
}

___ui_yesno_enter() {
    local p
    while true; do
        printf "%s" "$1 (Press Enter or y for yes, otherwise no):"
        ___ui_read p
        # remove space
        case $p in
            y|"")           return 0    ;;
            *)              return 1    ;;
        esac
    done
}

___ui_readint() {
    local min=${1:?Provide min}
    local max=${2:?Provide max}

    local choice
    while true; do
        printf "%s" "${3:-Read integer: }" 
        ___ui_read choice
        if [ "$choice" -ge "$min" ] && [ "$choice" -le "$max" ]; then
            printf "%s" "$choice"
            return 0
        fi 2>/dev/null
    done
}
# EndSection
