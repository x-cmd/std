# shellcheck shell=sh disable=SC3043

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao


# Section: region update

___X_CMD_UI_REGION_AWK="$(xrc which ui/_v0/region.awk)"
# ___X_CMD_UI_REGION_AWK=./region.awk

___X_CMD_UI_REGION_SEPERATOR="$(printf "\001")"

# shellcheck disable=SC2120
___x_cmd_ui_region_send(){
    if [ "$#" -eq 0 ]; then
        awk -v RS="$(printf "\001")" '{
            gsub("\n", "\001", $0)
            print($0)
        }'
        # printf "\n"
    else
        printf "%s" "$*" | awk -v RS="$(printf "\001")" '{
            gsub("\n", "\001", $0)
            print($0)
        }'
        # printf "\n"
    fi
}

___x_cmd_ui_region_update(){
    {
        local line
        while read -r line; do
            printf "%s %s\n%s\n" UPDATE "$COLUMNS" "$line"
        done | {
            awk -f "$___X_CMD_UI_REGION_AWK"
        }
    }>&2
}

region_run(){
    exec 3>&1
    eval "$@" 2>&1 >&3 3>&- | ___x_cmd_ui_region_update
    exec 3>&-
}

# EndSection

# Section: readchar

if [ -n "$KSH_VERSION" ]; then

___x_cmd_ui_region_read_char(){
    stty -echo
    read -s -n 1 "$@"
    stty echo
}

else

___x_cmd_ui_region_read_char(){
    read -s -n 1 "$@"
}

fi

___X_CMD_UI_REGION_E="$(printf "\033")"
___X_CMD_UI_REGION_ENTER="$(printf "\015")"
___X_CMD_UI_REGION_BACKSPACE="$(printf "\010")"
___X_CMD_UI_REGION_DELETE="$(printf "\177")" # 7f


if [ -n "$BASH_VERSION" ]; then
___x_cmd_ui_region_getchar_read1(){
    local IFS="$(printf "\001")"
    read -rsn "${1:-1}" ___X_CMD_UI_GETCHAR_CHAR
}


elif [ -n "$ZSH_VERSION" ]; then

___x_cmd_ui_region_getchar_read1(){
    local IFS="$(printf "\001")"
    read -rsk "${1:-1}" ___X_CMD_UI_GETCHAR_CHAR
}

else

echo "Using stty for read1" >&2
___x_cmd_ui_region_getchar_read1(){
    stty raw
    ___X_CMD_UI_GETCHAR_CHAR="$(dd bs=1 count="${1:-1}" 2> /dev/null)"
    stty -raw
}

fi

___x_cmd_ui_region_get_leading_1_len(){
    local num
    num="$(printf "%d" "'$1")"
    if [ "$num" -ge 0 ]; then
        printf "%s\n" "0"
        return
    fi
    num=$((num + 256))
    local i
    for i in 0 1 2 3 4 5 6 7 8; do
        s=$(( (num << i) & 128 ))
        if [ "$s" -eq 0 ]; then
            printf "%s\n" "$i"
            return
        fi
    done
}

# Not worked in ksh. Using stty -echo

___X_CMD_UI_GETCHAR_TYPE=
___X_CMD_UI_GETCHAR_CHAR=
region_getchar(){
    ___x_cmd_ui_region_getchar_read1

    ___X_CMD_UI_GETCHAR_TYPE=special

    # TODO: only the last enter worked. check and trim
    [ "${#___X_CMD_UI_GETCHAR_CHAR}" -eq 0 ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return
    # [ "${___X_CMD_UI_GETCHAR_CHAR}" = "$___X_CMD_UI_REGION_ENTER" ] && printf "%s\n" ENTER && return
    # [ "${___X_CMD_UI_GETCHAR_CHAR}" = "$(printf "\012")" ] && printf "%s\n" ENTER && return
    # [ "${___X_CMD_UI_GETCHAR_CHAR}" = "$(printf "\n")" ] && printf "%s\n" ENTER && return
    [ "${___X_CMD_UI_GETCHAR_CHAR}" = "
" ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return

    if [ "$___X_CMD_UI_GETCHAR_CHAR" = "$___X_CMD_UI_REGION_E" ]; then
        ___x_cmd_ui_region_getchar_read1 # read 2 more chars

        case "$___X_CMD_UI_GETCHAR_CHAR" in
            \[) 
                ___x_cmd_ui_region_getchar_read1 # read 2 more chars
                case "$___X_CMD_UI_GETCHAR_CHAR" in
                    'A')       ___X_CMD_UI_GETCHAR_CHAR=UP  ;;
                    'B')       ___X_CMD_UI_GETCHAR_CHAR=DN  ;;
                    'D')       ___X_CMD_UI_GETCHAR_CHAR=LEFT ;;
                    'C')       ___X_CMD_UI_GETCHAR_CHAR=RIGHT ;;
                    *)         ___X_CMD_UI_GETCHAR_CHAR="[$___X_CMD_UI_GETCHAR_CHAR" ;;
                esac
                ;;
            q)  
                ___X_CMD_UI_GETCHAR_CHAR=QUITTING
                return 1
                ;;
            *)
                # ___X_CMD_UI_GETCHAR_CHAR="$___X_CMD_UI_GETCHAR_CHAR"
        esac
        return
    fi

    
    [ "$___X_CMD_UI_GETCHAR_CHAR" = "$___X_CMD_UI_REGION_BACKSPACE" ] && ___X_CMD_UI_GETCHAR_CHAR=BACKSPACE && return
    [ "$___X_CMD_UI_GETCHAR_CHAR" = "$___X_CMD_UI_REGION_DELETE" ] && ___X_CMD_UI_GETCHAR_CHAR=DELETE && return
    
    local num
    num=$(___x_cmd_ui_region_get_leading_1_len "$___X_CMD_UI_GETCHAR_CHAR")
    if [ "$num" -eq 0 ]; then
        # TODO: When input space, it will give "${#___X_CMD_UI_GETCHAR_CHAR}" - eq 0
        
        # [ "${#___X_CMD_UI_GETCHAR_CHAR}" -eq 0 ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return

        num="$(printf "%d" "'$___X_CMD_UI_GETCHAR_CHAR")"
        # ___X_CMD_UI_GETCHAR_CHAR
        if [ "$num" -le 27 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-control"
        elif [ "$num" -le 31 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-seperator"
        elif [ "$num" -le 32 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-space"
        elif [ "$num" -le 47 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-0"
        elif [ "$num" -le 57 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-digit"
        elif [ "$num" -le 64 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-1"
        elif [ "$num" -le 90 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-letter-uppercase"
        elif [ "$num" -le 96 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-2"
        elif [ "$num" -le 122 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-letter-lowercase"
        elif [ "$num" -le 126 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-3"
        elif [ "$num" -le 127 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-delete"
        fi

    else
        local ch1="$___X_CMD_UI_GETCHAR_CHAR"
        ___X_CMD_UI_GETCHAR_TYPE="UTF8-MULTI-$num"
        ___x_cmd_ui_region_getchar_read1 "$((num-1))"
        ___X_CMD_UI_GETCHAR_CHAR="${ch1}${___X_CMD_UI_GETCHAR_CHAR}"
    fi
}

# shellcheck disable=SC2120
# region_getchar(){
#     if [ "$#" -eq 0 ]; then
#         _region_getchar
#     else
#         local s
#         s="$(_region_getchar)" || return
#         eval "$1=\$s"
#     fi
# }

# EndSection

# Section: select app
___x_cmd_ui_region_select_draw(){
    local select="$1"
    local text="$2"
    local prompt="$3"; shift 3
    {
        local l=0
        local arg
        printf "%s\n" "$prompt"
        for arg in "$@"; do
            l=$((l+1))
            if [ "$l" -eq "$select" ]; then
                printf "  $l. \033[7m%s\033[0m\n" "$arg"
            else
                printf "  $l. \033[32m%s\033[0m\n" "$arg"
            fi
        done
        printf "Input number: %s\n" "$text"
        printf "\n\033[2m%s\033[0m" "Use arrow up/down to select. Press ENTER to confirm."
    } | ___x_cmd_ui_region_send
}

___x_cmd_ui_region_select_main(){
    exec 3>&1
    local state=2           # default
    local state_text="2"
    local question="$1"; shift
    {
        ___x_cmd_ui_region_select_draw "$state" "$state_text" "$question" "$@"
        while region_getchar; do
            case "${___X_CMD_UI_GETCHAR_CHAR}" in
                UP)
                    if [ $state -eq -1 ]; then
                        state=$#
                    else
                        state="$((state-1))" 
                    fi
                    ;;
                DN)         
                    if [ $state -eq -1 ]; then
                        state=1
                    else
                        state="$((state+1))" 
                    fi
                    ;;
                ENTER)
                    break ;;
                DELETE)     
                    state_text="${state_text%?}"
                    if [ "$state_text" = "" ]; then
                        state=-1
                    elif [ "$state_text" -ge 1 ] && [ "$state_text" -le $# ]; then
                        state="$state_text"
                    else
                        state=-1
                    fi
                    ;;
                0|1|2|3|4|5|6|7|8|9)        
                    state_text="${state_text}${___X_CMD_UI_GETCHAR_CHAR}"
                    if [ "$state_text" = "" ]; then
                        state=-1
                    elif [ "$state_text" -ge 1 ] && [ "$state_text" -le $# ]; then
                        state="$state_text"
                    else
                        state=-1
                    fi
                    ;;
            esac
            if [ "$state" -eq -1 ]; then
                # state=$(( state % $# + $# ))
                state=-1
            else
                state=$(( (state + $# - 1 ) % $# + 1 ))
                state_text="$state"
            fi
            ___x_cmd_ui_region_select_draw "$state" "$state_text" "$question" "$@"
        done
        
        # Notice: Meaningless but important.
        ___x_cmd_ui_region_select_draw "$state" "$question" "$@"

        if [ "$state" -eq -1 ]; then
            case "$___UI_REGION_OUTPUT" in
                text)           printf "" ;;
                numtext)        printf "%s\n" -1 ;;
                ""|*)           printf "%s" "-1" ;;
            esac >&3
        else
            case "$___UI_REGION_OUTPUT" in
                text)           shift 1; eval printf "\"%s\"" "\"\$$state\"" ;;
                numtext)        shift 1; eval printf "\"%s\n%s\"" "\"$state\"" "\"\$$state\"" ;;
                ""|*)           printf "%s" "$state" ;;
            esac >&3
        fi
        
    } | ___x_cmd_ui_region_update
    # tput cvvis
    # stty echo
    exec 3>&-
}

___x_cmd_ui_region_select(){
    printf "%s" "$(___x_cmd_ui_region_select_main "$@")"
}

___x_cmd_ui_region_select_text(){
    printf "%s" "$(___UI_REGION_OUTPUT=text ___x_cmd_ui_region_select_main "$@")"
}

___x_cmd_ui_region_select_numtext(){
    printf "%s" "$(___UI_REGION_OUTPUT=numtext ___x_cmd_ui_region_select_main "$@")"
}

# EndSection

# Section: annimation

# Example code ...
___ui_region_demo0(){
    for percentage in $(seq 1 60); do

        case $(( percentage / 10 % 2 )) in
            0) 
            style=warn
            text="Important to say: Percentage is even.
1
2"
;;
            1) 
            style=error
            text="Hia hia. Percentage is odd.
hi";;
        esac

        # region send to stderr
        ___x_cmd_ui_region_send "
$(ui_seperator)
$(ui_style $style -- Initializing the storage)
$(ui_style info -- Prepare the UI "$percentage")

$(ui_style bold black -- Initializing the storage)
$(cowsay "$(ui_style warn -- "Hi Good work" "$percentage")" )
$(cowsay Hi Good work)
$(ui_style info -- "$text")
$(ui_seperator)
"
        sleep 0.1
    done | ___x_cmd_ui_region_update
    printf "\033[34h\033[?25h" 
}

# EndSection

# Section: question app
___x_cmd_ui_prompt_question_draw(){
    local question="$1"
    local answer="$2"; 
    local right="$3"
    shift 3
    {
        printf "\033[34;1m%s: " "$question"
        if [ -z "$right" ]; then
            printf "  \033[31;7m%s\033[0m\n" "$answer"
        else
            printf "  \033[32;1m%s\033[0m\n" "$answer"
        fi
    } | ___x_cmd_ui_region_send
}

xrc assert/v0

___x_cmd_ui_prompt_question_main(){
    exec 3>&1

    local question="${1:?Question}"
    shift 1

    local answer

    {
        ___x_cmd_ui_prompt_question_draw "$question" "$answer"
        while region_getchar; do
            case "$___X_CMD_UI_GETCHAR_CHAR" in
                UP|DN)  continue ;;
                ENTER)
                    break ;;
                DELETE)     
                    answer="${answer%?}"
                    ;;
                *)
                    case "$___X_CMD_UI_GETCHAR_TYPE" in
                        ascii-space|ascii-digit|ascii-letter-*|ascii-symbol-*|UTF8*)   
                            answer="${answer}${___X_CMD_UI_GETCHAR_CHAR}" ;;
                        *)
                            answer="${answer}${___X_CMD_UI_GETCHAR_CHAR}" ;;
                    esac
                    
            esac

            if assert "$answer" "$@" 2>/dev/null; then
                ___x_cmd_ui_prompt_question_draw "$question" "$answer" 1
            else
                ___x_cmd_ui_prompt_question_draw "$question" "$answer"
            fi
        done
        
        # Notice: Meaningless but important.
        ___x_cmd_ui_prompt_question_draw "$question" "$answer"

        # printf "\n"
        printf "%s" "$answer" >&3

    } | ___x_cmd_ui_region_update

    # tput cvvis
    # stty echo
    exec 3>&-
}

___x_cmd_ui_prompt_question(){
    printf "%s" "$(___x_cmd_ui_prompt_question_main "$@")"
}

# EndSection

# ___x_cmd_ui_prompt_question "Input answer" =~ [0-9]+

# ___x_cmd_ui_region_select_text \
#     "Please select the app you want to install:" \
#     "Install docker" \
#     "Install k8s" \
#     "Install minikube" \
#     "Install jvm" \
#     "Install nvm"


# Section: form app

xrc assert/v0


# dict

# dict @x_ui_prompt_form put selected 3
# dict @x_ui_prompt_form put result 1 

___ui_prompt_ui_inc(){
    local cur="${1:?cur}"
    local max="${2:?max}"
    
    if [ "$cur" -lt 1 ] && [ "$cur" -gt "$max" ]; then
        printf "%s" 1
        return
    fi

    cur=$((cur + 1))
    if [ $cur -gt "$max" ]; then
        cur=1
    fi
    printf "%s" "$cur"
}

___ui_prompt_ui_dec(){
    local cur="${1:?cur}"
    local max="${2:?max}"

    if [ "$cur" -lt 1 ] && [ "$cur" -gt "$max" ]; then
        printf "%s" "$max"
        return
    fi

    cur=$((cur - 1))
    if [ $cur -le 0 ]; then
        cur=$max
    fi
    printf "%s" "$cur"
}

___x_cmd_ui_prompt_form_draw(){
    local i
    local j
    local question
    local answer

    {
        case "$q_focus-$(dict @x_ui_prompt_form get "$q_current" 4)" in
            0-=)
                printf "%s\n\n" "Press <ENTER> to JUMP into selection. <Ctrl-D> to Exit. Arrow <UP> and <DOWN> to navigate. "
            ;;
        
            1-=)
                printf "%s\n\n" "Press <ENTER> to EXIT selection. <Ctrl-D> to Exit. Arrow <UP> and <DOWN> to navigate. "
            ;;

            0-=~)
                printf "%s\n\n" "Press <ENTER> to edit. <Ctrl-D> to Exit. Arrow <UP> and <DOWN> to navigate. "
            ;;

            1-=~)
                printf "%s\n\n" "Press <ENTER> to finish edit. <Ctrl-D> to Exit. Arrow <UP> and <DOWN> to navigate. "
            ;;
        esac

        for i in $(seq "$q_count"); do
            local question_type
            question_type="$(dict @x_ui_prompt_form get "$i" 4)"
            question="$(dict @x_ui_prompt_form get "$i" 1)"
            answer="$(dict @x_ui_prompt_form get "$i" answer)"

        
            # if [ -z "$answer" ] && [ "$question_type" != = ]; then
            #     answer="$(printf "\033[2m%s\033[0m" "          ")"
            # fi

            if [ "$q_current" != "$i" ]; then
                # Not current
                if [ "$q_focus" -eq 0 ]; then
                    printf "\033[36m%-16s %s\033[0m\n" "$question:" "$answer"
                else
                    printf "\033[36;2m%-16s %s\033[0m\n" "$question:" "$answer"
                fi
                continue
            fi
            
            if [ "$q_focus" -eq 0 ]; then
                printf "\033[36;7;1m%-16s %s\033[0m\n" "$question:" "$answer"

                if [ "$question_type" = = ]; then
                    for j in $(seq 5 "$(dict @x_ui_prompt_form get "$i" argc)"); do
                        if [ "$((j-4))" = "$answer" ]; then
                            printf "  \033[32;5;4m%s. %s\033[0m\n" $((j-4)) "$(dict @x_ui_prompt_form get "$i" "$j")"
                        else
                            printf "  \033[32;2m%s. %s\033[0m\n" $((j-4)) "$(dict @x_ui_prompt_form get "$i" "$j")"
                        fi
                    done
                fi
            else
                if [ "$question_type" = = ]; then
                    printf "\033[36;1m%-16s %s\033[0m\n" "$question:" "$(printf "%s\033[7m%s\033[0m" "$answer" " ")"

                    for j in $(seq 5 "$(dict @x_ui_prompt_form get "$i" argc)"); do
                        if [ "$((j-4))" = "$answer" ]; then
                            printf "  \033[32;7;4m%s. %s\033[0m\n" $((j-4)) "$(dict @x_ui_prompt_form get "$i" "$j")"
                        else
                            printf "  \033[32m%s. %s\033[0m\n" $((j-4)) "$(dict @x_ui_prompt_form get "$i" "$j")"
                        fi
                    done
                else
                    printf "\033[36;1m%-16s %s\033[0m\n" "$question:" "$answer"
                fi
            fi
        done 
    } | ___x_cmd_ui_region_send
}

___x_cmd_ui_prompt_form_main(){

    stty -echo

    local q_count=1
    local arg_count=0
    local arg

    xrc dict
    for arg in "$@"; do
        case "$arg" in
            --) 
                dict @x_ui_prompt_form put $q_count argc $arg_count
                q_count=$((q_count + 1))
                arg_count=0    
                ;;
            *)
                arg_count=$((arg_count + 1))
                dict @x_ui_prompt_form put $q_count $arg_count "$arg"
        esac
    done

    local i
    local j
    for i in $(seq $q_count); do
        local default
        default="$( dict @x_ui_prompt_form get "$i" 3 )"
        if [ "$( dict @x_ui_prompt_form get "$i" 4 )" = = ]; then
            local answer=1
            for j in $(seq 5 "$(dict @x_ui_prompt_form get "$i" argc)"); do
                if [ "$default" = "$( dict @x_ui_prompt_form get "$i" "$j" )" ]; then
                    answer=$(( j - 4 ))
                    break
                fi
            done
            dict @x_ui_prompt_form put "$i" answer "$answer"
        else
            dict @x_ui_prompt_form put "$i" answer "$default"
        fi
    done


    local question="${1:?Question}"
    shift 1

    exec 3>&1

    local q_current=1
    local q_focus=0

    {
        ___x_cmd_ui_prompt_form_draw
        while region_getchar; do
            case "$___X_CMD_UI_GETCHAR_CHAR" in
                UP|DN)
                    if [ $q_focus -eq 0 ]; then
                        if [ "$___X_CMD_UI_GETCHAR_CHAR" = UP ]; then
                            q_current=$(___ui_prompt_ui_dec "$q_current" $q_count)
                        else
                            q_current=$(___ui_prompt_ui_inc "$q_current" $q_count)
                        fi
                    else
                        case "$(dict @x_ui_prompt_form get "$q_current" 4)" in
                            =)   
                                { 
                                    local tmp_answer
                                    tmp_answer=$(dict @x_ui_prompt_form get "$q_current" answer)
                                    if [ -z "$tmp_answer" ]; then
                                        # default answer
                                        tmp_answer="$(dict @x_ui_prompt_form get "$q_current" 3)"
                                    fi
                                    tmp_answer_max=$(dict @x_ui_prompt_form get "$q_current" argc)
                                    tmp_answer_max=$((tmp_answer_max - 4))
                                    if [ "$___X_CMD_UI_GETCHAR_CHAR" = UP ]; then
                                        tmp_answer=$(___ui_prompt_ui_dec "${tmp_answer}" $tmp_answer_max)
                                    else
                                        tmp_answer=$(___ui_prompt_ui_inc "${tmp_answer}" $tmp_answer_max)
                                    fi
                                    dict @x_ui_prompt_form put "$q_current" answer "$tmp_answer"
                                } 2>/dev/null
                                # TODO: Find out which command output to stderr
                        esac
                    fi
                    ;;
                ENTER)
                    if [ "$q_focus" -eq 0 ]; then
                        q_focus=1
                    else
                        q_focus=0
                    fi ;;
                DELETE) 
                    local tmp_answer
                    tmp_answer=$(dict @x_ui_prompt_form get "$q_current" answer)
                    tmp_answer="${tmp_answer%?}"
                    dict @x_ui_prompt_form put "$q_current" answer "$tmp_answer"
                    ;;
                *)
                    # TODO: using a significant OK to exit.
                    if [ "$___X_CMD_UI_GETCHAR_CHAR" = "$(printf "\004")" ]; then
                        break
                    fi

                    if [ "$q_focus" -ne 0 ]; then
                        local tmp_answer
                        tmp_answer=$(dict @x_ui_prompt_form get "$q_current" answer)
                        if [ "$(dict @x_ui_prompt_form get "$q_current" 4)" = = ]; then
                            case "$___X_CMD_UI_GETCHAR_TYPE" in
                                ascii-digit)   
                                    tmp_answer="${tmp_answer}${___X_CMD_UI_GETCHAR_CHAR}" ;;
                            esac
                        else
                            case "$___X_CMD_UI_GETCHAR_TYPE" in
                                ascii-space|ascii-digit|ascii-letter-*|ascii-symbol-*|UTF8*)   
                                    tmp_answer="${tmp_answer}${___X_CMD_UI_GETCHAR_CHAR}" ;;
                            esac
                        fi
                        dict @x_ui_prompt_form put "$q_current" answer "$tmp_answer"
                    fi
            esac

            ___x_cmd_ui_prompt_form_draw
        done
        
        # Notice: Meaningless but important.
        ___x_cmd_ui_prompt_form_draw

        if [ "$OUTPUT" != "" ]; then
#             local ___X_CMD_UI_REGION_SEPERATOR="
# "
            for i in $(seq "$q_count"); do
                printf "%s%s%s%s" \
                    "$(dict @x_ui_prompt_form get "$i" 2)" "$___X_CMD_UI_REGION_SEPERATOR" \
                    "$(dict @x_ui_prompt_form get "$i" answer)" "$___X_CMD_UI_REGION_SEPERATOR" >&3
            done
        fi

    } | ___x_cmd_ui_region_update

    exec 3>&-

    tput cvvis
    stty echo
}

___x_cmd_ui_prompt_form(){
    local ___result="$(OUTPUT=1 ___x_cmd_ui_prompt_form_main "$@")"

    while :; do
        local head="${___result%%${___X_CMD_UI_REGION_SEPERATOR}*}"
        [ "$head" = "$___result" ] && break
        ___result="${___result#*${___X_CMD_UI_REGION_SEPERATOR}}"

        local value="${___result%%${___X_CMD_UI_REGION_SEPERATOR}*}"
        [ "$value" = "$___result" ] && break

        eval "$head=\"\$value\""
        ___result="${___result#*${___X_CMD_UI_REGION_SEPERATOR}}"
    done
}

___x_cmd_ui_prompt_form \
    "Access type" atype public = private public -- \
    "Repo Name" repo "" =~ abc1[0-9]+   -- \
    "User name" user "" =~ 12[0-9]+

# EndSection

# Section: TableApp


