# shellcheck shell=sh disable=SC3043

# author:       Li Junhao           l@x-cmd.com    edwinjhlee.github.io
# maintainer:   Li Junhao


# Section: region update

___X_CMD_UI_REGION_AWK="$(xrc which ui/_v0/region.awk)"
# ___X_CMD_UI_REGION_AWK=./region.awk

___X_CMD_UI_REGION_SEPERATOR="$(printf "\001")"

# shellcheck disable=SC2120
___x_cmd_ui_region_send(){
    if [ "$#" -eq 0 ]; then
        awk -v RS="$(printf "\001")" '{
            gsub("\n", "\001", $0)
            print($0)
        }'
        # printf "\n"
    else
        printf "%s" "$*" | awk -v RS="$(printf "\001")" '{
            gsub("\n", "\001", $0)
            print($0)
        }'
        # printf "\n"
    fi
}

xrc awk

___x_cmd_ui_region_update(){
    {
        local line
        # TODO: Consider get rid of it to improve performance.
        while read -r line; do
            printf "%s %s\n%s\n" UPDATE "$COLUMNS" "$line"
        done | {
            # awk  "$(cat $(xrc which awk/_v0/ui.awk)  $___X_CMD_UI_REGION_AWK)"
            # awk -f "$___X_CMD_UI_REGION_AWK"
            ___x_cmd_ui_region_update_awk
        }
    }
}

___x_cmd_ui_region_update_awk(){
    LC_ALL=en_US.UTF-8 USE=str,wcwidth,ui ___x_cmd_awk file "$___X_CMD_UI_REGION_AWK"
}

region_run(){
    exec 3>&1
    eval "$@" 2>&1 >&3 3>&- | ___x_cmd_ui_region_update
    exec 3>&-
}

# EndSection

# Section: readchar

if [ -n "$KSH_VERSION" ]; then

___x_cmd_ui_region_read_char(){
    stty -echo
    read -s -n 1 "$@"
    stty echo
}

else

___x_cmd_ui_region_read_char(){
    read -s -n 1 "$@"
}

fi

___X_CMD_UI_REGION_E="$(printf "\033")"
___X_CMD_UI_REGION_ENTER="$(printf "\015")"
___X_CMD_UI_REGION_BACKSPACE="$(printf "\010")"
___X_CMD_UI_REGION_DELETE="$(printf "\177")" # 7f


if [ -n "$BASH_VERSION" ]; then
___x_cmd_ui_region_getchar_read1(){
    local IFS="$(printf "\001")"
    read -rsn "${1:-1}" ___X_CMD_UI_GETCHAR_CHAR
}


elif [ -n "$ZSH_VERSION" ]; then

___x_cmd_ui_region_getchar_read1(){
    local IFS="$(printf "\001")"
    read -rsk "${1:-1}" ___X_CMD_UI_GETCHAR_CHAR
}

else

echo "Using stty for read1" >&2
___x_cmd_ui_region_getchar_read1(){
    stty raw
    ___X_CMD_UI_GETCHAR_CHAR="$(dd bs=1 count="${1:-1}" 2> /dev/null)"
    stty -raw
}

fi

___x_cmd_ui_region_get_leading_1_len(){
    local num
    num="$(printf "%d" "'$1")"
    if [ "$num" -ge 0 ]; then
        printf "%s\n" "0"
        return
    fi
    num=$((num + 256))
    local i
    for i in 0 1 2 3 4 5 6 7 8; do
        s=$(( (num << i) & 128 ))
        if [ "$s" -eq 0 ]; then
            printf "%s\n" "$i"
            return
        fi
    done
}

# Not worked in ksh. Using stty -echo

# This is how we handle UTF-8
# Reference: https://zh.wikipedia.org/wiki/UTF-8

___X_CMD_UI_GETCHAR_TYPE=
___X_CMD_UI_GETCHAR_CHAR=
region_getchar(){
    ___x_cmd_ui_region_getchar_read1

    ___X_CMD_UI_GETCHAR_TYPE=special

    # TODO: only the last enter worked. check and trim
    [ "${#___X_CMD_UI_GETCHAR_CHAR}" -eq 0 ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return
    [ "${___X_CMD_UI_GETCHAR_CHAR}" = "$___X_CMD_UI_REGION_ENTER" ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return
    # [ "${___X_CMD_UI_GETCHAR_CHAR}" = "$(printf "\012")" ] && printf "%s\n" ENTER && return
    # [ "${___X_CMD_UI_GETCHAR_CHAR}" = "$(printf "\n")" ] && printf "%s\n" ENTER && return
    [ "${___X_CMD_UI_GETCHAR_CHAR}" = "
" ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return

    if [ "$___X_CMD_UI_GETCHAR_CHAR" = "$___X_CMD_UI_REGION_E" ]; then
        ___x_cmd_ui_region_getchar_read1 # read 2 more chars

        case "$___X_CMD_UI_GETCHAR_CHAR" in
            \[) 
                ___x_cmd_ui_region_getchar_read1 # read 2 more chars
                case "$___X_CMD_UI_GETCHAR_CHAR" in
                    'A')       ___X_CMD_UI_GETCHAR_CHAR=UP  ;;
                    'B')       ___X_CMD_UI_GETCHAR_CHAR=DN  ;;
                    'D')       ___X_CMD_UI_GETCHAR_CHAR=LEFT ;;
                    'C')       ___X_CMD_UI_GETCHAR_CHAR=RIGHT ;;
                    *)         ___X_CMD_UI_GETCHAR_CHAR="[$___X_CMD_UI_GETCHAR_CHAR" ;;
                esac
                ;;
            q)  
                ___X_CMD_UI_GETCHAR_CHAR=QUITTING
                return 1
                ;;
            *)
                # ___X_CMD_UI_GETCHAR_CHAR="$___X_CMD_UI_GETCHAR_CHAR"
        esac
        return
    fi

    
    [ "$___X_CMD_UI_GETCHAR_CHAR" = "$___X_CMD_UI_REGION_BACKSPACE" ] && ___X_CMD_UI_GETCHAR_CHAR=BACKSPACE && return
    [ "$___X_CMD_UI_GETCHAR_CHAR" = "$___X_CMD_UI_REGION_DELETE" ] && {
        ___X_CMD_UI_GETCHAR_TYPE=ascii-delete
        ___X_CMD_UI_GETCHAR_CHAR=DELETE
        return
    }
    
    local num
    num=$(___x_cmd_ui_region_get_leading_1_len "$___X_CMD_UI_GETCHAR_CHAR")
    if [ "$num" -eq 0 ]; then
        # TODO: When input space, it will give "${#___X_CMD_UI_GETCHAR_CHAR}" - eq 0
        
        # [ "${#___X_CMD_UI_GETCHAR_CHAR}" -eq 0 ] && ___X_CMD_UI_GETCHAR_CHAR=ENTER && return

        num="$(printf "%d" "'$___X_CMD_UI_GETCHAR_CHAR")"
        # ___X_CMD_UI_GETCHAR_CHAR
        if [ "$num" -le 27 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-control"
        elif [ "$num" -le 31 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-seperator"
        elif [ "$num" -le 32 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-space"
        elif [ "$num" -le 47 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-0"
        elif [ "$num" -le 57 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-digit"
        elif [ "$num" -le 64 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-1"
        elif [ "$num" -le 90 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-letter-uppercase"
        elif [ "$num" -le 96 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-2"
        elif [ "$num" -le 122 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-letter-lowercase"
        elif [ "$num" -le 126 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-symbol-3"
        elif [ "$num" -le 127 ]; then
            ___X_CMD_UI_GETCHAR_TYPE="ascii-delete"
        fi

    else
        local ch1="$___X_CMD_UI_GETCHAR_CHAR"
        ___X_CMD_UI_GETCHAR_TYPE="UTF8-MULTI-$num"
        ___x_cmd_ui_region_getchar_read1 "$((num-1))"
        ___X_CMD_UI_GETCHAR_CHAR="${ch1}${___X_CMD_UI_GETCHAR_CHAR}"
    fi
}

# shellcheck disable=SC2120
# region_getchar(){
#     if [ "$#" -eq 0 ]; then
#         _region_getchar
#     else
#         local s
#         s="$(_region_getchar)" || return
#         eval "$1=\$s"
#     fi
# }

# EndSection


# Section: annimation

# Example code ...
___ui_region_demo0(){
    for percentage in $(seq 1 60); do

        case $(( percentage / 10 % 2 )) in
            0) 
            style=warn
            text="Important to say: Percentage is even.
1
2"
;;
            1) 
            style=error
            text="Hia hia. Percentage is odd.
hi";;
        esac

        # region send to stderr
        ___x_cmd_ui_region_send "
$(ui_seperator)
$(ui_style $style -- Initializing the storage)
$(ui_style info -- Prepare the UI "$percentage")

$(ui_style bold black -- Initializing the storage)
$(cowsay "$(ui_style warn -- "Hi Good work" "$percentage")" )
$(cowsay Hi Good work)
$(ui_style info -- "$text")
$(ui_seperator)
"
        sleep 0.1
    done | ___x_cmd_ui_region_update
    printf "\033[34h\033[?25h" 
}

# EndSection

# Section: question app
___x_cmd_ui_prompt_question_draw(){
    local question="$1"
    local answer="$2"; 
    local right="$3"
    shift 3
    {
        printf "\033[34;1m%s: " "$question"
        if [ -z "$right" ]; then
            printf "  \033[31;7m%s\033[0m\n" "$answer"
        else
            printf "  \033[32;1m%s\033[0m\n" "$answer"
        fi
    } | ___x_cmd_ui_region_send
}

xrc assert/latest

___x_cmd_ui_prompt_question_main(){
    exec 3>&1

    local question="${1:?Question}"
    shift 1

    local answer

    {
        ___x_cmd_ui_prompt_question_draw "$question" "$answer"
        while region_getchar; do
            case "$___X_CMD_UI_GETCHAR_CHAR" in
                UP|DN)  continue ;;
                ENTER)
                    break ;;
                DELETE)     
                    answer="${answer%?}"
                    ;;
                *)
                    case "$___X_CMD_UI_GETCHAR_TYPE" in
                        ascii-space|ascii-digit|ascii-letter-*|ascii-symbol-*|UTF8*)   
                            answer="${answer}${___X_CMD_UI_GETCHAR_CHAR}" ;;
                        *)
                            answer="${answer}${___X_CMD_UI_GETCHAR_CHAR}" ;;
                    esac
                    
            esac

            if assert "$answer" "$@" 2>/dev/null; then
                ___x_cmd_ui_prompt_question_draw "$question" "$answer" 1
            else
                ___x_cmd_ui_prompt_question_draw "$question" "$answer"
            fi
        done
        
        # Notice: Meaningless but important.
        ___x_cmd_ui_prompt_question_draw "$question" "$answer"

        # printf "\n"
        printf "%s" "$answer" >&3

    } | ___x_cmd_ui_region_update

    # tput cvvis
    # stty echo
    exec 3>&-
}

___x_cmd_ui_prompt_question(){
    printf "%s" "$(___x_cmd_ui_prompt_question_main "$@")"
}

# EndSection

