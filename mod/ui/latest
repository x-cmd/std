# shellcheck shell=sh disable=SC3043 # xrc

# author:       Li Junhao           l@x-cmd.com

# Section: define lazy loader
___x_cmd_definelazyloader   ___x_cmd_ui_table         ui/lib/table
___x_cmd_definelazyloader   ___x_cmd_ui_select        ui/lib/select
___x_cmd_definelazyloader   ___x_cmd_ui_gridselect    ui/lib/gridselect
___x_cmd_definelazyloader   ___x_cmd_ui_form          ui/lib/form
___x_cmd_definelazyloader   ___x_cmd_ui_tf            ui/lib/truefalse
___x_cmd_definelazyloader   ___x_cmd_ui_prompt        ui/lib/prompt
# ___x_cmd_definelazyloader   ___x_cmd_ui_markdown      ui/lib/markdown

# EndSection

# Section : ui major function and facilities and init
___x_cmd_ui(){
    local f="$1"
    shift
    case "$f" in
        http://* | https://* | ftp://* |ftps://* | git://* )        ___x_cmd_ui_url "$f" "$@" ;;
        :)                                                          ___x_cmd_ui_print_var "$f" "$@" ;;
        progressbar|probar)                                         ___x_cmd_ui_progressbar "$@" ;;
        cmd|cmdline)                                                ___x_cmd_ui_cmdline "$@" ;;
        table)                                                      ___x_cmd_ui_table  "$@" ;;
        gridselect)                                                 ___x_cmd_ui_gridselect "$@" ;;
        select)                                                     ___x_cmd_ui_select "$@" ;;
        form)                                                       ___x_cmd_ui_form "$@" ;;
        tf|truefalse)                                               ___x_cmd_ui_tf "$@" ;;
        prompt)                                                     ___x_cmd_ui_prompt "$@" ;;
        # md|markdown)                                                ___x_cmd_ui_markdown "$@" ;;
        spin)                                                       ___x_cmd_ui_spin "$@" ;;
        sep)                                                        ___x_cmd_ui_sep "$@" ;;
        sep2)                                                       ___x_cmd_ui_sep2 "${1:--}" $(( $(___x_cmd_ui cols) / 2 )) ;;
        sep3)                                                       ___x_cmd_ui_sep3 "${1:--}" $(( $(___x_cmd_ui cols) / 3 )) ;;

        cols)                                                       printf "%s" "$COLUMNS" ;;
        rows)                                                       printf "%s" "$LINES" ;;

        style)                                                      ___x_cmd_ui_style "$@" ;;
        *)                                                          ___x_cmd_ui_style "$f" "$@" ;;
    esac
}

# EndSection

# Section : init

# Thank ryenus, iRaS and Mekcki for answers in https://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window
___x_cmd_ui_init_lines_columns(){
    local IFS
    IFS=" "
    read -r LINES COLUMNS <<A
$(stty size)
A
}

___x_cmd_ui_init_lines_columns

if read -p " " -e ___UI_TMP_TEST 1>/dev/null 2>/dev/null <<A
hi
A
then

___x_cmd_ui_read(){
    local varname="${1:?Provide varname}"
    read -p " " -e -r "$varname"
}

else

___x_cmd_ui_read(){
    local varname="${1:?Provide varname}"
    printf "%s" " "
    read -r "$varname"
}
fi

___UI_TMP_TEST=

# EndSection

# Section : ui style
___x_cmd_ui_colorcode(){
    case "$1" in
        black)      printf 0 ;;
        red)        printf 1 ;;
        green)      printf 2 ;;
        yellow)     printf 3 ;;
        blue)       printf 4 ;;
        magenta)    printf 5 ;;
        cyan)       printf 6 ;;
        white)      printf 7 ;;
    esac
}

if command -v tput 1>/dev/null 2>&1; then

# For some advancing usage. Refer to http://linuxcommand.org/lc3_adv_tput.php
# tput: https://www.gnu.org/software/termutils/manual/termutils-2.0/html_chapter/tput_1.html

___x_cmd_ui_tput(){
    local op="$1"; shift
    case "$op" in
        cursor_read)                ___x_cmd_ui_cursor_read "$@";;
        screen)                     ___x_cmd_ui_screen "$@" ;;

        sc|cursor_save)             tput sc ;;
        rc|cursor_restore)          tput rc ;;

        cnorm|cursor_normal)        tput cnorm ;;
        cvvis|cursor_show)          tput cvvis ;;
        civis|cursor_hide)          tput civis ;;

        smcup|screen_save)          tput smcup ;;
        rmcup|screen_restore)       tput rmcup ;;


        *)                          tput "$op" "$@" ;;
    esac
}


else

___x_cmd_ui_tput(){
    local op="$1"; shift
    case "$op" in
        cursor_read)                ___x_cmd_ui_cursor_read "$@";;
        screen)                     ___x_cmd_ui_screen "$@" ;;

        sc|cursor_save)             printf "\0337" ;;
        rc|cursor_restore)          printf "\0338" ;;

        cnorm|cursor_normal)        printf "\033[34h\033[?25h" ;;
        cvvis|cursor_show)          printf "\033[34l" ;;
        civis|cursor_hide)          printf "\033[?25l" ;;

        smcup|screen_save)          printf "\033[?1049h" ;;
        rmcup|screen_restore)       printf "\033[?1049l" ;;

        el)                         printf "\033[K" ;;
        el1)                        printf "\033[1K" ;;
        cuu)                        printf "\033[%sA" "${2:?Provide number of line to move up}" ;;
    esac
}

fi

___x_cmd_ui_style(){
    local IFS=" "
    while [ $# -gt 0 ]; do
        case "$1" in
            dim|debug)                                              printf "\033[2m"                                            ;; # tput dim;;
            info)                                                   printf "\033[1;36m"                                         ;;
            error)                                                  printf "\033[1;31m"                                         ;;
            warn)                                                   printf "\033[1;33m"                                         ;;
            normal)                                                 printf "\033[0m"                                            ;;  # tput bold
            bold)                                                   printf "\033[1m"                                            ;;  # tput bold
            underline|smul)                                         printf "\033[4m"                                            ;; # tput dim;;
            rmul)                                                   printf "\033[24m"                                           ;; # tput dim;;
            black|red|green|yellow|blue|magenta|cyan|white)         printf "\033[3$(___x_cmd_ui_colorcode "$1")m"               ;;
            bfg-*)                                                  printf "\033[1;3$(___x_cmd_ui_colorcode "${1#bfg-}")m"      ;;
            hfg-*)                                                  printf "\033[9$(___x_cmd_ui_colorcode "${1#hfg-}")m"        ;;
            rgbfg-*)                                                printf "\033[38;5;${1#rgbfg-}m"                             ;;
            bg-*)                                                   printf "\033[4$(___x_cmd_ui_colorcode "${1#bg-}")m"         ;;
            hbg-*)                                                  printf "\033[10$(___x_cmd_ui_colorcode "${1#hbg-}")m"       ;;
            rgbbg-*)                                                printf "\033[48;5;${1#rgbbg-}m"                             ;;
            rev)                                                    printf "\033[7m"                                            ;;
            end)                                                    printf "\033[0m"                                            ;;
            reset)                                                  tput reset                                                  ;;
            --)                                                     shift; printf "%s\033[0m" "$*"; return ;;
            *)                                                      printf "%s\033[0m" "$*"; return
        esac
        shift
    done
}

# EndSection

# Section : cmdline URL, sep, sep2, sep3

___x_cmd_ui_cmdline(){
    local prompt=${1:-">"}

    # if [ ! -t 0 ]; then
    if [ $# -gt 1 ]; then
        shift;
        printf "$(___x_cmd_ui bold yellow)${prompt} $(___x_cmd_ui normal white)%s$(___x_cmd_ui end)\n" "$*"
    else
        local line
        while read -r line; do
            printf "$(___x_cmd_ui bold yellow)${prompt} $(___x_cmd_ui normal white)%s$(___x_cmd_ui end)\n" "$line"
        done
    fi
}

___x_cmd_ui_url(){
    printf "$(___x_cmd_ui smul)%s$(___x_cmd_ui rmul)" "${1:?Provide URL}"
}

___x_cmd_ui_draw_seperator(){
    local sep=""
    local _i=1
    local maxw
    maxw="$(___x_cmd_ui cols)"
    while [ "$_i" -lt "$maxw" ];do
        sep="$sep""${1:-—}"
        _i="$((_i+1))"
    done
    printf "$sep\n"
}

___x_cmd_ui_sep(){
    local maxw="${2:?$COLUMNS}"

    # TODO: Introducing a much better solution
    # printf "%s\n" "$(seq -f "\xE2\x80\x95" -s '' "$COLUMNS")"
    local sep
    sep="$(seq -f "${1:-—}" -s '' "$maxw")"
    printf "%s\n" "$sep"
}

___x_cmd_ui_spin(){
    local c=$(( $1 % 4 ))
    local i
    case "$c" in
        0)  printf "\\"  ;;
        1)  printf "|"   ;;
        2)  printf "/"   ;;
        3)  printf "-"   ;;
    esac
}

# EndSection

# Section : progress

# shellcheck disable=SC2120
___x_cmd_ui_progressbar(){
    local maxw=80
    [ "$COLUMNS" -lt "$maxw" ] && maxw=$COLUMNS

    if [ -n "$3" ]; then    printf "%s\n" "$3"
    else                    cat;
    fi | command awk -v ch="${1:-\*}" -v other="${2:-" "}" -v maxw="$COLUMNS" '
function str_rep(char, number, _i, _s) {
    for (   _i=1; _i<=number; ++_i  ) _s = _s char
    return _s
}

function print_progressbar(percent,         _width, _space, _stars, _s){
    _width = maxw - 30
    _stars = _width
    _stars = int(_stars * percent / 100)
    _space = _width - _stars

    s = str_rep(ch, _stars) str_rep(other, _space)

    if (percent == 100)     printf("( DONE! )|%s|", s)
    else                    printf("( %3d %% )|%s|", percent, s)
}

NR==1{
    print_progressbar($0)
    fflush()
}
NR>=2{
    printf("\r")
    print_progressbar($0)
    fflush()
}
'
}

___x_cmd_ui_progressbar_test(){
    for i in $(seq 0 100); do
        printf "%s\n" "$i"
        sleep 0.01s
    done | ___x_cmd_ui_progressbar
}

# EndSection

# Section : tput facility: cursor
# reference: https://unix.stackexchange.com/questions/88296/get-vertical-cursor-position/183121#183121
# TODO: Not work in alpine. Find out a way to work in alpine.
# Notice: I think I already put enough effort in it. Since we cannot get the cursor position, we have to do the control by ourself thus we always know where the cursor is.
___x_cmd_ui_cursor_read(){
    local cv
    local ch
    local IFS
    # tput u7                  # Inquire for cursor position
    # read -sdR CURPOS         # Read cursor position
    # IFS=\; read cv ch <<<"${CURPOS#$'\e['}" # split $CURPOS

    # TODO: Use something better
    # IFS=';' read -sdR -p $'\E[6n' cv ch
    IFS=';' read -sdR -p "$(printf "\033[6n")" cv ch
    cv="${cv#*[}"

    case $# in
        0)  printf "%s %s\n" "$cv" "$ch";;
        1)  eval "$1=$cv";;
        *)
            eval "$1=$cv";
            eval "$2=$ch";;
    esac
}

___x_cmd_ui_line_count(){
    local maxw="$COLUMNS"
    local n
    local IFS
    local linenum=0
    while read -r n; do
        linenum=$(( linenum + ( ${#n} + maxw - 1 ) / maxw ))
    done
    printf "%s" "$linenum"
}

# EndSection

# Section : screen design -- tput screen facility

___x_cmd_ui_screen() {
    ___x_cmd_ui_tput screen_save
    eval "$@"
    ___x_cmd_ui_tput screen_restore
}

___x_cmd_ui_banner() {
    # echo -n ${BG:-$UI_BG_BLUE}${FG:-$UI_FG_WHITE}
    local FG
    local BG
    FG=$(tput setaf "${1:-$UI_WHITE}")
    BG=$(tput setab "${2:-$UI_BLUE}")
    echo "$FG$BG"
    clear
    cat
}

RUN_CMD_WITH_INFO() {
    local INFO=$1
    shift 1
    INFO "======================\n"
    INFO "$INFO\n"
    INFO "======================\n"
    eval "$@"
}

RUN_CMD_WITH_STEP() {
    local STEP=$1
    local INFO="STEP $STEP: $2"
    shift 2
    RUN_CMD_WITH_INFO "$INFO" "$@"
}

# EndSection

# Section : interactive component
___x_cmd_ui_check_cmd_run(){
    local msg="${1:?Please Provide message}"; shift

    # TODO: Consider using trap or other method to interrupt the par animation
    local filepath
    filepath="$TMPDIR/___x_cmd_ui_check_cmd_run.$$.$(date +%s).txt"
    {
        eval "$@"
        printf "%s" "$?" > "$filepath"
    } | {
        local i="-"
        local FMT="\r$(___x_cmd_ui blue)$(___x_cmd_ui bold)%s       $(___x_cmd_ui end)$(___x_cmd_ui yellow)%s$(___x_cmd_ui end)"
        printf "$FMT" "$i" "$msg"
        while [ ! -f "$filepath" ]; do
            sleep 0.1
            case "$i" in
                -)  i="\\"  ;;
                \\) i="|"   ;;
                \|) i="/"   ;;
                /)  i="-"   ;;
            esac
            printf "$FMT" "$i" "$msg"
        done
        return "$(cat "$filepath"; rm "$filepath" 2>/dev/null)"
    }
}

___x_cmd_ui_check_cmd(){
    local msg="${1:?Please Provide message}";
    if ___x_cmd_ui_check_cmd_run "$@"; then
        printf "\r$(___x_cmd_ui green)$(___x_cmd_ui bold)%s       %s$(___x_cmd_ui end)"  "√" "$msg"
    else
        local code=$?
        printf "\r$(___x_cmd_ui red)$(___x_cmd_ui bold)%s       %s$(___x_cmd_ui end)"    "X" "$msg"
        return "$code"
    fi
}
# EndSection

# Section other unused
# Maybe not useful
___x_cmd_ui_yesno() {
    local p
    while true; do
        printf "%s" "$1 (Input 'y' for yes or 'n' for no):"
        ___x_cmd_ui_read p
        # remove space
        case $p in
            y)          return 0 ;;
            n)          return 1 ;;
        esac
    done
}

___x_cmd_ui_yesno_enter() {
    local p
    while true; do
        printf "%s" "$1 (Press Enter or y for yes, otherwise no):"
        ___x_cmd_ui_read p
        # remove space
        case $p in
            y|"")           return 0    ;;
            *)              return 1    ;;
        esac
    done
}

___x_cmd_ui_readint() {
    local min=${1:?Provide min}
    local max=${2:?Provide max}

    local choice
    while true; do
        printf "%s" "${3:-Read integer: }"
        ___x_cmd_ui_read choice
        if [ "$choice" -ge "$min" ] && [ "$choice" -le "$max" ]; then
            printf "%s" "$choice"
            return 0
        fi 2>/dev/null
    done
}
# EndSection

xrc setmain ___x_cmd_ui
